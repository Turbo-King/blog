[{"categories":["Markdown"],"content":"JVM虚拟机","date":"2024-07-22","objectID":"/blog/20240722_jvm/","tags":["java","jvm","虚拟机","jvm原理"],"title":"JVM 原理拙见","uri":"/blog/20240722_jvm/"},{"categories":["Markdown"],"content":" 注意 一个 注意 横幅 摘要 一个 摘要 横幅 信息 一个 信息 横幅 技巧 一个 技巧 横幅 成功 一个 成功 横幅 问题 一个 问题 横幅 警告 一个 警告 横幅 失败 一个 失败 横幅 危险 一个 危险 横幅 Bug 一个 Bug 横幅 示例 一个 示例 横幅 引用 一个 引用 横幅 ","date":"2024-07-22","objectID":"/blog/20240722_jvm/:0:0","tags":["java","jvm","虚拟机","jvm原理"],"title":"JVM 原理拙见","uri":"/blog/20240722_jvm/"},{"categories":["Markdown"],"content":"概念 JVM 是 Java 的核心和基础，处于 Java 编译器和 OS 平台之间的虚拟处理器。它是一种利用软件方法实现的抽象的计算机基于下层的操作系统和硬件平台，可以在上面执行 Java 的字节码程序。Java 编译器只要面向 JVM，生成 JVM 能够理解的代码或字节码文件。Java 源文件经编译成字节码程序，通过 JVM 将每一条指令翻译成不同平台机器码，通过特定的平台运行。 ","date":"2024-07-22","objectID":"/blog/20240722_jvm/:1:0","tags":["java","jvm","虚拟机","jvm原理"],"title":"JVM 原理拙见","uri":"/blog/20240722_jvm/"},{"categories":["Markdown"],"content":"JVM的生命周期 JVM 的诞生：当启动一个 Java 程序时，一个 JVM 实例就产生了，任何一个拥有public static void main(String[] args)函数的 class 都可以作为 JVM 实例运行的起点。 JVM 实例的运行：main() 作为该程序初始线程的起点，任何其他线程均由该线程启动。JVM 内部有两种线程：守护线程和非守护线程，main() 属于非守护线程，守护线程通常由 JVM 自己使用，Java 程序也可以标明自己创建的线程是守护线程。 JVM 实例的消亡：当程序中的所有非守护线程都终止时，JVM 才退出；若安全管理器允许，程序也可以使用 java.lang.Runtime 类或者 java.lang.System.exit() 来退出。 ","date":"2024-07-22","objectID":"/blog/20240722_jvm/:2:0","tags":["java","jvm","虚拟机","jvm原理"],"title":"JVM 原理拙见","uri":"/blog/20240722_jvm/"},{"categories":["Markdown"],"content":"JVM运行内存模型 概念：JVM 把文件 .class 字节码加载到内存，对数据进行校验，转换和解析，并初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。 类加载机制 ","date":"2024-07-22","objectID":"/blog/20240722_jvm/:3:0","tags":["java","jvm","虚拟机","jvm原理"],"title":"JVM 原理拙见","uri":"/blog/20240722_jvm/"},{"categories":["Markdown"],"content":"类装载器 类加载器的任务是根据一个类的全限定名来读取此类的二进制字节流到 JVM 中，然后转换为一个与目标对应的 java.lang.Class 对象实例 虚拟机提供的四类类加载机制 启动类加载器（Bootstrap ClassLoader） C++ 编写，加载 Java 核心 java.* 这个类加载器负载放在 \u003cJAVA_HOME\u003e/lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中，并且是虚拟机识别的类库。用户无法直接使用。 由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。 扩展类加载器（Extend加） ","date":"2024-07-22","objectID":"/blog/20240722_jvm/:3:1","tags":["java","jvm","虚拟机","jvm原理"],"title":"JVM 原理拙见","uri":"/blog/20240722_jvm/"},{"categories":["Technology"],"content":"Linux systemctl systemd","date":"2024-06-26","objectID":"/blog/20240626_systemd/","tags":["Linux","systemctl","system"],"title":"Systemd 学习","uri":"/blog/20240626_systemd/"},{"categories":["Technology"],"content":"由来 根据我了解到，历史上,Linux的启动一直采用init进程。 下面的命令用来启动服务。 $ sudo /etc/init.d/apache2 start # 或者 $ service apache2 start 这种方法有两个缺点 启动时间长。init进程是串行启动，只有前一个进程启动完成，才会启动下一个进程。 启动脚本复杂。init进程只是执行启动脚本，不管其他事情。脚本需要自己处理各种情况，这往往使得脚本变得很长。 ","date":"2024-06-26","objectID":"/blog/20240626_systemd/:1:0","tags":["Linux","systemctl","system"],"title":"Systemd 学习","uri":"/blog/20240626_systemd/"},{"categories":["Technology"],"content":"Systemd 概述 Systemd 就是为了解决解决这些问题而诞生的。它的设计目标是，为系统的启动和管理提供一套完整的解决方案。 根据 Linux 惯例，字母d是守护进程（daemon）的缩写。Systemd 这个名字的含义，就是要守护整个 Linux 系统。 Systemd作者 （上图为 Systemd 作者 Lennart Poettering） 使用了 Systemd，就不需要再使用init了。Systemd 取代了init，成为系统的第一个进程（PID = 1），其他进程都是它的子进程。 $ systemctl --version 上面命令用于查看本机器 Systemd 的版本。 ","date":"2024-06-26","objectID":"/blog/20240626_systemd/:2:0","tags":["Linux","systemctl","system"],"title":"Systemd 学习","uri":"/blog/20240626_systemd/"},{"categories":["Technology"],"content":"系统管理 Systemd 并不是一个命令，而是一组命令，涉及到系统管理的方方面面。 ","date":"2024-06-26","objectID":"/blog/20240626_systemd/:3:0","tags":["Linux","systemctl","system"],"title":"Systemd 学习","uri":"/blog/20240626_systemd/"},{"categories":["Technology"],"content":"systemctl systemctl是 Systemd 的主命令，用于管理系统。 # 重启系统 $ sudo systemctl reboot # 关闭系统，切断电源 $ sudo systemctl poweroff # CPU停止工作 $ sudo systemctl halt # 暂停系统 $ sudo systemctl suspend # 让系统进入冬眠状态 $ sudo systemctl hibernate # 让系统进入交互式休眠状态 $ sudo systemctl hybrid-sleep # 启动进入救援状态（单用户状态） $ sudo systemctl rescue ","date":"2024-06-26","objectID":"/blog/20240626_systemd/:3:1","tags":["Linux","systemctl","system"],"title":"Systemd 学习","uri":"/blog/20240626_systemd/"},{"categories":["Technology"],"content":"systemd-analyze systemd-analyze命令用于查看启动耗时 # 查看启动耗时 $ systemd-analyze # 查看每个服务的启动耗时 $ systemd-analyze blame # 显示瀑布状的启动过程流 $ systemd-analyze critical-chain # 显示指定服务的启动流 $ systemd-analyze critical-chain atd.service ","date":"2024-06-26","objectID":"/blog/20240626_systemd/:3:2","tags":["Linux","systemctl","system"],"title":"Systemd 学习","uri":"/blog/20240626_systemd/"},{"categories":["Technology"],"content":"hostnamectl homenamectl命令用于查看当前主机的信息 # 显示当前主机的信息 $ hostnamectl # 设置主机名。 $ sudo hostnamectl set-hostname rhel7 ","date":"2024-06-26","objectID":"/blog/20240626_systemd/:3:3","tags":["Linux","systemctl","system"],"title":"Systemd 学习","uri":"/blog/20240626_systemd/"},{"categories":["Technology"],"content":"timedatectl timedatectl命令用于查看当前时区设置 # 查看当前时区设置 $ timedatectl # 显示所有可用的时区 $ timedatectl list-timezones # 设置当前时区 $ sudo timedatectl set-timezone America/New_York $ sudo timedatectl set-time YYYY-MM-DD $ sudo timedatectl set-time HH:MM:SS ","date":"2024-06-26","objectID":"/blog/20240626_systemd/:3:4","tags":["Linux","systemctl","system"],"title":"Systemd 学习","uri":"/blog/20240626_systemd/"},{"categories":["Technology"],"content":"loginctl loginctl命令用于查看当前的登陆用户 # 列出当前session $ loginctl list-sessions # 列出当前登录用户 $ loginctl list-users # 列出显示指定用户的信息 $ loginctl show-user ruanyf ","date":"2024-06-26","objectID":"/blog/20240626_systemd/:3:5","tags":["Linux","systemctl","system"],"title":"Systemd 学习","uri":"/blog/20240626_systemd/"},{"categories":["Technology"],"content":"Unit ","date":"2024-06-26","objectID":"/blog/20240626_systemd/:4:0","tags":["Linux","systemctl","system"],"title":"Systemd 学习","uri":"/blog/20240626_systemd/"},{"categories":["Technology"],"content":"含义 Systemd 可以管理所有系统资源。不同的资源统称为Unit（单位） Unit种类 Service unit：系统服务 Target unit：多个 Unit 构成的一个组 Device Unit：硬件设备 Mount Unit：文件系统的挂载点 Automount Unit：自动挂载点 Path Unit：文件或路径 Scope Unit：不是由 Systemd 启动的外部进程 Slice Unit：进程组 Snapshot Unit：Systemd 快照，可以切回某个快照 Socket Unit：进程间通信的 socket Swap Unit：swap 文件 Timer Unit：定时器 systemctl list-units命令可以查看当前系统的所有 Unit # 列出正在运行的 Unit $ systemctl list-units # 列出所有Unit，包括没有找到配置文件的或者启动失败的 $ systemctl list-units --all # 列出所有没有运行的 Unit $ systemctl list-units --all --state=inactive # 列出所有加载失败的 Unit $ systemctl list-units --failed # 列出所有正在运行的、类型为 service 的 Unit $ systemctl list-units --type=service ","date":"2024-06-26","objectID":"/blog/20240626_systemd/:4:1","tags":["Linux","systemctl","system"],"title":"Systemd 学习","uri":"/blog/20240626_systemd/"},{"categories":["Technology"],"content":"Unit 状态 systemctl status命令用于查看系统状态和单个 Unit 的状态 # 显示系统状态 $ systemctl status # 显示单个 Unit 的状态 $ sysystemctl status bluetooth.service # 显示远程主机的某个 Unit 的状态 $ systemctl -H root@rhel7.example.com status httpd.service 除了status命令，systemctl还提供了三个查询状态的简单方法，主要供脚本内部的判断语句使用 # 显示某个 Unit 是否正在运行 $ systemctl is-active application.service # 显示某个 Unit 是否处于启动失败状态 $ systemctl is-failed application.service # 显示某个 Unit 服务是否建立了启动链接 $ systemctl is-enabled application.service ","date":"2024-06-26","objectID":"/blog/20240626_systemd/:4:2","tags":["Linux","systemctl","system"],"title":"Systemd 学习","uri":"/blog/20240626_systemd/"},{"categories":["Technology"],"content":"Unit 管理 对于用户来说，最常用的是下面这些命令，用于启动和停止 Unit（主要是 service） # 立即启动一个服务 $ sudo systemctl start apache.service # 立即停止一个服务 $ sudo systemctl stop apache.service # 重启一个服务 $ sudo systemctl restart apache.service # 杀死一个服务的所有子进程 $ sudo systemctl kill apache.service # 重新加载一个服务的配置文件 $ sudo systemctl reload apache.service # 重载所有修改过的配置文件 $ sudo systemctl daemon-reload # 显示某个 Unit 的所有底层参数 $ systemctl show httpd.service # 显示某个 Unit 的指定属性的值 $ systemctl show -p CPUShares httpd.service # 设置某个 Unit 的指定属性 $ sudo systemctl set-property httpd.service CPUShares=500 ","date":"2024-06-26","objectID":"/blog/20240626_systemd/:4:3","tags":["Linux","systemctl","system"],"title":"Systemd 学习","uri":"/blog/20240626_systemd/"},{"categories":["Technology"],"content":"依赖关系 Unit 之间存在依赖关系：A 依赖于 B，就意味着 Systemd 在启动 A 的时候，同时会去启动 B systemctl list-dependencies命令列出一个 Unit 的所有依赖。 $ systemctl list-dependencies nginx.service 上面命令的输出结果之中，有些依赖是 Target 类型（详见下文），默认不会展开显示。如果要展开 Target，就需要使用--all参数。 systemctl list-dependencies --all nginx.service ","date":"2024-06-26","objectID":"/blog/20240626_systemd/:4:4","tags":["Linux","systemctl","system"],"title":"Systemd 学习","uri":"/blog/20240626_systemd/"},{"categories":["Technology"],"content":"Unit 的配置文件 ","date":"2024-06-26","objectID":"/blog/20240626_systemd/:5:0","tags":["Linux","systemctl","system"],"title":"Systemd 学习","uri":"/blog/20240626_systemd/"},{"categories":["Technology"],"content":"概述 每一个 Unit 都有一个配置文件，告诉 Systemd 怎么启动这个 Unit。 Systemd 默认从目录/etc/systemd/system/读取配置文件。但是，里面存放的大部分文件都是符号链接，指向目录/usr/lib/systemd/system/，真正的配置文件存放那个目录。 systemd enbale命令用于在上面两个目录之间，建立符号链接关系。 $ sudo systemctl enable custom.service # 等同于 $ sudo ln -s '/usr/lib/systemd/system/custom.service' '/etc/systemd/system/multi-user.target.wants/custom.service' 如果配置文件里面设置了开机启动，systemd enable命令相当于激活开机启动。 与之对应的，systemd disable命令用于在两个目录之间，撤销符号链接关系，相当于撤销开机启动。 $ sudo systemctl disable custom.service 配置文件的后缀名，就是该 Unit 的种类，比如sshd。socked。如果省略，Systemd 默认后缀名为.service，所以sshd会被理解成sshd.service。 ","date":"2024-06-26","objectID":"/blog/20240626_systemd/:5:1","tags":["Linux","systemctl","system"],"title":"Systemd 学习","uri":"/blog/20240626_systemd/"},{"categories":["Technology"],"content":"配置文件的状态 systemctl list-unit-files命令用于列出所有配置文件。 # 列出所有配置文件 $ systemctl list-unit-files # 列出指定类型的配置文件 $ systemctl list-unit-files --type=service 这个命令会输出一个列表。 $ systemctl list-unit-files UNIT FILE STATE chronyd.service enabled clamd@.service static clamd@scan.service disabled 这个列表显示每个配置文件的状态，一共有四种。 配置文件状态 enabled：已建立启动链接 disabled：没建立启动链接 static：该配置文件没有[Install]部分（无法执行），只能作为其他配置文件的依赖 masked：该配置文件被禁止建立启动链接 注意，从配置文件的状态无法看出，该 Unit 是否正在运行。这必须执行前面提到的systemctl status命令。 $ systemctl status bluetooth.service 一旦修改配置文件，就要让 Systemd 重新加载配置文件，然后重新启动，否则修改不会生效。 $ sudo systemctl daemon-reload $ sudo systemctl restart httpd.service ","date":"2024-06-26","objectID":"/blog/20240626_systemd/:5:2","tags":["Linux","systemctl","system"],"title":"Systemd 学习","uri":"/blog/20240626_systemd/"},{"categories":["Technology"],"content":"配置文件的格式 配置文件就是普通的文本文件，可以用文本编辑器打开。 systemctl cat命令可以查看配置文件的内容。 $ systemctl cat atd.service [Unit] Description=ATD daemon [Service] Type=forking ExecStart=/usr/bin/atd [Install] WantedBy=multi-user.target 从上面的输出可以看到，配置文件分成几个区块。每个区块的第一行，使用方括号表示的区别名，比如[Unit]。 注意，配置文件的区块名和字段名，都是大小写敏感。 每个区块内部是一些等号连接的键值对。 [Section] Directive1=value Directive2=value . . . 注意，键值对的等号两侧不能有空格 ","date":"2024-06-26","objectID":"/blog/20240626_systemd/:5:3","tags":["Linux","systemctl","system"],"title":"Systemd 学习","uri":"/blog/20240626_systemd/"},{"categories":["Technology"],"content":"Target 启动计算机的时候，需要启动大量的 Unit。如果每一次启动，都要一一写名本次启动需要哪些 Unit，显然非常不方便。Systemd 的解决方案就是 Target。 简单说，Target 就是一个 Unit 组，包含许多相关的 Unit。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。从这个意义上说，Target 这个概念，跟 Target 的作用很类似。不同的是，RunLevel 是互斥的，不能有多个 RunLevel 同时启动，但是多个 Target 可以同时启动。 # 查看当前系统的所有 Target $ systemctl list-unit-files --type=target # 查看一个 Target 包含的所有 Unit $ systemctl list-dependencies multi-user.target # 查看启动时的默认 Target $ systemctl get-default # 设置启动时的默认 Target $ sudo systemctl set-default multi-user.target # 切换 Target 时，默认不关闭前一个 Target 启动的进程， # systemctl isolate 命令改变这种行为， # 关闭前一个 Target 里面所有不属于后一个 Target 的进程 $ sudo systemctl isolate multi-user.target Target 与传统 RunLevel 的对应关系如下。 Traditional runlevel New target name Symbolically linked to... Runlevel 0 | runlevel0.target -\u003e poweroff.target Runlevel 1 | runlevel1.target -\u003e rescue.target Runlevel 2 | runlevel2.target -\u003e multi-user.target Runlevel 3 | runlevel3.target -\u003e multi-user.target Runlevel 4 | runlevel4.target -\u003e multi-user.target Runlevel 5 | runlevel5.target -\u003e graphical.target Runlevel 6 | runlevel6.target -\u003e reboot.target 它与init进程的主要差别如下： 差别 默认的 RunLevel（在/etc/inittab文件设置）现在被默认的 Target 取代，位置是/etc/systemd/system/default.target，通常符号链接到graphical.target（图形界面）或者multi-user.target（多用户命令行）。 启动脚本的位置，以前是/etc/init.d目录，符号链接到不同的 RunLevel 目录 （比如/etc/rc3.d、/etc/rc5.d等），现在则存放在/lib/systemd/system和/etc/systemd/system目录。 配置文件的位置，以前init进程的配置文件是/etc/inittab，各种服务的配置文件存放在/etc/sysconfig目录。现在的配置文件主要存放在/lib/systemd目录，在/etc/systemd目录里面的修改可以覆盖原始设置。 ","date":"2024-06-26","objectID":"/blog/20240626_systemd/:6:0","tags":["Linux","systemctl","system"],"title":"Systemd 学习","uri":"/blog/20240626_systemd/"},{"categories":["Technology"],"content":"MySQL Index","date":"2023-12-14","objectID":"/blog/20231214_mysqlindex/","tags":["Index","索引","MySQL","优化"],"title":"MySQL 索引","uri":"/blog/20231214_mysqlindex/"},{"categories":["Technology"],"content":"索引介绍 ","date":"2023-12-14","objectID":"/blog/20231214_mysqlindex/:1:0","tags":["Index","索引","MySQL","优化"],"title":"MySQL 索引","uri":"/blog/20231214_mysqlindex/"},{"categories":["Technology"],"content":"什么是MySQL的索引 MySQL官方对于索引的定义：索引是帮助MySQL高效获取数据的数据结构。 MySQL在存储数据之外，数据库系统中还维护着满足特定查找算法的数据结构，这些数据结构以某种引用(指向)表中的数据，这样我们就可以通过数据结构上实现的高级查找算法来快速找到我们想要的数据。而这种数据结构就是索引。 简单理解为“排好序的可以快速查找数据的数据结构”。 ","date":"2023-12-14","objectID":"/blog/20231214_mysqlindex/:1:1","tags":["Index","索引","MySQL","优化"],"title":"MySQL 索引","uri":"/blog/20231214_mysqlindex/"},{"categories":["Technology"],"content":"索引数据结构 下图展示的就是一种可能的二叉树的索引方式： 二叉树索引方式 二叉树数据结构的弊端：当极端情况下，数据递增插入时，会一直向右插入，形成链表，查询效率会降低。 MySQL中常用的索引数据结构有BTree索引（Myisam 普通索引），B+Tree索引（Innodb 普通索引）,Hash索引（Memory 存储引擎）等等。 ","date":"2023-12-14","objectID":"/blog/20231214_mysqlindex/:1:2","tags":["Index","索引","MySQL","优化"],"title":"MySQL 索引","uri":"/blog/20231214_mysqlindex/"},{"categories":["Technology"],"content":"索引优势 提高数据检索的效率，降低数据库的IO成本 通过索引对数据进行排序，降低数据排序的成本，降低了CPU的消耗。 ","date":"2023-12-14","objectID":"/blog/20231214_mysqlindex/:1:3","tags":["Index","索引","MySQL","优化"],"title":"MySQL 索引","uri":"/blog/20231214_mysqlindex/"},{"categories":["Technology"],"content":"索引优势 索引实际上也是一张表，保存了主键和索引的字段，并且指向实体表的记录，索引索引也是需要占用空间的。在索引大大提高查询速度的同时，却会降低表的更新速度，在对表进行数据增删改的同时，MySQL不仅要更新数据，还需要保存一下索引文件。每次更新添加了的索引列的字段，都会去调整因为更新带来的减值变化后的索引的信息。 ","date":"2023-12-14","objectID":"/blog/20231214_mysqlindex/:1:4","tags":["Index","索引","MySQL","优化"],"title":"MySQL 索引","uri":"/blog/20231214_mysqlindex/"},{"categories":["Technology"],"content":"索引使用场景 下列情况需要创建索引 主键自动建立唯一索引 频繁作为查询条件的字段应该创建索引（where 后面的语句） 查询中与其它表关联的字段，外键关系建立索引 多字段查询下倾向创建组合索引 查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度 查询中统计或者分组字段 下列情况不推荐建立索引 表记录太少 经常增删改的表 Where 条件里用不到的字段不建立索引 ","date":"2023-12-14","objectID":"/blog/20231214_mysqlindex/:1:5","tags":["Index","索引","MySQL","优化"],"title":"MySQL 索引","uri":"/blog/20231214_mysqlindex/"},{"categories":["Technology"],"content":"索引分类 主键索引 表中的列设定为主键后，数据库会自动建立主键索引 单独创建键和删除主键索引语法： 创建主键索引语法 alter table 表名 add primary key (字段); 删除主键索引语法 alter table 表名 drop primary key; 唯一索引 表中的列创建了唯一约束时，数据库会自动建立唯一索引。 单独创建和删除唯一索引语法： 创建唯一索引语法 alter table 表名 add unique 索引名(字段); 或 create unique index 索引名 on 表名(字段); 删除唯一索引语法 drop index 索引名 on 表名; 单值索引 即一个索引只包含单个列，一个表可以有多个单值索引。 建表时可随表一起建立单值索引 单独创建和删除单值索引： 创建单值索引 create index 索引名 on 表名(字段); 或 alter table 表名 add index 索引名(字段); 删除单值索引 drop index 索引名 on 表名; 复合索引 即一个索引包含多个列。 建表时可随表一起建立复合索引 单独创建和删除复合索引： 创建复合索引 create index 索引名 on 表名(字段1，字段2); 删除复合索引 drop index 索引名 on 表名; ","date":"2023-12-14","objectID":"/blog/20231214_mysqlindex/:1:6","tags":["Index","索引","MySQL","优化"],"title":"MySQL 索引","uri":"/blog/20231214_mysqlindex/"},{"categories":["Technology"],"content":"性能分析 ","date":"2023-12-14","objectID":"/blog/20231214_mysqlindex/:2:0","tags":["Index","索引","MySQL","优化"],"title":"MySQL 索引","uri":"/blog/20231214_mysqlindex/"},{"categories":["Technology"],"content":"MySQL常见瓶颈 SQL中对大量数据进行比较、关联、排序、分组时，产生CPU瓶颈。 实例内存满足不了缓存数据或排序等需要，导致产生大量的物理IO。查询数据时扫描过多数据行，导致查询效率低。 ","date":"2023-12-14","objectID":"/blog/20231214_mysqlindex/:2:1","tags":["Index","索引","MySQL","优化"],"title":"MySQL 索引","uri":"/blog/20231214_mysqlindex/"},{"categories":["Technology"],"content":"Explain分析 使用 Explain 关键字可以模拟优化器执行 SQL 查询语句，从而知道 MySQL 是如何处理 SQL 语句的。可以用来分析查询语句或是表的结构的性能瓶颈。作用如下： 表的读取顺序 哪些索引可以使用 数据读取操作的操作类型 哪些索引被实际使用 表之间的引用 每张表有多少行被优化器查询 Explain 关键字使用起来比较简单：explain + SQL语句 explain执行结果参数 ","date":"2023-12-14","objectID":"/blog/20231214_mysqlindex/:2:2","tags":["Index","索引","MySQL","优化"],"title":"MySQL 索引","uri":"/blog/20231214_mysqlindex/"},{"categories":["Technology"],"content":"Explain 重要字段名 -- 创建四张测试表 CREATE TABLE t1( id INT(10) AUTO_INCREMENT, content VARCHAR(100), PRIMARY KEY (id) ); CREATE TABLE t2( id INT(10) AUTO_INCREMENT, content VARCHAR(100), PRIMARY KEY (id) ); CREATE TABLE t3( id INT(10) AUTO_INCREMENT, content VARCHAR(100), PRIMARY KEY (id) ); CREATE TABLE t4( id INT(10) AUTO_INCREMENT, content VARCHAR(100), PRIMARY KEY (id) ); -- 每张表中添加一条数据 INSERT INTO t1(content) VALUES(CONCAT('t1_',FLOOR(1+RAND()*1000))); INSERT INTO t2(content) VALUES(CONCAT('t2_',FLOOR(1+RAND()*1000))); INSERT INTO t3(content) VALUES(CONCAT('t3_',FLOOR(1+RAND()*1000))); INSERT INTO t4(content) VALUES(CONCAT('t4_',FLOOR(1+RAND()*1000))); id select 查询的系列号，表示查询中执行 select 子句或操作表的顺序。 id 相同时，执行顺序由上至下。 explain select * from t1,t2,t3 where t1.id=t2.id and t2.id = t3.id; id 不同时，如果为子查询，id 的序号会递增，id 值越大优先级越高，则先被执行。 explain select t1.id from t1 where t1.id in (select t2.id from t2 where t2.id in (select t3.id from t3 where t3.id = 1) ); id 相同和不同都存在，id 相同的可以理解为一组，从上往下顺序执行，所有组中，id值越大，优先级越高越先执行。 explain select t2.* from t2,(select * from t3) s3 where s3.id = t2.id; select_type 查询的类型，常见值有： SIMPLE：简单的 select 查询，查询中不包含子查询或者 UNION explain select * from t1; PRIMARY：查询中若包含任何复杂的子部分，最外层查询则被标记为 Primary。 explain select * from (select t1.content from t1) s1; DERIVED：在 FROM 列表中包含的子查询被标记为 DERIVED（衍生）MySQL 会递归执行这些子查询，把结果放在临时表里。 explain select * from (select t1.content from t1) s1; SUBQUERY：在 SELECT 或 WHERE 列表中包含了子查询。 explain select t2.* from t2 where t2.id = (select t3.id from t3); table 显示这一行的数据是来自哪张表的。 type 访问类型排序： 访问类型 system:表中只有一行记录（等于系统表），这是 const 类型的特性，平时不会出现，这个也可以忽略不计。 explain select * from (select t1.id from t1 where id = 1) t; const:表示通过索引一次就找到了，const 用于比较 primary key 或者 unique 索引。因为只匹配一行数据，所以很快，如将主键置于 where 列表中，MySQL 就能将该查询转换为一个常量。 explain select * from t1 where id = 1; eq_ref:唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见主键或唯一索引扫描。 explain select t1.*,t2.* from t1 join t2 on t1.id = t2.id; ref:非唯一性索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，它返回所有匹配某个单独值的行，然后，它可能会找到多个符合条件的行，所以它应该属于查找和扫描的混合体。 alter table t1 add index idx_t1_content(content); explain select * from t1 where t1.content = \"abc\"; range:只检索给定范围的行，使用一个索引来选择行。key 列显示使用了哪个索引，一般就是在你的 where 语句中出现了 between、\u003c、\u003e、in 等的查询这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束语另一点，不用扫描全部索引。 explain select * from t2 where t2.id \u003e0; index:Full Index Scan，index 与 All 区别为 index 类型只遍历索引树。这通常比 All 快，因为索引文件通常比数据文件小，也就是说虽然 all 和 index 都是读全表，但 index 是从索引中读取的，而 all 是从硬盘中读的。 explain select id,content from t1; All:Full Table Scan，将遍历全表以找到匹配的行。 explain select * from t1 where t1.content = \"abc\"; 从最好到最差依次是：system \u003e const \u003e eq_ref \u003e ref \u003e range \u003e All 一般来说，最好保证查询能够达到 range 级别，最好达到 ref。 possible_keys 显示可能应用在这张表中的索引，一个或多个。查询涉及到的字段上如果存在索引，则相应索引将会被列出来，但不一定会被查询实际使用上。 key 查询中实际使用的索引，如果为 NULL，则没有使用索引。 key_len 表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好。 ref 显示索引的哪一列被使用了。哪些列或常量被用于查找索引列上的值。 rows rows 列显示 MySQL 认为它执行查询时必须检查的行数。一般越少越好。 extra -- 创建测试表 drop table if exists emps; CREATE TABLE emps ( id INT PRIMARY KEY AUTO_INCREMENT COMMENT \"主键id\", name VARCHAR (24) COMMENT '姓名', age INT COMMENT '年龄', job VARCHAR (20) COMMENT '职位' ); -- 插入测试数据 INSERT INTO emps(name,age,job) VALUES('张三',22,'manager'); INSERT INTO emps(name,age,job) VALUES('lisi',23,'clerk'); INSERT INTO emps(name,age,job) VALUES('wangwu',24,'salsman'); INSERT INTO emps(name,age,job) VALUES('赵六',23,'salsman'); 一些常见的重要的额外信息： Using filesort：MySQL 无法利用索引完成的排序操作称之为“文件排序”。 explain select * from emps order by age; Using temporary：MySQL 在对查询结果排序时使用临时表，常见排序 order by 和分组查询 group by。 explain select count(*),job from emps group by job; Using index：表示索引被用来执行索引键值的查找，避免访问了表的数据行，效率还不错。 explain select id,name from emps; Using where：表示使用了 where 过滤。 explain select * from emps where name = \"张三\"; ","date":"2023-12-14","objectID":"/blog/20231214_mysqlindex/:2:3","tags":["Index","索引","MySQL","优化"],"title":"MySQL 索引","uri":"/blog/20231214_mysqlindex/"},{"categories":["Technology"],"content":"查询优化 ","date":"2023-12-14","objectID":"/blog/20231214_mysqlindex/:3:0","tags":["Index","索引","MySQL","优化"],"title":"MySQL 索引","uri":"/blog/20231214_mysqlindex/"},{"categories":["Technology"],"content":"索引失效 最佳左前缀法则：如果索引了多列，要遵循最左前缀法则，指的是查询从索引的最左前列开始并且不跳过索引中的列。 不在索引上做任何计算、函数操作，会导致索引失效转而转向全表扫描。 存储引擎不能使用索引中范围条件右边的列。 MySQL 在使用不等于时无法使用索引会导致全表扫描。 is null 可以使用索引，但是 is not null 无法使用索引。 like 以通配符开头会使索引失效导致全表扫描。 字符串不加单引号索引会失效。 使用 or 连接时索引失效。 实战演示 假设 index(a,b,c) 复合索引：注意 or 不会生效，and 会自动调整顺序为最左前列。 where语句 索引是否被使用 where a = 3 Yes，使用到a where a = 3 and b = 5 Yes，使用到 a，b where a = 3 and b = 4 and c = 5 Yes，使用到 a，b，c Where b = 4 或者 where b = 4 and c = 4 或者 where c = 5 No where a = 3 and c = 5 Yes，只用到 a，key_len 会小一些 where a = 3 and b \u003e 4 and c = 5 Yes，使用到 a，b where a = 3 and b like ‘kk%’ and c = 5 Yes，使用到 a，b，c where a = 3 and b like ‘%kk’ and c = 5 Yes，只用到 a where a = 3 and b like ‘%kk%’ and c = 5 Yes，只用到 a where a = 3 and b like ‘k%kk%’ and c = 5 Yes，使用到 a，b，c 索引使用建议 对于单值索引，尽量选择针对当前查询字段过滤性更好的索引。 对于组合索引，当前 where 查询中过滤性更好的字段在索引字段顺序中位置越靠前越好。 对于组合索引，尽量选择能够包含当前查询中 where 子句中更多字段的索引。 尽可能通过分析统计信息和调整 query 的写法来达到选择合适索引的目的。 ","date":"2023-12-14","objectID":"/blog/20231214_mysqlindex/:3:1","tags":["Index","索引","MySQL","优化"],"title":"MySQL 索引","uri":"/blog/20231214_mysqlindex/"},{"categories":["Technology"],"content":"单表查询优化 索引优化 经常用于查询条件的列建立索引 避免在大表上使用全文索引，因为它可能会影响性能 对于经常需要排序或分组的列，可以考虑添加索引 使用覆盖索引，确保索引包含了查询所需要的所有列，避免了回表操作 查询语句优化 避免使用 select *，只选择实际需要的列 避免在 where 子句中使用不可见函数，会因为它可能导致索引失效 合理使用 limit，限制返回的记录数量，避免不必要的数据传输和处理 ","date":"2023-12-14","objectID":"/blog/20231214_mysqlindex/:3:2","tags":["Index","索引","MySQL","优化"],"title":"MySQL 索引","uri":"/blog/20231214_mysqlindex/"},{"categories":["Technology"],"content":"关联查询优化 内连接时，MySQL 会自动把小结果集的选为驱动表，所以大表的字段最好加上索引。座外连接时，左表会全表扫描，所以右边大表字段最好加上索引，右外连接同理。我们最好保证被驱动表上的字段建立了索引。 ","date":"2023-12-14","objectID":"/blog/20231214_mysqlindex/:3:3","tags":["Index","索引","MySQL","优化"],"title":"MySQL 索引","uri":"/blog/20231214_mysqlindex/"},{"categories":["Technology"],"content":"排序优化 尽量避免使用 Using fileSort 方式排序 order by 语句使用索引最左前列或使用 where 子句与 order by 字句条件组合满足索引最左前列。 where 子句中如果出现索引范围查询会导致 order by 索引失效。 参照上面实战演示 ","date":"2023-12-14","objectID":"/blog/20231214_mysqlindex/:3:4","tags":["Index","索引","MySQL","优化"],"title":"MySQL 索引","uri":"/blog/20231214_mysqlindex/"},{"categories":["Technology"],"content":"分组优化 参照排序优化 ","date":"2023-12-14","objectID":"/blog/20231214_mysqlindex/:3:5","tags":["Index","索引","MySQL","优化"],"title":"MySQL 索引","uri":"/blog/20231214_mysqlindex/"},{"categories":["Technology"],"content":"慢查询日志 ","date":"2023-12-14","objectID":"/blog/20231214_mysqlindex/:4:0","tags":["Index","索引","MySQL","优化"],"title":"MySQL 索引","uri":"/blog/20231214_mysqlindex/"},{"categories":["Technology"],"content":"介绍 MySQL 的慢查询日志是 MySQL 提供的一种日志记录，它用来记录在 MySQL 中响应时间超过设定阀值的语句，具体指运行时间超过 long_query_time 值的 SQL ，则会被记录到慢查询日志中。可以由它来查看哪些 SQL 超出了我们最大忍耐时间值。 ","date":"2023-12-14","objectID":"/blog/20231214_mysqlindex/:4:1","tags":["Index","索引","MySQL","优化"],"title":"MySQL 索引","uri":"/blog/20231214_mysqlindex/"},{"categories":["Technology"],"content":"慢查询日志使用 默认情况下，MySQL 数据库咩有开启慢查询日志，需要手动设置参数。 查看是否开启慢查询日志： show variables like '%slow_query_log%'; 开启日志： set global show_query_log = 1; 设置时间阀值： set global long_query_time = 1; 查看设置的时间阀值： show variables like 'long_query_time%'; 查看超时的 sql 记录日志：MySQL 的数据文件夹下 ‘\\Data\\设备名称-slow.log’ 注意：非调优场景下，一般不建议开启改参数，慢查询日志将日志记录写入文件，开启慢查询日志会或多或少带来一定的性能影响。 ","date":"2023-12-14","objectID":"/blog/20231214_mysqlindex/:4:2","tags":["Index","索引","MySQL","优化"],"title":"MySQL 索引","uri":"/blog/20231214_mysqlindex/"},{"categories":["Technology"],"content":"雪花算法","date":"2023-10-11","objectID":"/blog/20231011_globaluniqueid/","tags":["分布式全局ID","高并发","单机"],"title":"分布式全局唯一ID","uri":"/blog/20231011_globaluniqueid/"},{"categories":["Technology"],"content":"前言 系统唯一ID是我们在设计一个系统的时候常常会遇见的问题，也常常为这个问题而纠结。 这篇文章就是给大家提供一个生成分布式唯一全局id生成方案的思路，希望可以共勉大家。 ","date":"2023-10-11","objectID":"/blog/20231011_globaluniqueid/:1:0","tags":["分布式全局ID","高并发","单机"],"title":"分布式全局唯一ID","uri":"/blog/20231011_globaluniqueid/"},{"categories":["Technology"],"content":"问题 为什么需要分布式全局唯一ID以及分布式ID的业务需求 在复杂分布式系统中，往往需要对大量的数据和消息进行唯一标识，如在美团点评的金融、支付、餐饮、酒店 猫眼电影等产品的系统中数据逐渐增长，对数据库分库分表后需要有一个唯一ID来标识一条数据或信息； 特别是订单、骑手、优惠券都需要有唯一ID做标识 此时一个能够生成全局唯一ID的系统是非常必要的 ID生成规则部分硬性要求 全局唯一 趋势递增 在 MySQL 的 InnoDB 引擎中使用的是聚集索引，由于多数 RDBMS 使用 Btree 的数据结构来存储索引，在主键的选择上面我们应该尽量使用有序的主键保证写入性能 单调递增 保证下一个ID一定大于上一个ID，例如事务版本号、IM增量消息、排序等特殊需求 信息安全 如果ID是连续，恶意用户的爬取工作就非常容易做了，直接按照顺序下载指定URL即可，如果是订单号就危险了，竞争对手可以直接知道我们一天的单量，所以在一些应用场景下，需要ID无规则不规则，让竞争对手不好猜 含时间戳 一样能够快速在开发中了解这个分布式ID什么时候生成的 ID号生成系统的可用性要求 高可用 发布一个获取分布式ID请求，服务器就要保证 99.999% 的情况下给我创建一个唯一分布式ID 低延迟 发一个获取分布式ID的请求，服务器就要快，极速 高QPS 例如并发一口气10万个创建分布式ID请求同时杀过来，服务器要顶得住且一下子成功创建10万个分布式ID ","date":"2023-10-11","objectID":"/blog/20231011_globaluniqueid/:2:0","tags":["分布式全局ID","高并发","单机"],"title":"分布式全局唯一ID","uri":"/blog/20231011_globaluniqueid/"},{"categories":["Technology"],"content":"通用解决方案 ","date":"2023-10-11","objectID":"/blog/20231011_globaluniqueid/:3:0","tags":["分布式全局ID","高并发","单机"],"title":"分布式全局唯一ID","uri":"/blog/20231011_globaluniqueid/"},{"categories":["Technology"],"content":"UUID 介绍 UUID.randomUUID(), UUID的标准型包含32个16进制数字，以连字号分为五段，形式为 8-4-4-4-12的36个字符，性能非常高，本地生成，没有网络消耗。 UUID组成部分 当前日期和时间，UUID的第一个部分与时间有关，如果你在生成一个UUID之后，过几秒又生成一个UUID，则第一个部分不同，其余相同。 时钟序列。 全局唯一的IEEE机器识别号，如果有网卡，从网卡MAC地址获得，没有网卡以其他方式获得。 存在问题 入数据库性能差，因为UUID是无序的 无序，无法预测他的生成顺序，不能生成递增有序的数字 首先分布式id一般都会作为逐渐，但是按照mysql官方推荐主键尽量越短越好，UUID每一个都很长，所以不是很推荐。 主键，ID作为主键时，在特定的环境下会存在一些问题 比如做DB主键的场景下，UUID就非常不适用MySQL官方有明确的说明 索引，B+树索引的分裂 既然分布式ID是主键，然后主键是包含索引的，而mysql的索引是通过B+树来实现的，每一次新的UUID数据的插入，为了查询的优化，都会对索引底层的B+树进行修改，因为UUID数据是无序的，所以每一次UUID数据的插入都会对主键的B+树进行很大的修改，这一点很不好，插入完全无序，不但会导致一些中间节点产生分裂，也会白白创造出很多不饱和的节点，这样大大降低了数据库插入的性能。 UUID只能保证全局唯一性，不满足后面的趋势递增，单调递增 ","date":"2023-10-11","objectID":"/blog/20231011_globaluniqueid/:3:1","tags":["分布式全局ID","高并发","单机"],"title":"分布式全局唯一ID","uri":"/blog/20231011_globaluniqueid/"},{"categories":["Technology"],"content":"数据库自增主键 单机 在分布式里面，数据库的自增ID机制的主要原理是：数据库自增ID和mysql数据库的replace into实现的，这里的replace into跟insert功能 类似，不同点在于：replace into首先尝试插入数据列表中，如果发现表中已经有此行数据（根据主键或唯一索引判断）则先删除，在插入，否则直接插入新数据。 REPLACE INTO的含义是插入一条记录，如果表中唯一索引的值遇到冲突，则替换老数据 ICREATE TABLE t_test( id BIGINT(20) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, state CHAR (1) NOT NULL DEFAULT '', UNIQUE KEY state (state) ) REPLACE INTO t_test(state) values('b'); select LAST_INSERT_ID(); 我们每次插入的时候，发现都会把原来的数据给替换，并且ID也会增加 这就满足了 递增性 单调性 唯一性 在分布式情况下，并且并发量不多的情况，可以使用这种方案来解决，获得一个全局的唯一ID 分布式集群 那数据库自增ID机制适合做分布式ID吗？ 答案是不太适合 系统水平扩展比较困难，比如定义好步长和机器台数之后，如果要添加机器该怎么办，假设现在有一台机器发号是：1,2,3,4,5,（步长是1），这个时候需要扩容机器一台，可以这样做：把第二台机器的初始值设置得比第一台超过很多，貌似还好，但是假设线上如果有100台机器，这个时候扩容要怎么做，简直是噩梦，所以系统水平扩展方案复杂难以实现。 数据库压力还是很大，每次获取ID都得读写一次数据库，非常影响性能，不符合分布式ID里面的延迟低和高QPS的规则（在高并发下，如果都去数据库里面获取ID，那是非常影响性能的） ","date":"2023-10-11","objectID":"/blog/20231011_globaluniqueid/:3:2","tags":["分布式全局ID","高并发","单机"],"title":"分布式全局唯一ID","uri":"/blog/20231011_globaluniqueid/"},{"categories":["Technology"],"content":"基于Redis生成全局ID策略 单机 因为Redis是单线程，天生保证原子性，可以使用原子操作 INCR 和 INCRBY 来实现 INCRBY：设置增长步长 分布式集群 注意：在Redis集群情况下，同样和MySQL一样需要设置不同的增长步长，同时key一定要设置有效期，可以使用Redis集群来获取更高的吞吐量。 假设一个集群中有5台Redis，可以初始化每台Redis的值分别是 1,2,3,4,5 ， 然后设置步长都是5 各个Redis生成的ID为： A：1 6 11 16 21 B：2 7 12 17 22 C：3 8 13 18 23 D：4 9 14 19 24 E：5 10 15 20 25 但是存在的问题是，就是Redis集群的维护和保养比较麻烦，配置麻烦。因为要设置单点故障，哨兵值守 但是主要是的问题就是，为了一个ID，却需要引入整个Redis集群，有种杀鸡焉用牛刀的感觉 ","date":"2023-10-11","objectID":"/blog/20231011_globaluniqueid/:3:3","tags":["分布式全局ID","高并发","单机"],"title":"分布式全局唯一ID","uri":"/blog/20231011_globaluniqueid/"},{"categories":["Technology"],"content":"雪花算法 ","date":"2023-10-11","objectID":"/blog/20231011_globaluniqueid/:4:0","tags":["分布式全局ID","高并发","单机"],"title":"分布式全局唯一ID","uri":"/blog/20231011_globaluniqueid/"},{"categories":["Technology"],"content":"介绍 Twitter的分布式自增ID算法：Snowflake 最初Twitter把存储系统从MySQL迁移到Cassandra（由Facebook开发一套开源分布式NoSQL数据库系统）因为Cassandra没有顺序ID生成机制，所有开发了这样一套全局唯一ID生成服务。 Twitter的分布式雪花算法SnowFlake，经测试SnowFlake每秒可以产生26万个自增可排序的ID twitter的SnowFlake生成ID能够按照时间有序生成 SnowFlake算法生成ID的结果是一个64Bit大小的整数，为一个Long型（转换成字符串后长度最多19） 分布式系统内不会产生ID碰撞（由datacenter 和 workerID做区分）并且效率较高 全局唯一ID的基本要求 在分布式环境下，必须全局唯一性 一般都需要单调递增，因为一般唯一ID都会存在数据库，而InnoDB的特性就是将内容存储在主键索引上的叶子节点，而且是从左往右递增的，所有考虑到数据库性能，一般生成ID也最好是单调递增的。为了防止ID冲突可以使用36位UUID，但是UUID有一些缺点，首先是它相对比较长，并且另外UUID一般是无序的 可能还会需要无规则，因为如果使用唯一ID作为订单号这种，为了不让别人知道一天的订单量多少，就需要这种规则 ","date":"2023-10-11","objectID":"/blog/20231011_globaluniqueid/:4:1","tags":["分布式全局ID","高并发","单机"],"title":"分布式全局唯一ID","uri":"/blog/20231011_globaluniqueid/"},{"categories":["Technology"],"content":"结构 雪花算法的几个核心组成部分 在Java中64bit的证书是long类型，所以在SnowFlake算法生成的ID就是long类存储的 雪花算法核心组成部分 **第一部分** 二进制中最高位是符号位，1表示负数，0表示正数。生成的ID一般都是用整数，所以最高位固定为0。 **第二部分** 第二部分是41bit时间戳位，用来记录时间戳，毫秒级 41位可以表示 2^41 -1 个数字 如果只用来表示正整数，可以表示的范围是：0 - 2^41 -1，减1是因为可以表示的数值范围是从0开始计算的，而不是从1。 也就是说41位可以表示 2^41 - 1 毫秒的值，转换成单位年则是 69.73年 **第三部分** 第三部分为工作机器ID，10Bit用来记录工作机器ID 可以部署在2^10 = 1024个节点，包括5位 datacenterId（数据中心，机房） 和 5位 workerID（机器码） 5位可以表示的最大正整数是 2 ^ 5 = 31个数字，来表示不同的数据中心 和 机器码 **第四部分** 12位bit可以用来表示的正整数是 2^12 = 4095，即可以用0 1 2 … 4094 来表示同一个机器同一个时间戳内产生的4095个ID序号。 SnowFlake可以保证所有生成的ID按时间趋势递增，整个分布式系统内不会产生重复ID，因为有 datacenterId 和 workerId 来做区分 ","date":"2023-10-11","objectID":"/blog/20231011_globaluniqueid/:4:2","tags":["分布式全局ID","高并发","单机"],"title":"分布式全局唯一ID","uri":"/blog/20231011_globaluniqueid/"},{"categories":["Technology"],"content":"实现 雪花算法是由 scala 算法编写的，有人使用java实现，github地址 /** * twitter的snowflake算法 -- java实现 * * @author beyond */ public class SnowFlake { /** * 起始的时间戳 */ private final static long START_STMP = 1480166465631L; /** * 每一部分占用的位数 */ private final static long SEQUENCE_BIT = 12; //序列号占用的位数 private final static long MACHINE_BIT = 5; //机器标识占用的位数 private final static long DATACENTER_BIT = 5;//数据中心占用的位数 /** * 每一部分的最大值 */ private final static long MAX_DATACENTER_NUM = -1L ^ (-1L \u003c\u003c DATACENTER_BIT); private final static long MAX_MACHINE_NUM = -1L ^ (-1L \u003c\u003c MACHINE_BIT); private final static long MAX_SEQUENCE = -1L ^ (-1L \u003c\u003c SEQUENCE_BIT); /** * 每一部分向左的位移 */ private final static long MACHINE_LEFT = SEQUENCE_BIT; private final static long DATACENTER_LEFT = SEQUENCE_BIT + MACHINE_BIT; private final static long TIMESTMP_LEFT = DATACENTER_LEFT + DATACENTER_BIT; private long datacenterId; //数据中心 private long machineId; //机器标识 private long sequence = 0L; //序列号 private long lastStmp = -1L;//上一次时间戳 public SnowFlake(long datacenterId, long machineId) { if (datacenterId \u003e MAX_DATACENTER_NUM || datacenterId \u003c 0) { throw new IllegalArgumentException(\"datacenterId can't be greater than MAX_DATACENTER_NUM or less than 0\"); } if (machineId \u003e MAX_MACHINE_NUM || machineId \u003c 0) { throw new IllegalArgumentException(\"machineId can't be greater than MAX_MACHINE_NUM or less than 0\"); } this.datacenterId = datacenterId; this.machineId = machineId; } /** * 产生下一个ID * * @return */ public synchronized long nextId() { long currStmp = getNewstmp(); if (currStmp \u003c lastStmp) { throw new RuntimeException(\"Clock moved backwards. Refusing to generate id\"); } if (currStmp == lastStmp) { //相同毫秒内，序列号自增 sequence = (sequence + 1) \u0026 MAX_SEQUENCE; //同一毫秒的序列数已经达到最大 if (sequence == 0L) { currStmp = getNextMill(); } } else { //不同毫秒内，序列号置为0 sequence = 0L; } lastStmp = currStmp; return (currStmp - START_STMP) \u003c\u003c TIMESTMP_LEFT //时间戳部分 | datacenterId \u003c\u003c DATACENTER_LEFT //数据中心部分 | machineId \u003c\u003c MACHINE_LEFT //机器标识部分 | sequence; //序列号部分 } private long getNextMill() { long mill = getNewstmp(); while (mill \u003c= lastStmp) { mill = getNewstmp(); } return mill; } private long getNewstmp() { return System.currentTimeMillis(); } public static void main(String[] args) { SnowFlake snowFlake = new SnowFlake(2, 3); for (int i = 0; i \u003c (1 \u003c\u003c 12); i++) { System.out.println(snowFlake.nextId()); } } } ","date":"2023-10-11","objectID":"/blog/20231011_globaluniqueid/:4:3","tags":["分布式全局ID","高并发","单机"],"title":"分布式全局唯一ID","uri":"/blog/20231011_globaluniqueid/"},{"categories":["Technology"],"content":"总结 雪花算法优缺点 优点 毫秒数在高维，自增序列在低位，整个ID都是趋势递增的 不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也是非常高的 可以根据自身业务特性分配bit位，非常灵活 缺点 依赖机器时钟，如果机器时钟回拨，会导致重复ID生成 在单机上是递增的，但由于涉及到分布式环境，每台机器上的时钟不可能完全同步，有时候会出现不是全局递增的情况，此缺点可以认为无所谓，一般分布式ID只要求趋势递增，并不会严格要求递增，90%的需求只要求趋势递增。 ","date":"2023-10-11","objectID":"/blog/20231011_globaluniqueid/:4:4","tags":["分布式全局ID","高并发","单机"],"title":"分布式全局唯一ID","uri":"/blog/20231011_globaluniqueid/"},{"categories":["Technology"],"content":"其它补充 为了解决时钟回拨问题，导致ID重复，后面有人专门提出了解决的方案 百度开源的分布式唯一ID生成器 UidGenerator Leaf - 美团点评分布式ID生成系统 ","date":"2023-10-11","objectID":"/blog/20231011_globaluniqueid/:4:5","tags":["分布式全局ID","高并发","单机"],"title":"分布式全局唯一ID","uri":"/blog/20231011_globaluniqueid/"},{"categories":["Technology"],"content":"Java多线程","date":"2023-10-07","objectID":"/blog/20231007_concurrent/","tags":["Java","多线程","高并行","高并发","设计模式","study"],"title":"并发编程","uri":"/blog/20231007_concurrent/"},{"categories":["Technology"],"content":"引入 注意 一个 注意 横幅 摘要 一个 摘要 横幅 信息 一个 信息 横幅 技巧 一个 技巧 横幅 成功 一个 成功 横幅 问题 一个 问题 横幅 警告 一个 警告 横幅 失败 一个 失败 横幅 危险 一个 危险 横幅 Bug 一个 Bug 横幅 示例 一个 示例 横幅 引用 一个 引用 横幅 ","date":"2023-10-07","objectID":"/blog/20231007_concurrent/:1:0","tags":["Java","多线程","高并行","高并发","设计模式","study"],"title":"并发编程","uri":"/blog/20231007_concurrent/"},{"categories":["Technology"],"content":"进程与线程 ","date":"2023-10-07","objectID":"/blog/20231007_concurrent/:2:0","tags":["Java","多线程","高并行","高并发","设计模式","study"],"title":"并发编程","uri":"/blog/20231007_concurrent/"},{"categories":["Technology"],"content":"介绍 进程 程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU ，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的。 当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。 进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器等），也有的程序只能启动一个实例进程（例如网易云音乐、360安全卫士等） 线程 一个进程之内可以分为一到多个线程。 一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给CPU执行。 Java中，线程作为最小调度单位，进程作为资源分配的最小单位。在 Windows 中进程是不活动的，只是作为线程的容器。 线程与进程对比 进程基本上相互独立的，而线程存在于进程内，是进程的一个子集 进程拥有共享的资源，如内存空间等，供其内部的线程共享 进程间通信较为复杂 同一台计算机的进程通信称为IPC（Inter-process communication） 不同计算机之间的进程通信，需要通过网络，并遵循共同的协议，例如 HTTP 线程通信相对简单，因为他们共享进程内的内存。例如：多个线程可以访问同一个共享变量 线程更轻量，线程上下文切换成本一般上要比进程上下文切换低 ","date":"2023-10-07","objectID":"/blog/20231007_concurrent/:2:1","tags":["Java","多线程","高并行","高并发","设计模式","study"],"title":"并发编程","uri":"/blog/20231007_concurrent/"},{"categories":["Technology"],"content":"并行与并发 单核 CPU 下，线程实际还是串行执行的，操作系统中有一个组件叫做任务调度器，将 CPU 的时间片（Windows 下时间片最小约为15毫秒）分给不同的程序使用，只是由于 CPU 在线程间（时间片很短）的切换非常快，人类感觉是同时运行的。总结一句话就是：微观串行，宏观并行，一般会将这种线程轮流使用 CPU 的做法称为并发，concurrent CPU 时间片1 时间片2 时间片3 时间片4 core 线程1 线程2 线程3 线程4 并发 多核CPU下，每个核（core）都可以调度运行线程，这时候线程可以是并行的 CPU 时间片1 时间片2 时间片3 时间片4 Core1 线程1 线程2 线程3 线程4 Core2 线程1 线程2 线程3 线程4 并行 引用Rob Pike的一段描述： **并发（concurrent）**是同一时间应对（dealing with）多件事情的能力 **并行（parallel）**是同一时间动手做（doing）多件事情的能力 用例 家庭主妇做饭，打扫卫生，给孩子喂奶，她一个人轮流交替做这么多件事，这时就是并发 家庭主妇雇佣了个保姆，她们一起做这些事，这时既有并发，也有并行（这时会产生竞争，例如锅只有一口，一个人用锅时，另一个人就得等待） 雇了三个保姆，一个专做饭，一个专打扫卫生，一个专喂奶，互不打扰，这时就是并行 Rob Pike 资料 Golang语言的创造者 Rob Pike - 百科百度 ","date":"2023-10-07","objectID":"/blog/20231007_concurrent/:2:2","tags":["Java","多线程","高并行","高并发","设计模式","study"],"title":"并发编程","uri":"/blog/20231007_concurrent/"},{"categories":["Technology"],"content":"应用 应用之异步调用 以调用角度来讲，如果 需要等待结果返回，才能继续运行就是同步 不需要等待结果返回，就能继续运行就是异步 设计 多线程可以让方法执行变为异步的（既不要巴巴干等着）比如说读取磁盘文件时，假设读取操作话费了5分钟，如果没有线程调度机制，这5秒CPU什么都做不了，其它代码都得暂停… 结论 比如在项目中，视频文件需要转换格式等操作比较费时，这时开启一个新线程处理视频转换，避免阻塞主线程 tomcat的异步servlet也是类似的目的，让用户线程处理耗时较长的操作，避免阻塞tomcat的工作线程 UI程序中，开线程进行其他操作，避免阻塞UI线程 应用之提高效率 充分利用多核CPU的优势，提高运行效率，想象下面的场景，执行3个计算，最后将计算结果汇总 计算 1 花费 10 ms 计算 2 花费 11 ms 计算 3 花费 9 ms 汇总需要 1 ms 如果是串行执行，那么总共花费的时间是10 + 11 + 9 + 1 = 31ms 但如果是四核CPU，各个核心分别使用线程1执行计算1，线程2执行计算2，线程3执行计算3，那么3个线程是并行的，花费时间只取决于最长的那个线程运行的时间，即11ms最后加上汇总时间只会花费12ms 注意 需要在多核CPU才能提高效率，单核仍然是轮流执行 结论 单核CPU下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用CPU，不至于一个线程总占用CPU，别的线程没法干活 多核CPU可以并行跑多个线程，但能否提高程序运行效率还是要分情况的 有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率，但不是所有计算任务都能拆分（参考阿姆达尔定律） 也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义 IO操作不占用CPU，只是我们一般拷贝文件使用的是阻塞IO，这时相当于线程虽然不用CPU，但需要一直等待IO结束，没能充分利用线程。所以才用后面的非阻塞IO和异步IO优化 ","date":"2023-10-07","objectID":"/blog/20231007_concurrent/:2:3","tags":["Java","多线程","高并行","高并发","设计模式","study"],"title":"并发编程","uri":"/blog/20231007_concurrent/"},{"categories":["Technology"],"content":"Java线程 ","date":"2023-10-07","objectID":"/blog/20231007_concurrent/:3:0","tags":["Java","多线程","高并行","高并发","设计模式","study"],"title":"并发编程","uri":"/blog/20231007_concurrent/"},{"categories":["Technology"],"content":"创建和运行线程 方法一 Thread Thread使用步骤 创建一个继承于Thread类的子类 重写Thread类的run() ——\u003e 将此线程执行的操作声明在run()中 创建Thread类的子类的对象 通过此对象调用start()执行线程 创建模版 // 创建线程对象 Thread t = new Thread() { public void run() { // 要执行的任务 } }; // 启动线程 t.start(); 实际应用示例 // 构造方法的参数是给线程指定名字，推荐 Thread t1 = new Thread(\"t1\") { @Override // run 方法内实现了要执行的任务 public void run() { log.debug(\"hello\"); } }; t1.start(); 输出 19:19:00 [t1] c.ThreadStarter - hello 方法二 Runable Runable使用步骤 创建一个实现了Runnable接口的类 实现类去实现Runnable中的抽象方法：run() 创建实现类的对象 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象 通过Thread类的对象调用start() 启动线程 调用当前线程的run()——\u003e调用了Runnable类型的target的run() 把线程和任务（需要执行的代码）分开 Thread 代表线程 Runable 可运行的任务（线程需要执行的代码） 创建模版 Runnable runnable = new Runnable() { public void run(){ // 要执行的任务 } }; // 创建线程对象 Thread t = new Thread( runnable ); // 启动线程 t.start(); 实际应用示例 // 创建任务对象 Runnable task2 = new Runnable() { @Override public void run() { log.debug(\"hello\"); } }; // 参数1 是任务对象; 参数2 是线程名字，推荐 Thread t2 = new Thread(task2, \"t2\"); t2.start(); 输出 19:19:00 [t2] c.ThreadStarter - hello Java 8以后可以使用 Lambda 精简代码 // 创建任务对象 Runnable task2 = () -\u003e log.debug(\"hello\"); // 参数1 是任务对象; 参数2 是线程名字，推荐 Thread t2 = new Thread(task2, \"t2\"); t2.start(); Thread 与 Runnable 的关系 方法一是把线程和任务合并在了一起，方法二是把线程和任务分开了 用 Runable 更容易与线程池等高级 API 配合 用 Runable 让任务类脱离了 Thread 继承体系，更灵活 方法三 Callable FutureTask使用步骤 创建一个实现 Callable 的实现类 实现 call() 方法，将此线程需要执行的操作声明在 call() 中 创建 Callable 接口实现类的对象 将此 Callable 接口实现类的对象作为传递到 FutureTask 构造器中，创建 FutureTask 的对象 将 FutureTask 的对象作为参数传递到 Thread 类的构造器中，创建 Thread 对象，并调用 start() 获取 Callable 中 call() 方法的返回值 实现Callable接口的方式创建线程的强大之处 call() 可以有返回值的 call() 可以抛出异常，被外面的操作捕获，获取异常的信息 Callable 是支持泛型的 实际应用示例 // 创建任务对象 FutureTask\u003cInteger\u003e task3 = new FutureTask\u003c\u003e(() -\u003e { log.debug(\"hello\"); return 100; }); // 参数1 是任务对象; 参数2 是线程名字，推荐 new Thread(task3, \"t3\").start(); // 主线程阻塞，同步等待 task 执行完毕的结果 Integer result = task3.get(); log.debug(\"结果是:{}\", result); 输出 19:22:27 [t3] c.ThreadStarter - hello 19:22:27 [main] c.ThreadStarter - 结果是:100 ","date":"2023-10-07","objectID":"/blog/20231007_concurrent/:3:1","tags":["Java","多线程","高并行","高并发","设计模式","study"],"title":"并发编程","uri":"/blog/20231007_concurrent/"},{"categories":["Technology"],"content":"观察多个线程同时运行 规律 交替执行 谁先谁后，不由我们控制 ","date":"2023-10-07","objectID":"/blog/20231007_concurrent/:3:2","tags":["Java","多线程","高并行","高并发","设计模式","study"],"title":"并发编程","uri":"/blog/20231007_concurrent/"},{"categories":["Technology"],"content":"查看进程线程运行的方法 Windows 任务管理器可以查看进程和线程数，也可以用来杀死进程 tasklist 查看进程 taskkill 杀死进程 Linux ps -ef 查看所有进程 ps -fT -p\u003cPID\u003e 查看某个进程（PID）的所有线程 kill 杀死进程 top 按大写H切换是否显示线程 top -H -p\u003cPID\u003e 查看某个进程（PID）的所有线程 Java jps 查看所有Java进程 jstack \u003cPID\u003e 查看某个Java进程（PID）的所有线程状态 jconsole 来查看某个Java进程中线程的运行状态（图形界面） jconsole 远程监控配置 需要以如下方式运行Java类 java -Djava.rmi.server.hostname=`ip地址` -Dcom.sun.management.jmxremote Dcom.sun.management.jmxremote.port=`连接端口` -Dcom.sun.management.jmxremote.ssl=是否安全连接 Dcom.sun.management.jmxremote.authenticate=是否认证 java类 修改 /etc/hosts 文件将 127.0.0.1 映射至主机名 如果要认证访问，还需要做如下步骤 复制 jmxremote.password 文件 修改 jmxremote.password 和 jmxremote.access 文件的权限为600即文件所有者可读写 连接时填入 controlRole（用户名），R\u0026D（密码） ","date":"2023-10-07","objectID":"/blog/20231007_concurrent/:3:3","tags":["Java","多线程","高并行","高并发","设计模式","study"],"title":"并发编程","uri":"/blog/20231007_concurrent/"},{"categories":["Technology"],"content":"线程运行原理 栈与栈帧 Java Virtual Machine Stacks（Java虚拟机栈） 我们都知道jVM中由堆、栈、方法区所组成，其中栈内存是给谁用的呢？其实就是线程，每个线程启动后，虚拟机就会为其分配一块栈内存 每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存 每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法 线程上下文切换（Thread Context Switch） 因为以下一些原因导致CPU不再执行当前的线程，转而执行另一个线程的代码 线程的CPU时间片用完 垃圾回收 有更高优先级的线程需要运行 线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法 当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java中对应的概念就是程序计数器（Program Counter Register），它的作用是记住下一条 JVM 指令的执行地址，是线程私有的 状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、放回地址等 Context Switch 频繁发生会影响性能 ","date":"2023-10-07","objectID":"/blog/20231007_concurrent/:3:4","tags":["Java","多线程","高并行","高并发","设计模式","study"],"title":"并发编程","uri":"/blog/20231007_concurrent/"},{"categories":["Technology"],"content":"线程常见方法 方法名 static 功能说明 注意 start() 启动一个新线 程，在新的线程 运行 run 方法 中的代码 start 方法只是让线程进入就绪，里面代码不一定立刻 运行（CPU 的时间片还没分给它）。每个线程对象的 start方法只能调用一次，如果调用了多次会出现 IllegalThreadStateException run() 新线程启动后会 调用的方法 如果在构造 Thread 对象时传递了 Runnable 参数，则 线程启动后会调用 Runnable 中的 run 方法，否则默 认不执行任何操作。但可以创建 Thread 的子类对象， 来覆盖默认行为 join() 等待线程运行结 束 join(long n) 等待线程运行结 束,最多等待 n 毫秒 getId() 获取线程长整型 的 id id 唯一 getName() 获取线程名 setName(String) 修改线程名 getPriority() 获取线程优先级 setPriority(int) 修改线程优先级 java中规定线程优先级是1~10 的整数，较大的优先级 能提高该线程被 CPU 调度的机率 getState() 获取线程状态 Java 中线程状态是用 6 个 enum 表示，分别为： NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED isInterrupted() 判断是否被打 断， 不会清除打断标记 isAlive() 线程是否存活 （还没有运行完 毕） interrupt() 打断线程 如果被打断线程正在 sleep，wait，join 会导致被打断 的线程抛出 InterruptedException，并清除 打断标 记 ；如果打断的正在运行的线程，则会设置 打断标 记 ；park 的线程被打断，也会设置 打断标记 interrupted() static 判断当前线程是 否被打断 会清除打断标记 currentThread() static 获取当前正在执 行的线程 sleep(long n) static 让当前执行的线 程休眠n毫秒， 休眠时让出 cpu 的时间片给其它 线程 yield() static 提示线程调度器 让出当前线程对 CPU的使用 主要是为了测试和调试 ","date":"2023-10-07","objectID":"/blog/20231007_concurrent/:3:5","tags":["Java","多线程","高并行","高并发","设计模式","study"],"title":"并发编程","uri":"/blog/20231007_concurrent/"},{"categories":["Technology"],"content":"start 与 run 调用 run() public static void main(String[] args) { Thread t1 = new Thread(\"t1\") { @Override public void run() { log.debug(Thread.currentThread().getName()); FileReader.read(Constants.MP4_FULL_PATH); } }; t1.run(); log.debug(\"do other things ...\"); } 输出 19:39:14 [main] c.TestStart - main 19:39:14 [main] c.FileReader - read [1.mp4] start ... 19:39:18 [main] c.FileReader - read [1.mp4] end ... cost: 4227 ms 19:39:18 [main] c.TestStart - do other things ... 程序仍在main线程运行，FileReader.read()方法调用还是同步的 调用 start() 将上述代码的t1.run()改为 t1.start(); 输出 19:41:30 [main] c.TestStart - do other things ... 19:41:30 [t1] c.TestStart - t1 19:41:30 [t1] c.FileReader - read [1.mp4] start ... 19:41:35 [t1] c.FileReader - read [1.mp4] end ... cost: 4542 ms 程序在t1线程中运行，FileReader.read()方法调用是异步的 小结 直接调用 run() 是在主线程中执行了run方法中内容，没有真正启动新的线程 使用 start() 是启动新的线程，通过新的线程间接执行了run方法中的代码 ","date":"2023-10-07","objectID":"/blog/20231007_concurrent/:3:6","tags":["Java","多线程","高并行","高并发","设计模式","study"],"title":"并发编程","uri":"/blog/20231007_concurrent/"},{"categories":["Technology"],"content":"sleep 与 yield sleep 调用 sleep 会让当前线程从 Running 进入 Timed Waiting 状态（阻塞） 其他线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会跑出 InterruptedException 睡眠结束后的线程未必会立刻得到执行 建议使用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性 yield 调用 yield 会让当前线程从 Running 进入 Runnable 就绪状态，然后调度执行其他线程 具体的实现依赖于操作系统的任务调度器 线程优先级 线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它 如果 CPU 比较忙，那么优先级高的线程会获得更多的时间片，但 CPU 空闲时，优先级几乎没有作用 Runnable task1 = () -\u003e { int count = 0; for (;;) { System.out.println(\"----\u003e1 \" + count++); } }; Runnable task2 = () -\u003e { int count = 0; for (;;) { // Thread.yield(); System.out.println(\"----\u003e2 \" + count++); } }; Thread t1 = new Thread(task1, \"t1\"); Thread t2 = new Thread(task2, \"t2\"); // t1.setPriority(Thread.MIN_PRIORITY); // t2.setPriority(Thread.MAX_PRIORITY); t1.start(); t2.start(); ","date":"2023-10-07","objectID":"/blog/20231007_concurrent/:3:7","tags":["Java","多线程","高并行","高并发","设计模式","study"],"title":"并发编程","uri":"/blog/20231007_concurrent/"},{"categories":["Technology"],"content":"join方法详解 为什么需要join 执行下面代码，打印r是什么？ static int r = 0; public static void main(String[] args) throws InterruptedException { test1(); } private static void test1() throws InterruptedException { log.debug(\"开始\"); Thread t1 = new Thread(() -\u003e { log.debug(\"开始\"); sleep(1); log.debug(\"结束\"); r = 10; }); t1.start(); log.debug(\"结果为:{}\", r); log.debug(\"结束\"); } 分析 因为主线程和线程t1是并行执行的，t1线程需要1秒之后才能算出r=10 而主线程一开始就要打印r的结果，所以只能打印出r=0 解决办法 使用 sleep 行不行？为什么？ 用 join，加在t1.start()之后即可 同步应用案例 以调用方角度来讲，如果 需要等待结果返回，才能继续运行就是同步 不需要等待结果返回，就能继续运行就是异步 同步 等待多个结果 问，下面代码 cost 大约多少秒？ static int r1 = 0; static int r2 = 0; public static void main(String[] args) throws InterruptedException { test2(); } private static void test2() throws InterruptedException { Thread t1 = new Thread(() -\u003e { sleep(1); r1 = 10; }); Thread t2 = new Thread(() -\u003e { sleep(2); r2 = 20; }); long start = System.currentTimeMillis(); t1.start(); t2.start(); t1.join(); t2.join(); long end = System.currentTimeMillis(); log.debug(\"r1: {} r2: {} cost: {}\", r1, r2, end - start); } 分析如下 第一个 join：等待t1时，t2并没有停止，而在运行 第二个 join：1s后，执行到此，t2也运行了1s，因此也只需再等待1s 如果颠倒两个 join 呢？ 20:45:43.239 [main] c.TestJoin - r1: 10 r2: 20 cost: 2005 异步 有时效的join 等待时间 static int r1 = 0; static int r2 = 0; public static void main(String[] args) throws InterruptedException { test3(); } public static void test3() throws InterruptedException { Thread t1 = new Thread(() -\u003e { sleep(1); r1 = 10; }); long start = System.currentTimeMillis(); t1.start(); // 线程执行结束会导致 join 结束 t1.join(1500); long end = System.currentTimeMillis(); log.debug(\"r1: {} r2: {} cost: {}\", r1, r2, end - start); } 输出 20:48:01.320 [main] c.TestJoin - r1: 10 r2: 0 cost: 1010 没等够时间 static int r1 = 0; static int r2 = 0; public static void main(String[] args) throws InterruptedException { test3(); } public static void test3() throws InterruptedException { Thread t1 = new Thread(() -\u003e { sleep(2); r1 = 10; }); long start = System.currentTimeMillis(); t1.start(); // 线程执行结束会导致 join 结束 t1.join(1500); long end = System.currentTimeMillis(); log.debug(\"r1: {} r2: {} cost: {}\", r1, r2, end - start); } 输出 20:52:15.623 [main] c.TestJoin - r1: 0 r2: 0 cost: 1502 ","date":"2023-10-07","objectID":"/blog/20231007_concurrent/:3:8","tags":["Java","多线程","高并行","高并发","设计模式","study"],"title":"并发编程","uri":"/blog/20231007_concurrent/"},{"categories":["Technology"],"content":"interrupt方法详解 打断 sleep，wait，join 的线程 **sleep，wait，join **这些方法都会让线程进入阻塞状态 打断 sleep 的线程，会清空打断状态，以sleep为例 private static void test1() throws InterruptedException { Thread t1 = new Thread(()-\u003e{ sleep(1); }, \"t1\"); t1.start(); sleep(0.5); t1.interrupt(); log.debug(\" 打断状态: {}\",t1.isInterrupted()); } 输出 java.lang.InterruptedException: sleep interrupted at java.lang.Thread.sleep(Native Method) at java.lang.Thread.sleep(Thread.java:340) at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:386) at cn.itcast.n2.util.Sleeper.sleep(Sleeper.java:8) at cn.itcast.n4.TestInterrupt.lambda$test1$3(TestInterrupt.java:59) at java.lang.Thread.run(Thread.java:745) 21:18:10.374 [main] c.TestInterrupt - 打断状态: false 打断正常运行的线程 打断正常运行的线程，不会清空打断状态 private static void test2() throws InterruptedException { Thread t2 = new Thread(()-\u003e{ while(true) { Thread current = Thread.currentThread(); boolean interrupted = current.isInterrupted(); if(interrupted) { log.debug(\" 打断状态: {}\", interrupted); break; } } }, \"t2\"); t2.start(); sleep(0.5); t2.interrupt(); } 输出 20:57:37.964 [t2] c.TestInterrupt - 打断状态: true 打断 park 线程 打断 park 线程，不会清空打断状态 private static void test3() throws InterruptedException { Thread t1 = new Thread(() -\u003e { log.debug(\"park...\"); LockSupport.park(); log.debug(\"unpark...\"); log.debug(\"打断状态：{}\",Thread.currentThread().isInterrupted()); }, \"t1\"); t1.start(); sleep(0.5); t1.interrupt(); } 输出 21:11:52.795 [t1] c.TestInterrupt - park... 21:11:53.295 [t1] c.TestInterrupt - unpark... 21:11:53.295 [t1] c.TestInterrupt - 打断状态：true 如果打断标记已经是 true，则 park 会失效 private static void test4() { Thread t1 = new Thread(() -\u003e { for (int i = 0; i \u003c 5; i++) { log.debug(\"park...\"); LockSupport.park(); log.debug(\"打断状态：{}\", Thread.currentThread().isInterrupted()); } }); t1.start(); sleep(1); t1.interrupt(); } 输出 21:13:48.783 [Thread-0] c.TestInterrupt - park... 21:13:49.809 [Thread-0] c.TestInterrupt - 打断状态：true 21:13:49.812 [Thread-0] c.TestInterrupt - park... 21:13:49.813 [Thread-0] c.TestInterrupt - 打断状态：true 21:13:49.813 [Thread-0] c.TestInterrupt - park... 21:13:49.813 [Thread-0] c.TestInterrupt - 打断状态：true 21:13:49.813 [Thread-0] c.TestInterrupt - park... 21:13:49.813 [Thread-0] c.TestInterrupt - 打断状态：true 21:13:49.813 [Thread-0] c.TestInterrupt - park... 21:13:49.813 [Thread-0] c.TestInterrupt - 打断状态：true 提示 可以使用Thread.interrupted() 清除打断状态 ","date":"2023-10-07","objectID":"/blog/20231007_concurrent/:3:9","tags":["Java","多线程","高并行","高并发","设计模式","study"],"title":"并发编程","uri":"/blog/20231007_concurrent/"},{"categories":["Technology"],"content":"不推荐的方法 还有一些不推荐使用的方法，这些方法已过时，容易破坏同步代码块，造成线程死锁 方法名 static 功能说明 stop() 停止线程运行 suspend() 挂起（暂停）线程运行 resume() 恢复线程运行 ","date":"2023-10-07","objectID":"/blog/20231007_concurrent/:3:10","tags":["Java","多线程","高并行","高并发","设计模式","study"],"title":"并发编程","uri":"/blog/20231007_concurrent/"},{"categories":["Technology"],"content":"主线程与守护线程 默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其他非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。 应用示例 log.debug(\"开始运行...\"); Thread t1 = new Thread(() -\u003e { log.debug(\"开始运行...\"); sleep(2); log.debug(\"运行结束...\"); }, \"daemon\"); // 设置该线程为守护线程 t1.setDaemon(true); t1.start(); sleep(1); log.debug(\"运行结束...\"); 输出 08:26:38.123 [main] c.TestDaemon - 开始运行... 08:26:38.213 [daemon] c.TestDaemon - 开始运行... 08:26:39.215 [main] c.TestDaemon - 运行结束... 注意 垃圾回收器线程就是一种守护线程 Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求 ","date":"2023-10-07","objectID":"/blog/20231007_concurrent/:3:11","tags":["Java","多线程","高并行","高并发","设计模式","study"],"title":"并发编程","uri":"/blog/20231007_concurrent/"},{"categories":["Technology"],"content":"五种状态 这是从 操作系统 层面来划分描述的 线程五种状态 【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联 【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行 【运行状态】指获取了 CPU 时间片运行中的状态 当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换 【阻塞状态】 如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入 【阻塞状态】 等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】 与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑 调度它们 【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态 ","date":"2023-10-07","objectID":"/blog/20231007_concurrent/:3:12","tags":["Java","多线程","高并行","高并发","设计模式","study"],"title":"并发编程","uri":"/blog/20231007_concurrent/"},{"categories":["Technology"],"content":"六种状态 这时从 Java API 层面来描述的 根据 Thread.State 枚举，分为六种状态 线程六种状态 NEW 线程刚被创建，但是还没有调用 RUNNABLE 当调用了 start() 方法 方法之后，注意，Java API 层面的 RUNNABLE 状态涵盖了 操作系统 层面的【可运行状态】、【运行状态】和【阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为 是可运行） BLOCKED ， WAITING ， TIMED_WAITING 都是 Java API 层面对【阻塞状态】的细 TERMINATED 当线程代码运行结束 ","date":"2023-10-07","objectID":"/blog/20231007_concurrent/:3:13","tags":["Java","多线程","高并行","高并发","设计模式","study"],"title":"并发编程","uri":"/blog/20231007_concurrent/"},{"categories":["Technology"],"content":"共享模型 ","date":"2023-10-07","objectID":"/blog/20231007_concurrent/:4:0","tags":["Java","多线程","高并行","高并发","设计模式","study"],"title":"并发编程","uri":"/blog/20231007_concurrent/"},{"categories":["Technology"],"content":"Java体现 两个线程对初始值为0的静态变量一个做自增，一个做自减，各做5000次，结果是0吗？ static int counter = 0; public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(() -\u003e { for (int i = 0; i \u003c 5000; i++) { counter++; } }, \"t1\"); Thread t2 = new Thread(() -\u003e { for (int i = 0; i \u003c 5000; i++) { counter--; } }, \"t2\"); t1.start(); t2.start(); t1.join(); t2.join(); log.debug(\"{}\",counter); } 问题分析 以上的结果可能是正数、负数、零。为什么呢？因为Java中对静态变量的自增，自减并不是原子操作，要彻底理解，必须从字节码角度来进行分析 例如对于 i++ 而言（i为静态变量），实际会产生如下的JVM字节码指令： getstatic i // 获取静态变量i的值 iconst_1 // 准备常量1 iadd // 自增 putstatic i // 将修改后的值存入静态变量i 而对应 i-- 也是类似： getstatic i // 获取静态变量 i 的值 iconst_1 // 准备常量1 isub // 自减 putstatic i // 将修改后的值存入静态变量 i 而Java的内存模型如下，完成静态变量的自增，自减需要在主存和工作内存中进行数据交换 Java内存模型 如果是单线程以上8行代码是顺序执行（不会交错）没有问题： 单线程下运行 但多线程下这8行代码可能交错运行： 出现负数的情况： 多线程下运行下出现负数情况 出现正数的情况： 多线程下运行出现正数情况 临界区Critical Section 一个程序运行多个线程本身是没有问题的 问题出在多线程访问共享资源 多个线程读共享资源其实也没有问题 在多个线程对共享资源读写操作时发生指令交错，就会出现问题 一段代码块如果存在对共享资源的多线程读写操作，称这段代码块为临界区 例如，下面代码中的临界区 static int counter = 0; static void increment() // 临界区 { counter++; } static void decrement() // 临界区 { counter--; } 竞态条件Race Condition 多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竞态条件 ","date":"2023-10-07","objectID":"/blog/20231007_concurrent/:4:1","tags":["Java","多线程","高并行","高并发","设计模式","study"],"title":"并发编程","uri":"/blog/20231007_concurrent/"},{"categories":["Technology"],"content":"Synchronized 为了避免临界区的竞态条件发生，由多种手段可以达到目的 阻塞式的解决方案：Synchronized，Lock 非阻塞式的解决方案：原子变量 本次使用阻塞式的解决方案：Synchronized，来解决上述问题，即俗称的 对象锁 ，它采用互斥的方式让同一时刻至多只有一个线程能持有 对象锁 ，其他线程再想获取这个 对象锁 时就会被阻塞住，这样就能保证拥有锁的线程可以安全的执行临界区的代码，不用担心线程上下文切换 注意 虽然Java中互斥和同步都可以采用Synchronized关键字来完成，但它们还是有区别的 互斥是保证临界区的竞态发生，同一时刻只能有一个线程执行临界区代码 同步是由于线程执行的先后，顺序不同，需要一个线程等待其他线程运行到某个点 Synchronized语法 synchronized(对象) // 线程1， 线程2(blocked) { 临界区 } 解决 static int counter = 0; static final Object room = new Object(); public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(() -\u003e { for (int i = 0; i \u003c 5000; i++) { synchronized (room) { counter++; } } }, \"t1\"); Thread t2 = new Thread(() -\u003e { synchronized (room) { for (int i = 0; i \u003c 5000; i++) { counter--; } } }, \"t2\"); t1.start(); t2.start(); t1.join(); t2.join(); log.debug(\"{}\",counter); } 执行过程 Synchronized执行过程 面向对象改进 把需要保护的共享变量放入一个类 class Room { int value = 0; public void increment() { synchronized (this) { value++; } } public void decrement() { synchronized (this) { value--; } } public int get() { synchronized (this) { return value; } } } @Slf4j public class Test1 { public static void main(String[] args) throws InterruptedException { Room room = new Room(); Thread t1 = new Thread(() -\u003e { for (int j = 0; j \u003c 5000; j++) { room.increment(); } }, \"t1\"); Thread t2 = new Thread(() -\u003e { for (int j = 0; j \u003c 5000; j++) { room.decrement(); } }, \"t2\"); t1.start(); t2.start(); t1.join(); t2.join(); log.debug(\"count: {}\" , room.get()); } } 方法上的synchronized class Test{ public synchronized void test() { } } 等价于 class Test{ public void test() { synchronized(this) { } } } class Test{ public synchronized static void test() { } } 等价于 class Test{ public static void test() { synchronized(Test.class) { } } } 不加synchronzied的方法 不加 synchronized 的方法就好比不遵守规则的人，不去老实排队（好比翻窗户进去的） ","date":"2023-10-07","objectID":"/blog/20231007_concurrent/:4:2","tags":["Java","多线程","高并行","高并发","设计模式","study"],"title":"并发编程","uri":"/blog/20231007_concurrent/"},{"categories":["Technology"],"content":"线程八锁 其实就是考察synchronized锁住的是哪个对象 情况1：12 或 21 @Slf4j(topic = \"c.Number\") class Number{ public synchronized void a() { log.debug(\"1\"); } public synchronized void b() { log.debug(\"2\"); } } public static void main(String[] args) { Number n1 = new Number(); new Thread(()-\u003e{ n1.a(); }).start(); new Thread(()-\u003e{ n1.b(); }).start(); } 情况2：1s后 12，或2 1s后 1 @Slf4j(topic = \"c.Number\") class Number{ public synchronized void a() { sleep(1); log.debug(\"1\"); } public synchronized void b() { log.debug(\"2\"); } } public static void main(String[] args) { Number n1 = new Number(); new Thread(()-\u003e{ n1.a(); }).start(); new Thread(()-\u003e{ n1.b(); }).start(); } 情况3：3 1s后 12，或23 1s后 1，或32 1s后 1 @Slf4j(topic = \"c.Number\") class Number{ public synchronized void a() { sleep(1); log.debug(\"1\"); } public synchronized void b() { log.debug(\"2\"); } public void c() { log.debug(\"3\"); } } public static void main(String[] args) { Number n1 = new Number(); new Thread(()-\u003e{ n1.a(); }).start(); new Thread(()-\u003e{ n1.b(); }).start(); new Thread(()-\u003e{ n1.c(); }).start(); } 情况4：2 1s后 1 @Slf4j(topic = \"c.Number\") class Number{ public synchronized void a() { sleep(1); log.debug(\"1\"); } public synchronized void b() { log.debug(\"2\"); } } public static void main(String[] args) { Number n1 = new Number(); Number n2 = new Number(); new Thread(()-\u003e{ n1.a(); }).start(); new Thread(()-\u003e{ n2.b(); }).start(); } 情况5：2 1s后 1 @Slf4j(topic = \"c.Number\") class Number{ public static synchronized void a() { sleep(1); log.debug(\"1\"); } public synchronized void b() { log.debug(\"2\"); } } public static void main(String[] args) { Number n1 = new Number(); new Thread(()-\u003e{ n1.a(); }).start(); new Thread(()-\u003e{ n1.b(); }).start(); } 情况6：1s后 12，或2 1s后 1 @Slf4j(topic = \"c.Number\") class Number{ public static synchronized void a() { sleep(1); log.debug(\"1\"); } public static synchronized void b() { log.debug(\"2\"); } } public static void main(String[] args) { Number n1 = new Number(); new Thread(()-\u003e{ n1.a(); }).start(); new Thread(()-\u003e{ n1.b(); }).start(); } 情况7：2 1s后 1 @Slf4j(topic = \"c.Number\") class Number{ public static synchronized void a() { sleep(1); log.debug(\"1\"); } public synchronized void b() { log.debug(\"2\"); } } public static void main(String[] args) { Number n1 = new Number(); Number n2 = new Number(); new Thread(()-\u003e{ n1.a(); }).start(); new Thread(()-\u003e{ n2.b(); }).start(); } 情况8：1s后 12，或2 1s后 1 @Slf4j(topic = \"c.Number\") class Number{ public static synchronized void a() { sleep(1); log.debug(\"1\"); } public static synchronized void b() { log.debug(\"2\"); } } public static void main(String[] args) { Number n1 = new Number(); Number n2 = new Number(); new Thread(()-\u003e{ n1.a(); }).start(); new Thread(()-\u003e{ n2.b(); }).start(); } 变量的线程安全分析 成员变量和静态变量是否线程安全？ 如果它们没有共享，则线程安全 如果它们被共享了，根据它们的状态是否能够改变，又分两种情况 如果只有读操作，则线程安全 如果有读写操作，则这段代码是临界区，需要考虑线程安全 局部变量是否线程安全？ 局部变量是线程安全的 但局部变量引用的对象则未必 如果该对象没有逃离方法的作用访问，它是线程安全的 如果该对象逃离方法的作用范围，需要考虑线程安全 局部变量线程安全分析？ public static void test1() { int i = 10; i++; } 每个线程调用test1()方法时局部变量i，会在每个线程的栈帧内存中被创建多份，因此不存在共享 public static void test1(); descriptor: ()V flags: ACC_PUBLIC, ACC_STATIC Code: stack=1, locals=1, args_size=0 0: bipush 10 2: istore_0 3: iinc 0, 1 6: return LineNumberTable: line 10: 0 line 11: 3 line 12: 6 LocalVariableTable: Start Length Slot Name Signature 3 4 0 i I 如下图展示 栈帧展示 局部变量的引用稍有不同 先看一个成员变量的例子 class ThreadUnsafe { ArrayList\u003cString\u003e list = new ArrayList\u003c\u003e(); public void method1(int loopNumber) { for (int i = 0; i \u003c loopNumber; i++) { // { 临界区, 会产生竞态条件 method2(); method3(); // } 临界区 } } private void method2() { list.add(\"1\"); } private void method3() { list.remove(0); } } 执行 static final int THREAD_NUMBER = 2; static final int LOOP_NUMBER = 200; public static void main(String[] args) { ThreadUnsafe test = new ThreadUnsafe(); for (int i = 0; i \u003c THREAD_NUMBER; i++) { new Thread(() -\u003e { test.method1(LOOP_NUMBER); }, \"Thread\" + i).start(); } } 其中一种情况是，如果线程2还未add，线程1 remove就会报错： Exception in thread \"Thread1\" java.lang.IndexOutOfBoundsException: Index: 0, Size: 0 at","date":"2023-10-07","objectID":"/blog/20231007_concurrent/:4:3","tags":["Java","多线程","高并行","高并发","设计模式","study"],"title":"并发编程","uri":"/blog/20231007_concurrent/"},{"categories":["Technology"],"content":"常见线程安全类 String Integer StringBuffer Random Vector Hashtable java.util.concurrent包下的类 这里说它们是线程安全的是指，多个线程调用它们同一个实例的某个方法时，是线程安全的。也可以理解为 Hashtable table = new Hashtable(); new Thread(()-\u003e{ table.put(\"key\", \"value1\"); }).start(); new Thread(()-\u003e{ table.put(\"key\", \"value2\"); }).start(); 它们每个方法是原子的 但注意它们多个方法的组合不是原子的 线程安全类方法的组合 分析下面代码是否线程安全 Hashtable table = new Hashtable(); // 线程1，线程2 if( table.get(\"key\") == null) { table.put(\"key\", value); } 代码图解 不可变类线程安全性 String、Integer等都是不可变类，因为其内部的状态不可以改变，因此它们的方法都是线程安全的。 public class Immutable{ private int value = 0; public Immutable(int value){ this.value = value; } public int getValue(){ return this.value; } } 如果想增加一个增加的方法呢 public class Immutable{ private int value = 0; public Immutable(int value){ this.value = value; } public int getValue(){ return this.value; } public Immutable add(int v){ return new Immutable(this.value + v); } } ","date":"2023-10-07","objectID":"/blog/20231007_concurrent/:4:4","tags":["Java","多线程","高并行","高并发","设计模式","study"],"title":"并发编程","uri":"/blog/20231007_concurrent/"},{"categories":["Technology"],"content":"Monitor概念 Java对象头 以32位虚拟机为例 普通对象 普通对象头 数组对象 数组对象头 其中 Mark Word 结构为 MarkWord结构 64位虚拟机 Mark Word 64位虚拟机MarkWord 参考资料 ","date":"2023-10-07","objectID":"/blog/20231007_concurrent/:4:5","tags":["Java","多线程","高并行","高并发","设计模式","study"],"title":"并发编程","uri":"/blog/20231007_concurrent/"},{"categories":["Technology"],"content":"wait notify API 介绍 obj.wait()让进入object监视器的线程到waitSet等待 obj.notify()在object上正在waitSet等待的线程中挑一个唤醒 obj.notifyAll()让object上正在waitSet等待的线程全部唤醒 它们都是线程之间进行协作的手段，都属于Object对象的方法，必须获得此对象的锁，才能调用这几个方法 final static Object obj = new Object(); public static void main(String[] args) { new Thread(() -\u003e { synchronized (obj) { log.debug(\"执行....\"); try { obj.wait(); // 让线程在obj上一直等待下去 } catch (InterruptedException e) { e.printStackTrace(); } log.debug(\"其它代码....\"); } }).start(); new Thread(() -\u003e { synchronized (obj) { log.debug(\"执行....\"); try { obj.wait(); // 让线程在obj上一直等待下去 } catch (InterruptedException e) { e.printStackTrace(); } log.debug(\"其它代码....\"); } }).start(); // 主线程两秒后执行 sleep(2); log.debug(\"唤醒 obj 上其它线程\"); synchronized (obj) { obj.notify(); // 唤醒obj上一个线程 // obj.notifyAll(); // 唤醒obj上所有等待线程 } } notify的一种结果 20:00:53.096 [Thread-0] c.TestWaitNotify - 执行.... 20:00:53.099 [Thread-1] c.TestWaitNotify - 执行.... 20:00:55.096 [main] c.TestWaitNotify - 唤醒 obj 上其它线程 20:00:55.096 [Thread-0] c.TestWaitNotify - 其它代码.... notifyAll结果 19:58:15.457 [Thread-0] c.TestWaitNotify - 执行.... 19:58:15.460 [Thread-1] c.TestWaitNotify - 执行.... 19:58:17.456 [main] c.TestWaitNotify - 唤醒 obj 上其它线程 19:58:17.456 [Thread-1] c.TestWaitNotify - 其它代码.... 19:58:17.456 [Thread-0] c.TestWaitNotify - 其它代码.... wait()方法会释放对象的锁，进入WaitSet等待区，从而让其他线程就就有机会获取对象的锁。无限制等待，直到notify为止 wait(long n)有时限的等待，到n毫秒后结束等待，或是被notify sleep(long n) 和 wait(long n) 的区别 sleep 是 Thread 方法，而 wait 是 Object 的方法 sleep 不需要强制和 synchronized 配合使用，但 wait 需要和 synchronized 一起使用 sleep 在睡眠的同时，不会释放对象锁，但 wait 在等待的时候会释放对象锁 它们状态 TIMED_WAITINGsss ","date":"2023-10-07","objectID":"/blog/20231007_concurrent/:4:6","tags":["Java","多线程","高并行","高并发","设计模式","study"],"title":"并发编程","uri":"/blog/20231007_concurrent/"},{"categories":["Technology"],"content":"Park \u0026 Unpark 基本使用 它们是 LockSupport 类中的方法 // 暂停当前线程 LockSupport.park(); // 恢复某个线程的运行 LockSupport.unpark(暂停线程对象) 先 park 再 unpark Thread t1 = new Thread(() -\u003e { log.debug(\"start...\"); sleep(1); log.debug(\"park...\"); LockSupport.park(); log.debug(\"resume...\"); },\"t1\"); t1.start(); sleep(2); log.debug(\"unpark...\"); LockSupport.unpark(t1); 输出结果 18:42:52.585 c.TestParkUnpark [t1] - start... 18:42:53.589 c.TestParkUnpark [t1] - park... 18:42:54.583 c.TestParkUnpark [main] - unpark... 18:42:54.583 c.TestParkUnpark [t1] - resume... 先 unpark 再 park Thread t1 = new Thread(() -\u003e { log.debug(\"start...\"); sleep(2); log.debug(\"park...\"); LockSupport.park(); log.debug(\"resume...\"); }, \"t1\"); t1.start(); sleep(1); log.debug(\"unpark...\"); LockSupport.unpark(t1); 输出结果 18:43:50.765 c.TestParkUnpark [t1] - start... 18:43:51.764 c.TestParkUnpark [main] - unpark... 18:43:52.769 c.TestParkUnpark [t1] - park... 18:43:52.769 c.TestParkUnpark [t1] - resume... 特点 wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark不必 park \u0026 unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程，就不那么【精确】 park \u0026 unpark 可以先 unpark，而 wait \u0026 notify 不能先 notify ","date":"2023-10-07","objectID":"/blog/20231007_concurrent/:4:7","tags":["Java","多线程","高并行","高并发","设计模式","study"],"title":"并发编程","uri":"/blog/20231007_concurrent/"},{"categories":["Technology"],"content":"重新理解线程状态转换 线程状态转换图 假设有线程Thread t 情况1 NEW -\u003e RUNABLE 当调用t.start()方法时，由NEW -\u003e RUNNABLE 情况2 RUNNABLE \u003c-\u003e WAITING t 线程调用synchronized(obj)获取了对象锁后 调用obj.wait()方法时，t 线程从RUNNABLE -\u003e WAITING 调用obj.notify(),obj.notifyAll(),t.interrupt时 竞争锁成功，t 线程从WAITING -\u003e RUNNABLE 竞争锁失败，t 线程从WAITING -\u003e BLOCKED public class TestWaitNotify { final static Object obj = new Object(); public static void main(String[] args) { new Thread(() -\u003e { synchronized (obj) { log.debug(\"执行....\"); try { obj.wait(); } catch (InterruptedException e) { e.printStackTrace(); } log.debug(\"其它代码....\"); // 断点 } },\"t1\").start(); new Thread(() -\u003e { synchronized (obj) { log.debug(\"执行....\"); try { obj.wait(); } catch (InterruptedException e) { e.printStackTrace(); } log.debug(\"其它代码....\"); // 断点 } },\"t2\").start(); sleep(0.5); log.debug(\"唤醒 obj 上其它线程\"); synchronized (obj) { obj.notifyAll(); // 唤醒obj上所有等待线程 } } } 情况3RUNNABLE \u003c–\u003e WAITING 当前线程调用t.join()方法时，当前线程从RUNABLE ——\u003e WAITING 注意当前线程在t 线程对象的监视器上等待 t 线程运行结束，或调用了当前线程的interrupt()时，当前线程从WAITING ——\u003e RUNABLE 情况4RUNABLE \u003c–\u003e WAITING 当前线程调用LockSupport.park()方法会让当前线程从RUNNABLE ——\u003e WAITING 调用LockSupport.unpark(目标线程)或调用了线程的interrupt()，会让目标线程从WAITING ——\u003e RUNABLE 情况5RUNNABLE \u003c–\u003e TIMED_WAITING t线程用synchronized(obj)获取了对象锁后 调用obj.wait(long n)方法时，t线程从RUNNABLE ——\u003e TIMED_WAITING t线程等待时间超过了n毫秒，或调用obj.notify()，obj.notifyAll()，t.interrupt()时 竞争锁成功，t线程从TIMED_WAITING ——\u003e RUNNABLE 竞争锁失败，t线程从TIMED_WAITING ——\u003e BLOCKED ​ 情况6RUNNABLE \u003c–\u003e TIMED_WAITING 当线程调用t.join(long n)方法时，当前先线程从RUNNABLE ——\u003e TIMED_WAITING 注意是当前线程在 t线程 对象的监视器上等待 当前线程等待时间超过了n毫秒，或 t线程 运行结束，或调用了当前线程的interrupt()时，当前线程从TIMED_WAITING ——\u003e RUNNABLE 情况7RUNNABLE \u003c–\u003e TIMED_WAITING 当前线程调用Thread.sleep(long n)，当前线程从RUNNABLE ——\u003e TIMED_WAITING 当前线程等待时间超过了n毫秒，当前线程从TIMED_WAITING ——\u003e RUNNABLE 情况8RUNNABLE \u003c–\u003e TIMED_WAITING 当前线程调用LockSupport.parkNanos(long nanos)或LockSupport.parkUntil(long mills)时，当前线程从RUNNABLE ——\u003e TIMED_WAITING 调用LockSupport.unpark(目标线程)或调用了线程的interrupt()，或是等待超时，会让目标线程从TIMED_WAITING ——\u003e RUNNABLE 情况9RUNNABLE \u003c–\u003e BLOCKED t线程 用synchronized(obj)获取了对象锁时如果竞争失败，从RUNNABLE ——\u003e BLOCKED 持obj锁线程的同步代码块执行完毕，会唤醒该对象上所有BLOCKED的线程重新竞争，如果其中 t线程 竞争成功，从BLOCKED ——\u003e RUNNABLE，其他失败的线程仍然BLOCKED 情况10RUNNABLE \u003c–\u003e TERMINATED 当前线程所有代码运行完毕，进入TERMINATED ","date":"2023-10-07","objectID":"/blog/20231007_concurrent/:4:8","tags":["Java","多线程","高并行","高并发","设计模式","study"],"title":"并发编程","uri":"/blog/20231007_concurrent/"},{"categories":["Technology"],"content":"多把锁 多把不相干的锁 示例：一间大屋子有两个功能：睡觉、学习，互不相干 现在小南要学习，小女要睡觉，但如果只用一间屋子（一个对象锁）的话，那么并发度很低 解决方法是准备多个房间（多个对象锁） 代码演示 class BigRoom { public void sleep() { synchronized (this) { log.debug(\"sleeping 2 小时\"); Sleeper.sleep(2); } } public void study() { synchronized (this) { log.debug(\"study 1 小时\"); Sleeper.sleep(1); } } } // 执行步骤 BigRoom bigRoom = new BigRoom(); new Thread(() -\u003e { bigRoom.compute(); },\"小南\").start(); new Thread(() -\u003e { bigRoom.sleep(); },\"小女\").start(); 执行结果 12:13:54.471 [小南] c.BigRoom - study 1 小时 12:13:55.476 [小女] c.BigRoom - sleeping 2 小时 观察线程启动时间 改进方案 class BigRoom { private final Object studyRoom = new Object(); private final Object bedRoom = new Object(); public void sleep() { synchronized (bedRoom) { log.debug(\"sleeping 2 小时\"); Sleeper.sleep(2); } } public void study() { synchronized (studyRoom) { log.debug(\"study 1 小时\"); Sleeper.sleep(1); } } } 执行结果 12:15:35.069 [小南] c.BigRoom - study 1 小时 12:15:35.069 [小女] c.BigRoom - sleeping 2 小时 将锁的粒度细分 好处：可以增强并发度 坏处：如果一个线程需要同时获取多把锁，就容易发生死锁 ","date":"2023-10-07","objectID":"/blog/20231007_concurrent/:4:9","tags":["Java","多线程","高并行","高并发","设计模式","study"],"title":"并发编程","uri":"/blog/20231007_concurrent/"},{"categories":["Technology"],"content":"活跃性 死锁 有这样的情况：一个线程需要同时获取多把锁，这时就容易发生死锁 t1线程获得A对象锁，接下来想获取B对象的锁t2线程获得B对象锁，接下来想获取A对象的锁 代码演示 Object A = new Object(); Object B = new Object(); Thread t1 = new Thread(() -\u003e { synchronized (A) { log.debug(\"lock A\"); sleep(1); synchronized (B) { log.debug(\"lock B\"); log.debug(\"操作...\"); } } }, \"t1\"); Thread t2 = new Thread(() -\u003e { synchronized (B) { log.debug(\"lock B\"); sleep(0.5); synchronized (A) { log.debug(\"lock A\"); log.debug(\"操作...\"); } } }, \"t2\"); t1.start(); t2.start(); 运行结果 12:22:06.962 [t2] c.TestDeadLock - lock B 12:22:06.962 [t1] c.TestDeadLock - lock A 定位死锁 检测死锁可以使用 jconsole 工具，或者使用 jps 定位进程 id，再用 jstack 定位死锁 cmd \u003e jps Picked up JAVA_TOOL_OPTIONS: -Dfile.encoding=UTF-8 12320 Jps 22816 KotlinCompileDaemon 33200 TestDeadLock // JVM 进程 11508 Main 28468 Launcher cmd \u003e jstack 33200 Picked up JAVA_TOOL_OPTIONS: -Dfile.encoding=UTF-8 2018-12-29 05:51:40 Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.91-b14 mixed mode): \"DestroyJavaVM\" #13 prio=5 os_prio=0 tid=0x0000000003525000 nid=0x2f60 waiting on condition [0x0000000000000000] java.lang.Thread.State: RUNNABLE \"Thread-1\" #12 prio=5 os_prio=0 tid=0x000000001eb69000 nid=0xd40 waiting for monitor entry [0x000000001f54f000] java.lang.Thread.State: BLOCKED (on object monitor) at thread.TestDeadLock.lambda$main$1(TestDeadLock.java:28) - waiting to lock \u003c0x000000076b5bf1c0\u003e (a java.lang.Object) - locked \u003c0x000000076b5bf1d0\u003e (a java.lang.Object) at thread.TestDeadLock$$Lambda$2/883049899.run(Unknown Source) at java.lang.Thread.run(Thread.java:745) \"Thread-0\" #11 prio=5 os_prio=0 tid=0x000000001eb68800 nid=0x1b28 waiting for monitor entry [0x000000001f44f000] java.lang.Thread.State: BLOCKED (on object monitor) at thread.TestDeadLock.lambda$main$0(TestDeadLock.java:15) - waiting to lock \u003c0x000000076b5bf1d0\u003e (a java.lang.Object) - locked \u003c0x000000076b5bf1c0\u003e (a java.lang.Object) at thread.TestDeadLock$$Lambda$1/495053715.run(Unknown Source) at java.lang.Thread.run(Thread.java:745) // 略去部分输出 Found one Java-level deadlock: ============================= \"Thread-1\": waiting to lock monitor 0x000000000361d378 (object 0x000000076b5bf1c0, a java.lang.Object),which is held by \"Thread-0\" \"Thread-0\": waiting to lock monitor 0x000000000361e768 (object 0x000000076b5bf1d0, a java.lang.Object),which is held by \"Thread-1\" Java stack information for the threads listed above: =================================================== \"Thread-1\": at thread.TestDeadLock.lambda$main$1(TestDeadLock.java:28) - waiting to lock \u003c0x000000076b5bf1c0\u003e (a java.lang.Object) - locked \u003c0x000000076b5bf1d0\u003e (a java.lang.Object) at thread.TestDeadLock$$Lambda$2/883049899.run(Unknown Source) at java.lang.Thread.run(Thread.java:745) \"Thread-0\": at thread.TestDeadLock.lambda$main$0(TestDeadLock.java:15) - waiting to lock \u003c0x000000076b5bf1d0\u003e (a java.lang.Object) - locked \u003c0x000000076b5bf1c0\u003e (a java.lang.Object) at thread.TestDeadLock$$Lambda$1/495053715.run(Unknown Source) at java.lang.Thread.run(Thread.java:745) Found 1 deadlock. 避免死锁要注意加锁顺序 另外如果由于某个线程进入死循环，导致其它线程一直等待，对于这种情况 Linux 下可以通过 top 先定位到 CPU 占用高的 Java 进程，再利用top -Hp 进程id来定位是哪个线程，最后再用 jstack 排查 哲学家就餐问题 哲学家就餐问题 有无位哲学家，围坐在圆饭桌旁 他们只做两件事，思考和吃饭，思考一会儿吃口饭，吃完饭后接着思考 吃饭时要用两根筷子吃，桌上一共有5根筷子，每位哲学家左右手边各有一根筷子 如果筷子被身边的人拿着，自己就得等待 筷子类定义 class Chopstick { String name; public Chopstick( String name) { this.name = name; } @Override public String toString() { return \"筷子{\" + name + '}'; } } 哲学家类定义 class Philosopher extends Thread { Chopstick left; Chopstick right; public Philosopher(String name, Chopstick left, Chopstick right) { super(name); this.left = left; this.right = right; } private void eat() { log.debug(\"eating...\"); Sleeper.sleep(1); } @Override public void run() { while (true) { // 获得左手筷子 synchronized (left) { // 获得右手筷子 synchronized (right) { // 吃饭 eat(); } // 放下右手筷子 } // 放下左手筷子 } } } 就餐模拟 Chopstick c1 = new Chopstick(\"1\"); Chopstick c2 = new Chopstick(\"2\"); Chopstick c3 = new Chopstick(\"3\"); Chopstick c4 = new Chopstick(\"4\"); Chopstick c5 = new Chopstick(\"5\"); new Philosopher(\"苏","date":"2023-10-07","objectID":"/blog/20231007_concurrent/:4:10","tags":["Java","多线程","高并行","高并发","设计模式","study"],"title":"并发编程","uri":"/blog/20231007_concurrent/"},{"categories":["Technology"],"content":"ReentrantLock 相对于 synchronized 它具备如下特点 可中断 可以设置超时时间 可以设置为公平锁 支持多个条件变量 与 synchronized 一样，都支持可重入 基本语法 // 获取锁 reentrantLock.lock(); try { // 临界区 } finally { // 释放锁 reentrantLock.unlock(); } 可重入 可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁，如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住 static ReentrantLock lock = new ReentrantLock(); public static void main(String[] args) { method1(); } public static void method1() { lock.lock(); try { log.debug(\"execute method1\"); method2(); } finally { lock.unlock(); } } public static void method2() { lock.lock(); try { log.debug(\"execute method2\"); method3(); } finally { lock.unlock(); } } public static void method3() { lock.lock(); try { log.debug(\"execute method3\"); } finally { lock.unlock(); } } 输出 17:59:11.862 [main] c.TestReentrant - execute method1 17:59:11.865 [main] c.TestReentrant - execute method2 17:59:11.865 [main] c.TestReentrant - execute method3 可打断 示例 ReentrantLock lock = new ReentrantLock(); Thread t1 = new Thread(() -\u003e { log.debug(\"启动...\"); try { lock.lockInterruptibly(); } catch (InterruptedException e) { e.printStackTrace(); log.debug(\"等锁的过程中被打断\"); return; } try { log.debug(\"获得了锁\"); } finally { lock.unlock(); } }, \"t1\"); lock.lock(); log.debug(\"获得了锁\"); t1.start(); try { sleep(1); t1.interrupt(); log.debug(\"执行打断\"); } finally { lock.unlock(); } 输出 18:02:40.520 [main] c.TestInterrupt - 获得了锁 18:02:40.524 [t1] c.TestInterrupt - 启动... 18:02:41.530 [main] c.TestInterrupt - 执行打断 java.lang.InterruptedException at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireInterruptibly(AbstractQueuedSynchr onizer.java:898) at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly(AbstractQueuedSynchron izer.java:1222) at java.util.concurrent.locks.ReentrantLock.lockInterruptibly(ReentrantLock.java:335) at cn.itcast.n4.reentrant.TestInterrupt.lambda$main$0(TestInterrupt.java:17) at java.lang.Thread.run(Thread.java:748) 18:02:41.532 [t1] c.TestInterrupt - 等锁的过程中被打断 注意如果是不可中断模式，那么即使使用了interrupt也不会让等待中断 ReentrantLock lock = new ReentrantLock(); Thread t1 = new Thread(() -\u003e { log.debug(\"启动...\"); lock.lock(); try { log.debug(\"获得了锁\"); } finally { lock.unlock(); } }, \"t1\"); lock.lock(); log.debug(\"获得了锁\"); t1.start(); try { sleep(1); t1.interrupt(); log.debug(\"执行打断\"); sleep(1); } finally { log.debug(\"释放了锁\"); lock.unlock(); } 输出 18:06:56.261 [main] c.TestInterrupt - 获得了锁 18:06:56.265 [t1] c.TestInterrupt - 启动... 18:06:57.266 [main] c.TestInterrupt - 执行打断 // 这时 t1 并没有被真正打断, 而是仍继续等待锁 18:06:58.267 [main] c.TestInterrupt - 释放了锁 18:06:58.267 [t1] c.TestInterrupt - 获得了锁 锁超时 立刻失败 ReentrantLock lock = new ReentrantLock(); Thread t1 = new Thread(() -\u003e { log.debug(\"启动...\"); if (!lock.tryLock()) { log.debug(\"获取立刻失败，返回\"); return; } try { log.debug(\"获得了锁\"); } finally { lock.unlock(); } }, \"t1\"); lock.lock(); log.debug(\"获得了锁\"); t1.start(); try { sleep(2); } finally { lock.unlock(); } 输出 18:15:02.918 [main] c.TestTimeout - 获得了锁 18:15:02.921 [t1] c.TestTimeout - 启动.. 18:15:02.921 [t1] c.TestTimeout - 获取立刻失败，返回 超时失败 ReentrantLock lock = new ReentrantLock(); Thread t1 = new Thread(() -\u003e { log.debug(\"启动...\"); try { if (!lock.tryLock(1, TimeUnit.SECONDS)) { log.debug(\"获取等待 1s 后失败，返回\"); return; } } catch (InterruptedException e) { e.printStackTrace(); } try { log.debug(\"获得了锁\"); } finally { lock.unlock(); } }, \"t1\"); lock.lock(); log.debug(\"获得了锁\"); t1.start(); try { sleep(2); } finally { lock.unlock(); } 输出 18:19:40.537 [main] c.TestTimeout - 获得了锁 18:19:40.544 [t1] c.TestTimeout - 启动... 18:19:41.547 [t1] c.TestTimeout - 获取等待 1s 后失败，返回 使用 tryLock 解决哲学家就餐问题 class Chopstick extends ReentrantLock { String name; public Chopstick(String name) { this.name = name; } @Override public String toString() { return \"筷子{\" + name + '}'; } } class Philosopher extends Thread { Chopstick left; Chopstick right; public Philosopher(String name, Chopstick left, Chopstick right) { super(name); this.left = left; this.right = right; } @Override public void run() { while (true) { // 尝试获得左手筷子 if (left.tryLock()) { try { // 尝试获得右手筷子 if ","date":"2023-10-07","objectID":"/blog/20231007_concurrent/:4:11","tags":["Java","多线程","高并行","高并发","设计模式","study"],"title":"并发编程","uri":"/blog/20231007_concurrent/"},{"categories":["Technology"],"content":"小结 分析多线程访问共享资源时，哪些代码片段属于临界区 使用 synchronized 互斥解决临界区的线程安全 掌握 synchronized 锁对象语法 掌握 synchronized 加载成员方法和静态方法语法 掌握 wait/notify 同步方法 使用 lock 互斥解决临界区的线程安全问题 掌握 lock 的使用细节：可打断、锁超时、公平锁、条件变量 学会分析变量的线程安全、掌握常见线程安全类的使用 了解线程活跃性问题：死锁、活锁、饥饿 应用方面 互斥：使用 synchronized 或 Lock 达到共享资源互斥效果 同步：使用 wait/notify 或 Lock 的条件变量来达到线程间通信效果 原理方面 monitor、synchronized、wait/notify原理 synchronized进阶原理 park \u0026 unpark原理 模式方面 同步模式之保护性暂停 异步模式之生产者消费者 同步模式之顺序控制 ","date":"2023-10-07","objectID":"/blog/20231007_concurrent/:4:12","tags":["Java","多线程","高并行","高并发","设计模式","study"],"title":"并发编程","uri":"/blog/20231007_concurrent/"},{"categories":["Technology"],"content":"共享模型内存 ","date":"2023-10-07","objectID":"/blog/20231007_concurrent/:5:0","tags":["Java","多线程","高并行","高并发","设计模式","study"],"title":"并发编程","uri":"/blog/20231007_concurrent/"},{"categories":["Technology"],"content":"Java内存模式 JMM 即 Java Memory Model，它定义了主存、工作内存抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、CPU指令优化等。 JMM 体现在以下几个方面 原子性：保证指令不会收到线程上下文切换的影响 可见行：保证指令不会收到 CPU 缓存的影响 有序性：保证指令不会受 CPU 指令并行优化的影响 ","date":"2023-10-07","objectID":"/blog/20231007_concurrent/:5:1","tags":["Java","多线程","高并行","高并发","设计模式","study"],"title":"并发编程","uri":"/blog/20231007_concurrent/"},{"categories":["Technology"],"content":"可见行 退不出的循环 先来看一个现象，main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止： static boolean run = true; public static void main(String[] args) throws InterruptedException { Thread t = new Thread(()-\u003e{ while(run){ // .... } }); t.start(); sleep(1); run = false; // 线程t不会如预想的停下来 } 原因分析： 初始状态，t 线程刚开始从主内存读取了 run 的值到工作内存 步骤一 因为 t 线程要频繁从主内存中读取 run 的值，JIT编译器会将 run 的值缓存至自己工作内存中的高速缓存中，减少对主内存中 run 的访问，提高效率 步骤二 1秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是旧值 步骤三 解决方法 volatile（易变关键字） 它可以用来修饰成员变量和静态成员变量，它可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存 可见性 VS 原子性 前面例子体现的实际就是可见性，它保证的是在多个线程之间，一个线程对 volatile 变量的修改对另一个线程可见，不能保证原子性，仅用在一个写线程，多个读线程的情况：上例从字节码理解是这样的： getstatic run // 线程 t 获取 run true getstatic run // 线程 t 获取 run true getstatic run // 线程 t 获取 run true getstatic run // 线程 t 获取 run true putstatic run // 线程 main 修改 run 为 false， 仅此一次 getstatic run // 线程 main 修改 run 为 false 比较一下之前我们将线程安全时举的例子：两个线程一个 i++ 一个 i- -，只能保证看到最新值，不能解决指令交错 // 假设i的初始值为0 getstatic i // 线程2-获取静态变量i的值 线程内i=0 getstatic i // 线程1-获取静态变量i的值 线程内i=0 iconst_1 // 线程1-准备常量1 iadd // 线程1-自增 线程内i=1 putstatic i // 线程1-将修改后的值存入静态变量i 静态变量i=1 iconst_1 // 线程2-准备常量1 isub // 线程2-自减 线程内i=-1 putstatic i // 线程2-将修改后的值存入静态变量i 静态变量i=-1 Synchronized 语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性。但缺点是 Synchronized 是属于重量级操作，性能相对更低 如果在前面示例的死循环中加入 System.out.println() 会发现即使不加 volatile 修饰符，线程t也能正确看到对 run 变量的修改了，请思考一下为什么？ ","date":"2023-10-07","objectID":"/blog/20231007_concurrent/:5:2","tags":["Java","多线程","高并行","高并发","设计模式","study"],"title":"并发编程","uri":"/blog/20231007_concurrent/"},{"categories":["Technology"],"content":"有序性 JVM会在不影响正确性的前提下，可以调整语句的执行顺序，思考一下下面一段代码 static int i; static int j; // 在某个线程内执行如下赋值操作 i = ...; j = ...; 可以看到，至于是先执行 i 还是先执行 j，对最终结果不会产生影响。所以，上面代码真正执行时，既可以是 i = ...; j = ...; 也可以是 j = ...; i = ...; 这种特性称之为【指令重排】，多线程下【指令重排】会影响正确性，为什么要有重排指令这项优化呢？ **提示：**从CPU执行指令的原理角度思考 指令级并行 诡异的结果 int num = 0; boolean ready = false; // 线程1 执行此方法 public void actor1(I_Result r) { if(ready) { r.r1 = num + num; } else { r.r1 = 1; } } // 线程2 执行此方法 public void actor2(I_Result r) { num = 2; ready = true; } I_Result 是一个对象，有一个属性 r1 用来保存结果，问，可能结果有几种？ 有些同学可能会这么分析： **情况1：**线程1先执行，这时 ready=false，所以进入 else 分支结果为1 **情况2：**线程2先执行 num=2，但没来得及执行 ready=true，线程1执行，还是进入else分支，结果为1 **情况3：**线程2执行到 ready=true，线程1执行，这回进入 if 分支，结果为4（因为 num 已经执行过了） 特殊情况：我会告诉你结果可能为0 这种情况是：线程3执行 ready=true，切换线程1，进入 if 分支，相加为0，再切回线程2执行 num=2。相信很多同学已经晕了 这种现象叫做指令重排，是JIT编译器在运行时进行的一些优化，这个现象需要通过大量测试才能复现： 借助Java并发压测工具 jcstress mvn archetype:generate -DinteractiveMode=false -DarchetypeGroupId=org.openjdk.jcstress -DarchetypeArtifactId=jcstress-java-test-archetype -DarchetypeVersion=0.5 -DgroupId=cn.itcast -DartifactId=ordering -Dversion=1.0 创建 maven 项目，提供以下测试类 @JCStressTest @Outcome(id = {\"1\", \"4\"}, expect = Expect.ACCEPTABLE, desc = \"ok\") @Outcome(id = \"0\", expect = Expect.ACCEPTABLE_INTERESTING, desc = \"!!!!\") @State public class ConcurrencyTest { int num = 0; boolean ready = false; @Actor public void actor1(I_Result r) { if(ready) { r.r1 = num + num; } else { r.r1 = 1; } } @Actor public void actor2(I_Result r) { num = 2; ready = true; } } 执行方式 mvn clean install java -jar target/jcstress.jar 会输出我们感兴趣的结果，摘录其中一次结果： jcstress执行结果 可以看到，出现结果为0的情况有638次，虽然次数相对较少，但毕竟是出现了 解决方法 volatile 修饰的变量，可以禁用指令重排 @JCStressTest @Outcome(id = {\"1\", \"4\"}, expect = Expect.ACCEPTABLE, desc = \"ok\") @Outcome(id = \"0\", expect = Expect.ACCEPTABLE_INTERESTING, desc = \"!!!!\") @State public class ConcurrencyTest { int num = 0; volatile boolean ready = false; @Actor public void actor1(I_Result r) { if(ready) { r.r1 = num + num; } else { r.r1 = 1; } } @Actor public void actor2(I_Result r) { num = 2; ready = true; } } 输出结果 *** INTERESTING tests Some interesting behaviors observed. This is for the plain curiosity. 0 matching test results. Happens-before Happens-befor 规定了对共享变量的写操作对其它线程的读操作可见，它是可见性与有序性的一套规则总结，抛开一下happens-before规则，JMM并不能保证一个线程对共享变量的写，对于其他线程对该共享变量的读可见 线程解锁m之前对变量的写，对于接下来对m加锁的其他线程对该变量的读可见 static int x; static Object m = new Object(); new Thread(()-\u003e{ synchronized(m) { x = 10; } },\"t1\").start(); new Thread(()-\u003e{ synchronized(m) { System.out.println(x); } },\"t2\").start(); 线程对 volatile 变量的写，对接下来其它线程对该变量的读可见 volatile static int x; new Thread(()-\u003e{ x = 10; },\"t1\").start(); new Thread(()-\u003e{ System.out.println(x); },\"t2\").start(); 线程 start 前对变量的写，对该线程开始写对该变量的读可见 static int x; x = 10; new Thread(()-\u003e{ System.out.println(x); },\"t2\").start(); 线程结束前对变量的写，对其他线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() 或 t1.join() 等待它结束） static int x; Thread t1 = new Thread(()-\u003e{ x = 10; },\"t1\"); t1.start(); t1.join(); System.out.println(x); 线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见（通过t2.interrupted 或 t2.isInterruped） static int x; public static void main(String[] args) { Thread t2 = new Thread(()-\u003e{ while(true) { if(Thread.currentThread().isInterrupted()) { System.out.println(x); break; } } },\"t2\"); t2.start(); new Thread(()-\u003e{ sleep(1); x = 10; t2.interrupt(); },\"t1\").start(); while(!t2.isInterrupted()) { Thread.yield(); } System.out.println(x); } 对变量默认值（0，false，null）的写，对其它线程对该变量的读可见 具有传递性，如果x hb -\u003e y并且x hb -\u003e z，配合 volatile 的防指令重排，有下面的例子 volatile static int x; static int y; new Thread(()-\u003e{ y = 10; x = 20; },\"t1\").start(); new Thread(()-\u003e{ // x=20 对 t2 可见, 同时 y=10 也对 t2 可见 System.out.println(x); },\"t2\").start(); 变量都是指成员变量或静态成员变量 ","date":"2023-10-07","objectID":"/blog/20231007_concurrent/:5:3","tags":["Java","多线程","高并行","高并发","设计模式","study"],"title":"并发编程","uri":"/blog/20231007_concurrent/"},{"categories":["Technology"],"content":"小结 重点讲解了JMM中的 可见性 - 由 JVM 缓存优化引起 有序性 - 由 JVM 指令重排序优化引起 happen-before 规则 原理方面 CPU 指令并行 volatile 模式方面 两阶段终止模式的 volatile 改进 同步模式 - balking ","date":"2023-10-07","objectID":"/blog/20231007_concurrent/:5:4","tags":["Java","多线程","高并行","高并发","设计模式","study"],"title":"并发编程","uri":"/blog/20231007_concurrent/"},{"categories":["Technology"],"content":"共享模型无锁","date":"2023-10-07","objectID":"/blog/20231007_concurrent/:6:0","tags":["Java","多线程","高并行","高并发","设计模式","study"],"title":"并发编程","uri":"/blog/20231007_concurrent/"},{"categories":["Go"],"content":"Go基础语法和常用特性解析","date":"2023-08-05","objectID":"/blog/go/","tags":["Go","study"],"title":"Go基础语法和常用特性解析","uri":"/blog/go/"},{"categories":["Go"],"content":"Go基础语法和常用特性解析 Go 语言入门指南：基础语法和常用特性解析 Go 语言是由 Google 在 2007 年开发的一种新的编程语言，它具有简单、快速、可靠和安全等优点，已经成为了软件开发领域的一种重要工具。本文将介绍 Go 语言的基础语法和常用特性，并提供一些使用示例，帮助你快速入门 Go 语言。 ","date":"2023-08-05","objectID":"/blog/go/:0:0","tags":["Go","study"],"title":"Go基础语法和常用特性解析","uri":"/blog/go/"},{"categories":["Go"],"content":"一、基础语法 ","date":"2023-08-05","objectID":"/blog/go/:1:0","tags":["Go","study"],"title":"Go基础语法和常用特性解析","uri":"/blog/go/"},{"categories":["Go"],"content":"1. 变量和类型 在 Go 语言中，变量必须先声明后才能使用。声明变量时需要指定变量类型和变量名。 // 声明整型变量 var num int = 10 // 声明浮点型变量 var decimal float64 = 3.14 除了整型和浮点型，Go 语言还支持其他类型，如字符串、布尔型、数组、切片、结构体等。 ","date":"2023-08-05","objectID":"/blog/go/:1:1","tags":["Go","study"],"title":"Go基础语法和常用特性解析","uri":"/blog/go/"},{"categories":["Go"],"content":"2. 赋值和运算符 Go 语言支持常用的算术运算符、比较运算符、逻辑运算符和位运算符。可以使用等号（=）给变量赋值。 Copy code // 计算 1+1 的结果 var sum int = 1 + 1 // 比较两个数是否相等 if num == 10 { fmt.Println(\"num is equal to 10\") } // 逻辑或运算符 if num == 1 || num == 2 { fmt.Println(\"num is either 1 or 2\") } ","date":"2023-08-05","objectID":"/blog/go/:1:2","tags":["Go","study"],"title":"Go基础语法和常用特性解析","uri":"/blog/go/"},{"categories":["Go"],"content":"3. 控制流和函数 Go 语言支持 if、else、else if 和 for 等控制流语句。还可以定义函数来封装常用的代码块。 // 判断一个数是否是偶数 func isEven(num int) bool { return num%2 == 0 } // 循环打印前 n 个斐波那契数列 func fibonacci(n int) { if n \u003c= 1 { return } fibonacci(n-1) + fibonacci(n-2) } // 函数返回值类型 func max(x, y int) int { if x \u003e y { return x } return y } ","date":"2023-08-05","objectID":"/blog/go/:1:3","tags":["Go","study"],"title":"Go基础语法和常用特性解析","uri":"/blog/go/"},{"categories":["Go"],"content":"常用语法功能 字符串声明和使用 字符串声明语法为：const( 字符串名 = \"字符串值\")，例如：const hello = \"Hello, world!\"。 字符串使用语法为：字符串名，例如：hello。 函数声明和调用 函数声明语法为：func 函数名(参数列表) 返回值类型，例如：func add(x, y int) int { return x + y }。 函数调用语法为：函数名(参数列表)，例如：result = add(1, 2)。 控制流程 go语言支持多种控制流程结构，包括if语句、for循环、range循环、函数和switch语句等。 if语句语法为：if 条件语句 { 条件为真时的语句 } else { 条件为假时的语句 }， 例如：if x \u003e 0 { // x是正数 } else { // x是负数或零 }。 for循环语法为：for 初始化语句; 条件语句; 更新语句 { 循环体 }， 例如：for i := 0; i \u003c 10; i++ { // 打印i }。 range循环语法为：for 变量名 := 初始化表达式; 条件语句; 变量名++ { 循环体 }， 例如：for i := 0; i \u003c 10; i++ { // 打印i }。 函数语法为：func 函数名(参数列表) 返回值类型 { 函数体 }， 例如：func max(x, y int) int { if x \u003e y { return x } else { return y } }。 switch语句语法为：switch 表达式 { case 常量1: 语句1; case 常量2: 语句2; ... default: 语句 default }， 例如：switch x := 5; x { case 1: fmt.Println(\"x是1\") case 2: fmt.Println(\"x是2\") default: fmt.Println(\"x不是1也不是2\") }。 ","date":"2023-08-05","objectID":"/blog/go/:1:4","tags":["Go","study"],"title":"Go基础语法和常用特性解析","uri":"/blog/go/"},{"categories":["Go"],"content":"二、常用特性 ","date":"2023-08-05","objectID":"/blog/go/:2:0","tags":["Go","study"],"title":"Go基础语法和常用特性解析","uri":"/blog/go/"},{"categories":["Go"],"content":"1. 切片和切片操作 切片是一种数据结构，它可以动态地分配内存，并且可以快速地进行索引和操作。切片操作包括：初始化、切片大小的改变、切片元素的添加和删除、切片元素的查找和替换等。 ","date":"2023-08-05","objectID":"/blog/go/:2:1","tags":["Go","study"],"title":"Go基础语法和常用特性解析","uri":"/blog/go/"},{"categories":["Go"],"content":"2. 字典和字典操作 字典是一种键值对的数据结构，它可以快速地进行查找和删除操作。字典操作包括：初始化、字典大小的改变、字典元素的添加和删除、字典元素的查找和替换等。 ","date":"2023-08-05","objectID":"/blog/go/:2:2","tags":["Go","study"],"title":"Go基础语法和常用特性解析","uri":"/blog/go/"},{"categories":["Go"],"content":"3. 函数和函数调用 go语言支持函数式编程风格，函数可以作为参数传递，也可以作为返回值返回。函数调用可以使用点号或者括号，点号用于调用包内的函数，括号用于调用包外的函数。 ","date":"2023-08-05","objectID":"/blog/go/:2:3","tags":["Go","study"],"title":"Go基础语法和常用特性解析","uri":"/blog/go/"},{"categories":["Go"],"content":"4. 接口和接口调用 go语言支持接口编程，接口可以被多个类型实现，接口调用可以使用点号或者括号，点号用于调用包内的接口方法，括号用于调用包外的接口方法。 ","date":"2023-08-05","objectID":"/blog/go/:2:4","tags":["Go","study"],"title":"Go基础语法和常用特性解析","uri":"/blog/go/"},{"categories":["Go"],"content":"5. 并发和协程 Go 语言支持并发和协程，可以使用 Goroutine 和 Channel 实现并发编程。 // 创建一个 Goroutine go func() { fmt.Println(\"Hello, world!\") }() // 通道传递数据 var ch = make(chan int) go func() { ch \u003c- 1 }() // 接收通道数据 fmt.Println(\u003c-ch) ","date":"2023-08-05","objectID":"/blog/go/:2:5","tags":["Go","study"],"title":"Go基础语法和常用特性解析","uri":"/blog/go/"},{"categories":["Go"],"content":"6. 错误处理 Go 语言支持错误处理，可以使用 error 类型来表示错误，并使用 panic 和 recover 函数来处理错误。 // 发送数据到网络通道 func sendToChannel(conn net.Conn) error { _, err := conn.Write([]byte(\"Hello, world!\")) return err } // recover 函数捕捉 panic 生成的错误 func main() { defer func() { recover() fmt.Println(\"Recovered from panic\") }() // panic 生成错误 panic(\"This is a panic\") } ","date":"2023-08-05","objectID":"/blog/go/:2:6","tags":["Go","study"],"title":"Go基础语法和常用特性解析","uri":"/blog/go/"},{"categories":["Go"],"content":"7. 包和模块 Go 语言支持包和模块，可以使用 import 语句导入需要使用的包和模块，并使用 Exported 函数获取包内的可导出变量和函数。 // 导入标准库 import ( \"fmt\" \"math\" ) // 导入自定义包 import \"path/filepath\" // 获取导入包内的可导出变量和函数 func max(x, y int) int { if x \u003e y { return x } return y } // 打印结果 func main() { fmt.Println(max(1, 2)) fmt.Println(math.Sqrt(4)) filepath.Println(\"hello\") } ","date":"2023-08-05","objectID":"/blog/go/:2:7","tags":["Go","study"],"title":"Go基础语法和常用特性解析","uri":"/blog/go/"},{"categories":["Java"],"content":"Stream流","date":"2023-05-22","objectID":"/blog/20230522_stream/","tags":["java","stream","collect","函数式编程"],"title":"集合Stream流用法","uri":"/blog/20230522_stream/"},{"categories":["Java"],"content":"📝介绍 上篇文章Lambda常见场景用法中已经间接使用到了Stream操作，你可能当时会有些疑问，问什么会使用Stream流呢？它到底是用来干什么的呢？ Java 8 引入了全新的Stream API。这里的Stream和I/O流不同，它更像具有Iterable的集合类，但行为和集合类又有所不同。 Stream API引入的目的在于弥补Java函数式编程的缺陷。对于很多支持函数式编程的语言，map()、reduce()基本上都内置到语言的标准库中了，不过，Java 8的Stream API总体来讲仍然是非常完善和强大，足以用很少的代码完成许多复杂的功能。 ","date":"2023-05-22","objectID":"/blog/20230522_stream/:1:0","tags":["java","stream","collect","函数式编程"],"title":"集合Stream流用法","uri":"/blog/20230522_stream/"},{"categories":["Java"],"content":"体验Stream流 案例需求 按照下面的要求完成集合的创建和遍历 创建一个集合，存储多个字符串元素 把集合中所有以\"张\"开头的元素存储到一个新的集合 把\"张\"开头的集合中的长度为3的元素存储到一个新的集合 遍历上一步得到的集合 ❌ 原始方式示例代码 public class MyStream { public static void main(String[] args) { //集合的批量添加 ArrayList\u003cString\u003e list1 = new ArrayList\u003c\u003e(List.of(\"张三丰\",\"张无忌\",\"张翠山\",\"王二麻子\",\"张良\",\"谢广坤\")); //list.add() //遍历list1把以张开头的元素添加到list2中。 ArrayList\u003cString\u003e list2 = new ArrayList\u003c\u003e(); for (String s : list1) { if(s.startsWith(\"张\")){ list2.add(s); } } //遍历list2集合，把其中长度为3的元素，再添加到list3中。 ArrayList\u003cString\u003e list3 = new ArrayList\u003c\u003e(); for (String s : list2) { if(s.length() == 3){ list3.add(s); } } for (String s : list3) { System.out.println(s); } } } ✅ 使用Stream流示例代码 public class StreamDemo { public static void main(String[] args) { //集合的批量添加 ArrayList\u003cString\u003e list1 = new ArrayList\u003c\u003e(List.of(\"张三丰\",\"张无忌\",\"张翠山\",\"王二麻子\",\"张良\",\"谢广坤\")); //Stream流 list1.stream().filter(s-\u003es.startsWith(\"张\")) .filter(s-\u003es.length() == 3) .forEach(s-\u003e System.out.println(s)); } } Stream的好处 直接阅读代码的字面意思即可完美展示无关逻辑方式的语义：获取流，过滤姓张，过滤长度为3，逐一打印 Stream流把真正的函数式编程风格引入到了Java中 代码简洁 ","date":"2023-05-22","objectID":"/blog/20230522_stream/:2:0","tags":["java","stream","collect","函数式编程"],"title":"集合Stream流用法","uri":"/blog/20230522_stream/"},{"categories":["Java"],"content":"♠️Stream流的思想 Stream流思想 Stream流的三类方法 获取Stream流 创建一条流水线，并把数据放到流水线上准备进行操作 中间方法 流水线上的操作 一次操作完成之后，还可以继续进行其他操作 终结方法 一个Stream流只能有一个终结方法 是流水线上的最后一个操作 ","date":"2023-05-22","objectID":"/blog/20230522_stream/:2:1","tags":["java","stream","collect","函数式编程"],"title":"集合Stream流用法","uri":"/blog/20230522_stream/"},{"categories":["Java"],"content":"♥️Stream流获取方式 获取方式 方法名 说明 单列集合 default Stream \u003cE\u003e stream Collection中的默认方法 双列集合 无 无法直接使用Stream 数组 public static \u003cT\u003e Stream \u003cT\u003e stream(T[] array) Arrays工具类中的静态方法 零散数据 public static \u003cT\u003e Stream \u003cT\u003e of(T…values) Stream接口中的静态方法 Collection体系集合 使用默认方法stream()生成流 Map体系集合 把Map转成Set结合，间接的生成流 数组 ​ 通过Arrays中的静态方法strean生成流 同种数据类型的多个数据 通过Stream接口的静态方法of(T…values)生成流 代码演示 public class StreamDemo { public static void main(String[] args) { //Collection体系的集合可以使用默认方法stream()生成流 List\u003cString\u003e list = new ArrayList\u003cString\u003e(); Stream\u003cString\u003e listStream = list.stream(); Set\u003cString\u003e set = new HashSet\u003cString\u003e(); Stream\u003cString\u003e setStream = set.stream(); //Map体系的集合间接的生成流 Map\u003cString,Integer\u003e map = new HashMap\u003cString, Integer\u003e(); Stream\u003cString\u003e keyStream = map.keySet().stream(); Stream\u003cInteger\u003e valueStream = map.values().stream(); Stream\u003cMap.Entry\u003cString, Integer\u003e\u003e entryStream = map.entrySet().stream(); //数组可以通过Arrays中的静态方法stream生成流 String[] strArray = {\"hello\",\"world\",\"java\"}; Stream\u003cString\u003e strArrayStream = Arrays.stream(strArray); //同种数据类型的多个数据可以通过Stream接口的静态方法of(T... values)生成流 Stream\u003cString\u003e strArrayStream2 = Stream.of(\"hello\", \"world\", \"java\"); Stream\u003cInteger\u003e intStream = Stream.of(10, 20, 30); } } ","date":"2023-05-22","objectID":"/blog/20230522_stream/:2:2","tags":["java","stream","collect","函数式编程"],"title":"集合Stream流用法","uri":"/blog/20230522_stream/"},{"categories":["Java"],"content":"♦️Stream中间方法 中间操作的意思是，执行完此方法后，Stream流依然可以继续执行其他操作 方法名 说明 Stream \u003cT\u003e filter(Predicate predicate) 用于对流中的数据进行过滤 Stream \u003cT\u003e limit(long maxSize) 返回此流中的元素组成的流，截取前指定参数个数的数据 Stream \u003cT\u003e skip(long n) 跳过指定参数个数的数据，返回由该流的剩余元素组成的流 static \u003cT\u003e Stream \u003cT\u003e concat(Stream a, Stream b) 合并a和b两个流为一个流 Stream \u003cT\u003e distinct() 返回由该流的不同元素（根据Object.equals(Object) ）组成的流 🔮filter操作 public class MyStream { public static void main(String[] args) { // Stream\u003cT\u003e filter(Predicate predicate)：过滤 // Predicate接口中的方法 boolean test(T t)：对给定的参数进行判断，返回一个布尔值 ArrayList\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(\"林青霞\"); list.add(\"张曼玉\"); list.add(\"王祖贤\"); list.add(\"柳岩\"); list.add(\"张敏\"); list.add(\"张无忌\"); //filter方法获取流中的 每一个数据. //而test方法中的s,就依次表示流中的每一个数据. //我们只要在test方法中对s进行判断就可以了. //如果判断的结果为true,则当前的数据留下 //如果判断的结果为false,则当前数据就不要. // list.stream().filter( // new Predicate\u003cString\u003e() { // @Override // public boolean test(String s) { // boolean result = s.startsWith(\"张\"); // return result; // } // } // ).forEach(s-\u003e System.out.println(s)); //因为Predicate接口中只有一个抽象方法test //所以我们可以使用lambda表达式来简化 // list.stream().filter( // (String s)-\u003e{ // boolean result = s.startsWith(\"张\"); // return result; // } // ).forEach(s-\u003e System.out.println(s)); list.stream().filter(s -\u003es.startsWith(\"张\")).forEach(s-\u003e System.out.println(s)); } } 🔮limit\u0026skip操作 public class StreamDemo { public static void main(String[] args) { //创建一个集合，存储多个字符串元素 ArrayList\u003cString\u003e list = new ArrayList\u003cString\u003e(); list.add(\"林青霞\"); list.add(\"张曼玉\"); list.add(\"王祖贤\"); list.add(\"柳岩\"); list.add(\"张敏\"); list.add(\"张无忌\"); //需求1：取前3个数据在控制台输出 list.stream().limit(3).forEach(s-\u003e System.out.println(s)); System.out.println(\"--------\"); //需求2：跳过3个元素，把剩下的元素在控制台输出 list.stream().skip(3).forEach(s-\u003e System.out.println(s)); System.out.println(\"--------\"); //需求3：跳过2个元素，把剩下的元素中前2个在控制台输出 list.stream().skip(2).limit(2).forEach(s-\u003e System.out.println(s)); } } 🔮concat\u0026distinct操作 public class StreamDemo { public static void main(String[] args) { //创建一个集合，存储多个字符串元素 ArrayList\u003cString\u003e list = new ArrayList\u003cString\u003e(); list.add(\"林青霞\"); list.add(\"张曼玉\"); list.add(\"王祖贤\"); list.add(\"柳岩\"); list.add(\"张敏\"); list.add(\"张无忌\"); //需求1：取前4个数据组成一个流 Stream\u003cString\u003e s1 = list.stream().limit(4); //需求2：跳过2个数据组成一个流 Stream\u003cString\u003e s2 = list.stream().skip(2); //需求3：合并需求1和需求2得到的流，并把结果在控制台输出 // Stream.concat(s1,s2).forEach(s-\u003e System.out.println(s)); //需求4：合并需求1和需求2得到的流，并把结果在控制台输出，要求字符串元素不能重复 Stream.concat(s1,s2).distinct().forEach(s-\u003e System.out.println(s)); } } ","date":"2023-05-22","objectID":"/blog/20230522_stream/:2:3","tags":["java","stream","collect","函数式编程"],"title":"集合Stream流用法","uri":"/blog/20230522_stream/"},{"categories":["Java"],"content":"♣️Stream终结方法 终结操作的意思是,执行完此方法之后,Stream流将不能再执行其他操作 方法名 说明 void forEach(Consumer action) 对此流的每个元素执行操作 long count() 返回此流中的元素数 public class MyStream { public static void main(String[] args) { ArrayList\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(\"林青霞\"); list.add(\"张曼玉\"); list.add(\"王祖贤\"); list.add(\"柳岩\"); list.add(\"张敏\"); list.add(\"张无忌\"); //method1(list); // long count()：返回此流中的元素数 long count = list.stream().count(); System.out.println(count); } private static void method1(ArrayList\u003cString\u003e list) { // void forEach(Consumer action)：对此流的每个元素执行操作 // Consumer接口中的方法void accept(T t)：对给定的参数执行此操作 //在forEach方法的底层,会循环获取到流中的每一个数据. //并循环调用accept方法,并把每一个数据传递给accept方法 //s就依次表示了流中的每一个数据. //所以,我们只要在accept方法中,写上处理的业务逻辑就可以了. list.stream().forEach( new Consumer\u003cString\u003e() { @Override public void accept(String s) { System.out.println(s); } } ); System.out.println(\"====================\"); //lambda表达式的简化格式 //是因为Consumer接口中,只有一个accept方法 list.stream().forEach( (String s)-\u003e{ System.out.println(s); } ); System.out.println(\"====================\"); //lambda表达式还是可以进一步简化的. list.stream().forEach(s-\u003eSystem.out.println(s)); } } ","date":"2023-05-22","objectID":"/blog/20230522_stream/:2:4","tags":["java","stream","collect","函数式编程"],"title":"集合Stream流用法","uri":"/blog/20230522_stream/"},{"categories":["Java"],"content":"🎯Stream流收集操作 对数据使用Stream流的方式操作完毕后,可以把流中的数据收集到集合中 方法名 说明 R collect(Collector collector) 把结果收集到集合中 public static \u003cT\u003e Collector toList() 把元素收集到List集合中 public static \u003cT\u003e Collector toSet() 把元素收集到Set集合中 public static Collector toMap(Function keyMapper,Function valueMapper) 把元素收集到Map集合中 // toList和toSet方法演示 public class MyStream { public static void main(String[] args) { ArrayList\u003cInteger\u003e list1 = new ArrayList\u003c\u003e(); for (int i = 1; i \u003c= 10; i++) { list1.add(i); } list1.add(10); list1.add(10); list1.add(10); list1.add(10); list1.add(10); //filter负责过滤数据的. //collect负责收集数据. //获取流中剩余的数据,但是他不负责创建容器,也不负责把数据添加到容器中. //Collectors.toList() : 在底层会创建一个List集合.并把所有的数据添加到List集合中. List\u003cInteger\u003e list = list1.stream().filter(number -\u003e number % 2 == 0) .collect(Collectors.toList()); System.out.println(list); Set\u003cInteger\u003e set = list1.stream().filter(number -\u003e number % 2 == 0) .collect(Collectors.toSet()); System.out.println(set); } } /** Stream流的收集方法 toMap方法演示 创建一个ArrayList集合，并添加以下字符串。字符串中前面是姓名，后面是年龄 \"zhangsan,23\" \"lisi,24\" \"wangwu,25\" 保留年龄大于等于24岁的人，并将结果收集到Map集合中，姓名为键，年龄为值 */ public class MyStream { public static void main(String[] args) { ArrayList\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(\"zhangsan,23\"); list.add(\"lisi,24\"); list.add(\"wangwu,25\"); Map\u003cString, Integer\u003e map = list.stream().filter( s -\u003e { String[] split = s.split(\",\"); int age = Integer.parseInt(split[1]); return age \u003e= 24; } // collect方法只能获取到流中剩余的每一个数据. //在底层不能创建容器,也不能把数据添加到容器当中 //Collectors.toMap 创建一个map集合并将数据添加到集合当中 // s 依次表示流中的每一个数据 //第一个lambda表达式就是如何获取到Map中的键 //第二个lambda表达式就是如何获取Map中的值 ).collect(Collectors.toMap( s -\u003e s.split(\",\")[0], s -\u003e Integer.parseInt(s.split(\",\")[1]) )); System.out.println(map); } } ","date":"2023-05-22","objectID":"/blog/20230522_stream/:3:0","tags":["java","stream","collect","函数式编程"],"title":"集合Stream流用法","uri":"/blog/20230522_stream/"},{"categories":["Java"],"content":"🏆总结 在 Java 8 之前，我们通常是通过 for 循环或者 Iterator 迭代来重新排序合并数据，又或者通过重新定义 Collections.sorts 的 Comparator 方法来实现，这两种方式对于大数据量系统来说，效率并不是很理想。Stream 的聚合操作与数据库 SQL 的聚合操作 sorted、filter、map 等类似。可见用 Stream API 可以写出多么简洁的代码，用其他的模型也可以写出来，但是代码会非常复杂。 ","date":"2023-05-22","objectID":"/blog/20230522_stream/:4:0","tags":["java","stream","collect","函数式编程"],"title":"集合Stream流用法","uri":"/blog/20230522_stream/"},{"categories":["Java"],"content":"Lambda表达式","date":"2023-05-19","objectID":"/blog/20230519_lambda/","tags":["java","lambda","函数式编程"],"title":"Lambda常见场景用法","uri":"/blog/20230519_lambda/"},{"categories":["Java"],"content":"📝介绍 Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。 Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。 使用 Lambda 表达式可以使代码变的更加简洁紧凑。 Lambda表达式特性 可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。 可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。 可选的大括号：如果主体包含了一个语句，就不需要使用大括号。 可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定表达式返回了一个数值。 ","date":"2023-05-19","objectID":"/blog/20230519_lambda/:1:0","tags":["java","lambda","函数式编程"],"title":"Lambda常见场景用法","uri":"/blog/20230519_lambda/"},{"categories":["Java"],"content":"🌈使用场景 ","date":"2023-05-19","objectID":"/blog/20230519_lambda/:2:0","tags":["java","lambda","函数式编程"],"title":"Lambda常见场景用法","uri":"/blog/20230519_lambda/"},{"categories":["Java"],"content":"遍历 ❌ 常规方法 List\u003cString\u003e list = Arrays.asList(\"apple\", \"banana\", \"cherry\"); for (String fruit : list) { System.out.println(fruit); } ✅ 使用Lambda表达式 List\u003cString\u003e list = Arrays.asList(\"apple\", \"banana\", \"cherry\"); list.forEach(fruit -\u003e System.out.println(fruit)); ","date":"2023-05-19","objectID":"/blog/20230519_lambda/:2:1","tags":["java","lambda","函数式编程"],"title":"Lambda常见场景用法","uri":"/blog/20230519_lambda/"},{"categories":["Java"],"content":"排序 ❌ 常规方法 List\u003cString\u003e list = Arrays.asList(\"apple\", \"banana\", \"cherry\"); Collections.sort(list, new Comparator() { public int compare(String s1, String s2) { return s1.compareTo(s2); } }); ✅ 使用Lambda表达式 List\u003cString\u003e list = Arrays.asList(\"apple\", \"banana\", \"cherry\"); Collections.sort(list, (s1, s2) -\u003e s1.compareTo(s2)); ","date":"2023-05-19","objectID":"/blog/20230519_lambda/:2:2","tags":["java","lambda","函数式编程"],"title":"Lambda常见场景用法","uri":"/blog/20230519_lambda/"},{"categories":["Java"],"content":"过滤 ❌ 常规方法 List\u003cString\u003e list = Arrays.asList(\"apple\", \"banana\", \"cherry\"); List filteredList = new ArrayList(); for (String fruit : list) { if (fruit.startsWith(\"a\")) { filteredList.add(fruit); } } ✅ 使用Lambda表达式 List\u003cString\u003e list = Arrays.asList(\"apple\", \"banana\", \"cherry\"); List filter = list.stream() .filter(fruit -\u003e fruit.startsWith(\"a\")) .collect(Collectors.toList()); ","date":"2023-05-19","objectID":"/blog/20230519_lambda/:2:3","tags":["java","lambda","函数式编程"],"title":"Lambda常见场景用法","uri":"/blog/20230519_lambda/"},{"categories":["Java"],"content":"映射 ❌ 常规方法 List\u003cString\u003e list = Arrays.asList(\"apple\", \"banana\", \"cherry\"); List lengths = new ArrayList(); for (String fruit : list) { lengths.add(fruit.length()); } ✅ 使用Lambda表达式 List\u003cString\u003e list1 = Arrays.asList(\"apple\", \"banana\", \"cherry\"); List\u003cInteger\u003elengths=list1.stream() .map(String::length) .collect(Collectors.toList()); ","date":"2023-05-19","objectID":"/blog/20230519_lambda/:2:4","tags":["java","lambda","函数式编程"],"title":"Lambda常见场景用法","uri":"/blog/20230519_lambda/"},{"categories":["Java"],"content":"规约 ❌ 常规方法 List\u003cInteger\u003e list = Arrays.asList(1, 2, 3, 4, 5); int sum = 0; for (int i : list) { sum += i; } ✅ 使用Lambda表达式 List\u003cInteger\u003e list = Arrays.asList(1, 2, 3, 4, 5); int sum = list.stream().reduce(0, Integer::sum); ","date":"2023-05-19","objectID":"/blog/20230519_lambda/:2:5","tags":["java","lambda","函数式编程"],"title":"Lambda常见场景用法","uri":"/blog/20230519_lambda/"},{"categories":["Java"],"content":"分组 ❌ 常规方法 List\u003cString\u003e list = Arrays.asList(\"apple\", \"banana\", \"cherry\"); Map\u003cInteger, List\u003cString\u003e\u003e grouped = new HashMap\u003cInteger, List\u003cString\u003e\u003e(); for (String fruit : list) { int length = fruit.length(); if (!grouped.containsKey(length)) { grouped.put(length, new ArrayList()); } grouped.get(length).add(fruit); } ✅ 使用Lambda表达式 List\u003cString\u003e list = Arrays.asList(\"apple\", \"banana\", \"cherry\"); Map\u003cInteger, List\u003cString\u003e\u003e grouped = list.stream() .collect(Collectors.groupingBy(String::length)); ","date":"2023-05-19","objectID":"/blog/20230519_lambda/:2:6","tags":["java","lambda","函数式编程"],"title":"Lambda常见场景用法","uri":"/blog/20230519_lambda/"},{"categories":["Java"],"content":"函数式接口实现 ❌ 常规方法 public interface MyInterface { public void doSomething(String input); } MyInterface myObject = new MyInterface() { public void doSomething(String input) { System.out.println(input); } }; myObject.doSomething(\"Hello World\"); ✅ 使用Lambda表达式 public interface MyInterface { public void doSomething(String input); } MyInterface myObject = input -\u003e System.out.println(input); myObject.doSomething(\"Hello World\"); ","date":"2023-05-19","objectID":"/blog/20230519_lambda/:2:7","tags":["java","lambda","函数式编程"],"title":"Lambda常见场景用法","uri":"/blog/20230519_lambda/"},{"categories":["Java"],"content":"线程创建 ❌ 常规方法 Thread thread = new Thread(new Runnable() { public void run() { System.out.println(\"Thread is running.\"); } }); thread.start(); ✅ 使用Lambda表达式 Thread thread = new Thread(() -\u003e System.out.println(\"Thread is running.\")); thread.start(); ","date":"2023-05-19","objectID":"/blog/20230519_lambda/:2:8","tags":["java","lambda","函数式编程"],"title":"Lambda常见场景用法","uri":"/blog/20230519_lambda/"},{"categories":["Java"],"content":"Optional操作 ❌ 常规方法 String str = \"Hello World\"; if (str != null) { System.out.println(str.toUpperCase()); } ✅ 使用Lambda表达式 Optional.of(\"hello\") .map(String::toUpperCase) .ifPresent(System.out::println); ","date":"2023-05-19","objectID":"/blog/20230519_lambda/:2:9","tags":["java","lambda","函数式编程"],"title":"Lambda常见场景用法","uri":"/blog/20230519_lambda/"},{"categories":["Java"],"content":"Stream流水线操作 ❌ 常规方法 List\u003cString\u003e list = Arrays.asList(\"apple\", \"banana\", \"cherry\"); List\u003cString\u003e filteredList = new ArrayList(); for (String fruit : list) { if (fruit.startsWith(\"a\")) { filteredList.add(fruit.toUpperCase()); } } Collections.sort(filteredList); ✅ 使用Lambda表达式 List\u003cString\u003e list = Arrays.asList(\"apple\", \"banana\", \"cherry\"); List\u003cString\u003e filteredList = list.stream() .filter(fruit -\u003e fruit.startsWith(\"a\")) .map(String::toUpperCase) .sorted() .collect(Collectors.toList()); ","date":"2023-05-19","objectID":"/blog/20230519_lambda/:2:10","tags":["java","lambda","函数式编程"],"title":"Lambda常见场景用法","uri":"/blog/20230519_lambda/"},{"categories":["Java"],"content":"🏆总结 当你需要一个仅在一个地方有效的函数, 并且只做一件事情，那么就用 lambda。比如，lambda经常用在 sorted 函数的 key 参数中。所以，可以认为，lambda的主要目的是为了减少单行函数的定义。 lambda不会提高代码执行效率，它只是定义了一个匿名函数，使我们的代码更加简洁，而且在某种程度上可读性更高。 注意 如果可以使用for…if来完成的，坚决不用lambda。 如果使用lambda，lambda内不要包含循环，否则，最好定义函数来完成，使代码获得可重用性和更好的可读性。 ","date":"2023-05-19","objectID":"/blog/20230519_lambda/:3:0","tags":["java","lambda","函数式编程"],"title":"Lambda常见场景用法","uri":"/blog/20230519_lambda/"},{"categories":["Java"],"content":"剑指Offer","date":"2023-05-15","objectID":"/blog/20230515_code/","tags":["算法","Java"],"title":"剑指Offer-个人题解","uri":"/blog/20230515_code/"},{"categories":["Java"],"content":"剑指Offer ","date":"2023-05-15","objectID":"/blog/20230515_code/:0:0","tags":["算法","Java"],"title":"剑指Offer-个人题解","uri":"/blog/20230515_code/"},{"categories":["Java"],"content":"简单 ","date":"2023-05-15","objectID":"/blog/20230515_code/:1:0","tags":["算法","Java"],"title":"剑指Offer-个人题解","uri":"/blog/20230515_code/"},{"categories":["Java"],"content":"斐波那契数列 描述 斐波那契数列 输入描述： 一个正整数n 返回值描述： 输出一个正整数。 示例1 输入：4 返回值：3 说明：根据斐波那契数列的定义可知 fib(1)=1,fib(2)=1,fib(3)=fib(3-1)+fib(3-2)=2,fib(4)=fib(4-1)+fib(4-2)=3，所以答案为3。 示例2 输入：1 返回值：1 示例3 输入：2 返回值：1 代码实现 public class Solution { public int Fibonacci(int n) { if(n==1||n==2)return 1; int[] a=new int[n+1]; a[1]=a[2]=1; for(int i=3;i\u003c=n;i++){ a[i]=a[i-1]+a[i-2]; } return a[n]; } } ","date":"2023-05-15","objectID":"/blog/20230515_code/:1:1","tags":["算法","Java"],"title":"剑指Offer-个人题解","uri":"/blog/20230515_code/"},{"categories":["Java"],"content":"数组中重复的数字 描述 数组中重复的数字 示例1 输入：[2,3,1,0,2,5,3] 返回值：2 说明：2或3都是对的 代码实现 import java.util.*; public class Solution { /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param numbers int整型一维数组 * @return int整型 */ public int duplicate (int[] numbers) { // write code here int tep = 0; for(int i = 0;i \u003c numbers.length;i++){ tep = numbers[i]; int count = 0; for(int j = 0; j\u003c numbers.length;j++){ if(tep==numbers[j]){ count++; if(count\u003e1){ return tep; } } } } return -1; } } ","date":"2023-05-15","objectID":"/blog/20230515_code/:1:2","tags":["算法","Java"],"title":"剑指Offer-个人题解","uri":"/blog/20230515_code/"},{"categories":["Java"],"content":"替换空格 描述 替换空格 示例1 输入：\"We Are Happy\" 返回值：\"We%20Are%20Happy\" 示例2 输入：\" \" 返回值：\"%20\" 代码实现 import java.util.*; public class Solution { /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param s string字符串 * @return string字符串 */ public String replaceSpace (String s) { // write code here return s.replace(\" \", \"%20\"); } } ","date":"2023-05-15","objectID":"/blog/20230515_code/:1:3","tags":["算法","Java"],"title":"剑指Offer-个人题解","uri":"/blog/20230515_code/"},{"categories":["Java"],"content":"从尾到头打印链表 描述 从尾到头打印链表 示例1 输入：{1,2,3} 返回值：[3,2,1] 示例2 输入：{67,0,24,58} 返回值：[58,24,0,67] 代码实现 /** * public class ListNode { * int val; * ListNode next = null; * * ListNode(int val) { * this.val = val; * } * } * */ import java.util.ArrayList; public class Solution { public ArrayList\u003cInteger\u003e printListFromTailToHead(ListNode listNode) { ArrayList\u003cInteger\u003e list = new ArrayList\u003c\u003e(); ListNode tmp = listNode; while(tmp!=null){ list.add(0,tmp.val); tmp = tmp.next; } return list; } } ","date":"2023-05-15","objectID":"/blog/20230515_code/:1:4","tags":["算法","Java"],"title":"剑指Offer-个人题解","uri":"/blog/20230515_code/"},{"categories":["Java"],"content":"用两个栈实现队列 描述 用两个栈实现队列 示例1 输入：[\"PSH1\",\"PSH2\",\"POP\",\"POP\"] 返回值：1,2 说明： \"PSH1\":代表将1插入队列尾部 \"PSH2\":代表将2插入队列尾部 \"POP“:代表删除一个元素，先进先出=\u003e返回1 \"POP“:代表删除一个元素，先进先出=\u003e返回2 代码实现 import java.util.Stack; public class Solution { Stack\u003cInteger\u003e stack1 = new Stack\u003cInteger\u003e(); Stack\u003cInteger\u003e stack2 = new Stack\u003cInteger\u003e(); public void push(int node) { stack1.push(node); } public int pop() { if (stack2.size() \u003c= 0){ while (stack1.size() != 0){ stack2.push(stack1.pop()); } } return stack2.pop(); } } ","date":"2023-05-15","objectID":"/blog/20230515_code/:1:5","tags":["算法","Java"],"title":"剑指Offer-个人题解","uri":"/blog/20230515_code/"},{"categories":["Java"],"content":"旋转数组的最小数字 描述 旋转数组的最小数字 示例1 输入：[3,4,5,1,2] 返回值：1 示例2 输入：[3,100,200,3] 返回值：3 代码实现 import java.util.ArrayList; public class Solution { public int minNumberInRotateArray(int[] array) { if (array.length == 0) { return 0; } int min = array[0]; for (int e : array) { if (e \u003c min) { min = e; } } return min; } } ","date":"2023-05-15","objectID":"/blog/20230515_code/:1:6","tags":["算法","Java"],"title":"剑指Offer-个人题解","uri":"/blog/20230515_code/"},{"categories":["Java"],"content":"二进制中1的个数 描述 二进制中1的个数 示例1 输入：10 返回值：2 说明： 十进制中10的32位二进制表示为0000 0000 0000 0000 0000 0000 0000 1010，其中有两个1。 示例2 输入：-1 返回值：32 说明： 负数使用补码表示 ，-1的32位二进制表示为1111 1111 1111 1111 1111 1111 1111 1111，其中32个1 代码实现 import java.util.*; public class Solution { public int NumberOf1(int n) { Scanner in = new Scanner(System.in); int count = 0; for (int i = 0; i \u003c 32; i++) { if ((n \u0026 (1 \u003c\u003c i)) != 0) { count++; } } return count; } } ","date":"2023-05-15","objectID":"/blog/20230515_code/:1:7","tags":["算法","Java"],"title":"剑指Offer-个人题解","uri":"/blog/20230515_code/"},{"categories":["Java"],"content":"打印从1到最大的n位数 描述 打印从1到最大的n位数 示例1 输入：1 返回值：[1,2,3,4,5,6,7,8,9] 代码实现 import java.util.*; public class Solution { /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param n int整型 最大位数 * @return int整型一维数组 */ public int[] printNumbers (int n) { // write code here int length = (int)Math.pow(10, n); int []nums = new int[length-1]; for(int i=1;i\u003clength;i++){ nums[i-1]=i; } return nums; } } ","date":"2023-05-15","objectID":"/blog/20230515_code/:1:8","tags":["算法","Java"],"title":"剑指Offer-个人题解","uri":"/blog/20230515_code/"},{"categories":["Java"],"content":"删除链表的节点 描述 删除链表的节点 示例1 输入：{2,5,1,9},5 返回值：{2,1,9} 说明： 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 2 -\u003e 1 -\u003e 9 示例2 输入：{2,5,1,9},1 返回值：{2,5,9} 说明： 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 2 -\u003e 5 -\u003e 9 代码实现 import java.util.*; /* * public class ListNode { * int val; * ListNode next = null; * public ListNode(int val) { * this.val = val; * } * } */ public class Solution { /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param head ListNode类 * @param val int整型 * @return ListNode类 */ public ListNode deleteNode (ListNode head, int val) { // write code here if(head.val == val) { return head.next; } ListNode newHead = head; while(newHead.next != null) { if(newHead.next.val == val) { newHead.next = newHead.next.next; } newHead = newHead.next; } return head; } } ","date":"2023-05-15","objectID":"/blog/20230515_code/:1:9","tags":["算法","Java"],"title":"剑指Offer-个人题解","uri":"/blog/20230515_code/"},{"categories":["Java"],"content":"链表中倒数最后k个结点 描述 链表中倒数最后k个结点 示例1 输入：{1,2,3,4,5},2 返回值：{4,5} 说明：返回倒数第2个节点4，系统会打印后面所有的节点来比较。 示例2 输入：{2},8 返回值：{} 代码实现 import java.util.*; /* * public class ListNode { * int val; * ListNode next = null; * public ListNode(int val) { * this.val = val; * } * } */ public class Solution { /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param pHead ListNode类 * @param k int整型 * @return ListNode类 */ public ListNode FindKthToTail (ListNode pHead, int k) { // write code here // 快慢指针思想 ListNode fast = pHead; ListNode slow = pHead; int step=0; if (pHead == null) { return null; } // 快指针先走k步 while (fast != null \u0026\u0026 step != k) { fast = fast.next; step++; } if (step \u003c k) { return null; } // 慢指针与快指针同步 while (fast != null) { fast = fast.next; slow = slow.next; } return slow; } } ","date":"2023-05-15","objectID":"/blog/20230515_code/:1:10","tags":["算法","Java"],"title":"剑指Offer-个人题解","uri":"/blog/20230515_code/"},{"categories":["Java"],"content":"反转链表 描述 反转链表 示例1 输入：{1,2,3} 返回值：{3,2,1} 示例2 输入：{} 返回值：{} 说明：空链表则输出空 代码实现 /* public class ListNode { int val; ListNode next = null; ListNode(int val) { this.val = val; } }*/ public class Solution { public ListNode ReverseList(ListNode head) { ListNode pre = null; ListNode nextOne = null; while (head != null) { nextOne = head.next; head.next = pre; pre = head; head = nextOne; } return pre; } } ","date":"2023-05-15","objectID":"/blog/20230515_code/:1:11","tags":["算法","Java"],"title":"剑指Offer-个人题解","uri":"/blog/20230515_code/"},{"categories":["Java"],"content":"合并两个排序的链表 描述 合并两个排序的链表 示例1 输入：{1,3,5},{2,4,6} 返回值：{1,2,3,4,5,6} 示例2 输入：{},{} 返回值：{} 示例3 输入：{-1,2,4},{1,3,4} 返回值：{-1,1,2,3,4,4} 代码实现 /* public class ListNode { int val; ListNode next = null; ListNode(int val) { this.val = val; } }*/ public class Solution { public ListNode Merge(ListNode list1, ListNode list2) { if (list1 == null \u0026\u0026 list2 == null) { return null; } ListNode head = new ListNode(-1); ListNode pre = head; while (list1 != null \u0026\u0026 list2 != null) { if (list1.val \u003c list2.val) { pre.next = list1; list1 = list1.next; } else if (list1.val \u003e list2.val) { pre.next = list2; list2 = list2.next; } else { pre.next = list1; list1 = list1.next; pre=pre.next; pre.next = list2; list2 = list2.next; } pre=pre.next; } pre.next = list1 == null ? list2 : list1; return head.next; } } ","date":"2023-05-15","objectID":"/blog/20230515_code/:1:12","tags":["算法","Java"],"title":"剑指Offer-个人题解","uri":"/blog/20230515_code/"},{"categories":["Java"],"content":"二叉树的镜像 描述 二叉树的镜像 示例1 输入：{8,6,10,5,7,9,11} 返回值：{8,10,6,11,9,7,5} 说明：如题面所示 示例2 输入：{} 返回值：{} 代码实现 import java.util.*; /* * public class TreeNode { * int val = 0; * TreeNode left = null; * TreeNode right = null; * public TreeNode(int val) { * this.val = val; * } * } */ public class Solution { /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param pRoot TreeNode类 * @return TreeNode类 */ public TreeNode Mirror (TreeNode pRoot) { // write code here if (pRoot == null) { return null; } TreeNode tmp = pRoot.left; pRoot.left = pRoot.right ; pRoot.right = tmp; Mirror(pRoot.left); Mirror(pRoot.right); return pRoot; } } ","date":"2023-05-15","objectID":"/blog/20230515_code/:1:13","tags":["算法","Java"],"title":"剑指Offer-个人题解","uri":"/blog/20230515_code/"},{"categories":["Java"],"content":"对称的二叉树 描述 对称的二叉树 示例1 输入：{1,2,2,3,4,4,3} 返回值：true 示例2 输入：{8,6,9,5,7,7,5} 返回值：false 代码实现 /* public class TreeNode { int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) { this.val = val; } } */ import java.util.*; public class Solution { boolean isSymmetrical(TreeNode pRoot) { if (pRoot == null) { return true; } Queue\u003cTreeNode\u003e left = new LinkedList(); Queue\u003cTreeNode\u003e right = new LinkedList(); left.offer(pRoot.left); right.offer(pRoot.right); while (!left.isEmpty() \u0026\u0026 !right.isEmpty()) { TreeNode tn_left = left.poll(); TreeNode tn_right = right.poll(); if (tn_left == null \u0026\u0026 tn_right == null) { continue; } if (tn_left == null || tn_right == null || tn_left.val != tn_right.val) { return false; } left.offer(tn_left.left); left.offer(tn_left.right); right.offer(tn_right.right); right.offer(tn_right.left); } return true ; } } ","date":"2023-05-15","objectID":"/blog/20230515_code/:1:14","tags":["算法","Java"],"title":"剑指Offer-个人题解","uri":"/blog/20230515_code/"},{"categories":["Java"],"content":"顺时针打印矩阵 描述 顺时针打印矩阵 示例1 输入：[[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]] 返回值：[1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10] 示例2 输入：[[1,2,3,1],[4,5,6,1],[4,5,6,1]] 返回值：[1,2,3,1,1,1,6,5,4,4,5,6] 代码实现 import java.util.*; public class Solution { public ArrayList\u003cInteger\u003e printMatrix(int [][] matrix) { ArrayList\u003cInteger\u003e nums = new ArrayList(); if (matrix == null || matrix.length == 0 || matrix[0].length == 0) { return nums; } int up = 0, down = matrix.length - 1, left = 0, right = matrix[0].length - 1; while (true) { // 往右走 for (int index = left; index \u003c= right; index++) { nums.add(matrix[up][index]); } up++; if (up \u003e down) { break; } // 往下走 for (int index = up; index \u003c= down; index++) { nums.add(matrix[index][right]); } right--; if (left \u003e right) { break; } // 往左走 for (int index = right; index \u003e= left; index--) { nums.add(matrix[down][index]); } down--; if (up \u003e down) { break; } // 往上走 for (int index = down; index \u003e= up; index--) { nums.add(matrix[index][left]); } left++; if (left \u003e right) { break; } } return nums; } } ","date":"2023-05-15","objectID":"/blog/20230515_code/:1:15","tags":["算法","Java"],"title":"剑指Offer-个人题解","uri":"/blog/20230515_code/"},{"categories":["Java"],"content":"包含min函数的栈 描述 包含min函数的栈 示例1 输入：[\"PSH-1\",\"PSH2\",\"MIN\",\"TOP\",\"POP\",\"PSH1\",\"TOP\",\"MIN\"] 返回值：-1,2,1,-1 示例2 输入：\" \" 返回值：\"%20\" 代码实现 import java.util.Stack; public class Solution { Stack\u003cInteger\u003enum = new Stack\u003c\u003e(); Stack\u003cInteger\u003emin = new Stack\u003c\u003e(); public void push(int node) { num.push(node); if (min.isEmpty() || min.peek() \u003e node) { min.push(node); } else { min.push(min.peek()); } } public void pop() { num.pop(); min.pop(); } public int top() { int top_val = num.peek(); return top_val; } public int min() { return min.peek(); } } ","date":"2023-05-15","objectID":"/blog/20230515_code/:1:16","tags":["算法","Java"],"title":"剑指Offer-个人题解","uri":"/blog/20230515_code/"},{"categories":["Java"],"content":"从上往下打印二叉树 描述 从上往下打印二叉树 示例1 输入：{8,6,10,#,#,2,1} 返回值：[8,6,10,2,1] 示例2 输入：{5,4,#,3,#,2,#,1} 返回值：[5,4,3,2,1] 代码实现 import java.util.*; /** public class TreeNode { int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) { this.val = val; } } */ public class Solution { ArrayList\u003cInteger\u003e num = new ArrayList(); Queue\u003cTreeNode\u003enode = new LinkedList(); public ArrayList\u003cInteger\u003e PrintFromTopToBottom(TreeNode root) { node.add(root); while (!node.isEmpty()) { TreeNode tmp = node.poll(); if (tmp != null) { num.add(tmp.val); node.add(tmp.left); node.add(tmp.right); } } return num; } } ","date":"2023-05-15","objectID":"/blog/20230515_code/:1:17","tags":["算法","Java"],"title":"剑指Offer-个人题解","uri":"/blog/20230515_code/"},{"categories":["Java"],"content":"数组中出现次数超过一半的数字 描述 数组中出现次数超过一半的数字 示例1 输入： [1,2,3,2,2,2,5,4,2] 返回值：2 示例2 输入：[3,3,3,3,2,2,2] 返回值：3 示例3 输入：[1] 返回值：1 代码实现 public class Solution { public int MoreThanHalfNum_Solution(int [] array) { int []count = new int[10000]; if(array.length==1){ return array[0]; } for (int i = 0; i \u003c array.length; i++) { count[array[i]]++; } int mid = array.length \u003e\u003e 1; int target = 0; for (int i = 0; i \u003c count.length; i++) { if (count[i] \u003e mid) { target = i; break; } } return target; } } ","date":"2023-05-15","objectID":"/blog/20230515_code/:1:18","tags":["算法","Java"],"title":"剑指Offer-个人题解","uri":"/blog/20230515_code/"},{"categories":["Java"],"content":"连续子数组的最大和 描述 连续子数组的最大和 示例1 输入：[1,-2,3,10,-4,7,2,-5] 返回值：18 说明：经分析可知，输入数组的子数组[3,10,-4,7,2]可以求得最大和为18 示例2 输入：[2] 返回值：2 示例3 输入：[-10] 返回值：-10 代码实现 public class Solution { public int FindGreatestSumOfSubArray(int[] array) { // 未优化 // int []dp = new int[array.length]; // int max = array[0]; // dp[0] = array[0]; // for (int i = 1; i \u003c array.length; i++) { // dp[i] = Math.max(array[i], dp[i - 1] + array[i]); // max = Math.max(max, dp[i]); // } // return max; // 优化空间复杂度 int sum=array[0]; int max=array[0]; for(int i=1;i\u003carray.length;i++){ sum=Math.max(sum+array[i],array[i]); max=Math.max(max,sum); } return max; } } 未完待续··· ","date":"2023-05-15","objectID":"/blog/20230515_code/:1:19","tags":["算法","Java"],"title":"剑指Offer-个人题解","uri":"/blog/20230515_code/"},{"categories":["Redis"],"content":"Redis集群","date":"2023-05-03","objectID":"/blog/20230503_colony/","tags":["Redis","Java","NoSQL"],"title":"Redis集群","uri":"/blog/20230503_colony/"},{"categories":["Redis"],"content":"Redis集群搭建 Redis 是一个高性能的开源键值存储数据库，它支持多种数据结构，如字符串、哈希、列表、集合和有序集合。它的出色性能和易于使用的特性，使得 Redis 成为了许多应用程序的首选数据存储方案。然而，随着业务的增长，单节点 Redis 可能会面临诸如存储容量、读写性能等方面的限制。为了解决这些问题，Redis 提供了集群模式，使得用户可以通过水平扩展的方式来横向扩展 Redis 的性能和存储能力。在本此内容中，我 将介绍Redis 集群的几种部署方法，帮助读者了解如何使用 Redis 集群来满足业务需求，提高应用程序的性能和可扩展性。 ","date":"2023-05-03","objectID":"/blog/20230503_colony/:0:0","tags":["Redis","Java","NoSQL"],"title":"Redis集群","uri":"/blog/20230503_colony/"},{"categories":["Redis"],"content":"Redis主从集群 ","date":"2023-05-03","objectID":"/blog/20230503_colony/:1:0","tags":["Redis","Java","NoSQL"],"title":"Redis集群","uri":"/blog/20230503_colony/"},{"categories":["Redis"],"content":"集群结构 我们搭建的主从集群结构如图： 主从集群结构 共包含三个节点，一个主节点，两个从节点。 这里我们会在同一台虚拟机中开启3个redis实例，模拟主从集群，信息如下： IP PORT 角色 192.168.150.101 7001 master 192.168.150.101 7002 slave 192.168.150.101 7003 slave ","date":"2023-05-03","objectID":"/blog/20230503_colony/:1:1","tags":["Redis","Java","NoSQL"],"title":"Redis集群","uri":"/blog/20230503_colony/"},{"categories":["Redis"],"content":"准备实例和配置 要在同一台虚拟机开启3个实例，必须准备三份不同的配置文件和目录，配置文件所在目录也就是工作目录。 1）创建目录 我们创建三个文件夹，名字分别叫7001、7002、7003： # 进入/tmp目录 cd /tmp # 创建目录 mkdir 7001 7002 7003 如图： 2）恢复原始配置 修改redis-6.2.4/redis.conf文件，将其中的持久化模式改为默认的RDB模式，AOF保持关闭状态。 # 开启RDB # save \"\" save 3600 1 save 300 100 save 60 10000 # 关闭AOF appendonly no 3）拷贝配置文件到每个实例目录 然后将redis-6.2.4/redis.conf文件拷贝到三个目录中（在/tmp目录执行下列命令）： # 方式一：逐个拷贝 cp redis-6.2.4/redis.conf 7001 cp redis-6.2.4/redis.conf 7002 cp redis-6.2.4/redis.conf 7003 # 方式二：管道组合命令，一键拷贝 echo 7001 7002 7003 | xargs -t -n 1 cp redis-6.2.4/redis.conf 4）修改每个实例的端口、工作目录 修改每个文件夹内的配置文件，将端口分别修改为7001、7002、7003，将rdb文件保存位置都修改为自己所在目录（在/tmp目录执行下列命令）： sed -i -e 's/6379/7001/g' -e 's/dir .\\//dir \\/tmp\\/7001\\//g' 7001/redis.conf sed -i -e 's/6379/7002/g' -e 's/dir .\\//dir \\/tmp\\/7002\\//g' 7002/redis.conf sed -i -e 's/6379/7003/g' -e 's/dir .\\//dir \\/tmp\\/7003\\//g' 7003/redis.conf 5）修改每个实例的声明IP 虚拟机本身有多个IP，为了避免将来混乱，我们需要在redis.conf文件中指定每一个实例的绑定ip信息，格式如下： # redis实例的声明 IP replica-announce-ip 192.168.150.101 每个目录都要改，我们一键完成修改（在/tmp目录执行下列命令）： # 逐一执行 sed -i '1a replica-announce-ip 192.168.150.101' 7001/redis.conf sed -i '1a replica-announce-ip 192.168.150.101' 7002/redis.conf sed -i '1a replica-announce-ip 192.168.150.101' 7003/redis.conf # 或者一键修改 printf '%s\\n' 7001 7002 7003 | xargs -I{} -t sed -i '1a replica-announce-ip 192.168.150.101' {}/redis.conf ","date":"2023-05-03","objectID":"/blog/20230503_colony/:1:2","tags":["Redis","Java","NoSQL"],"title":"Redis集群","uri":"/blog/20230503_colony/"},{"categories":["Redis"],"content":"启动 为了方便查看日志，我们打开3个ssh窗口，分别启动3个redis实例，启动命令： # 第1个 redis-server 7001/redis.conf # 第2个 redis-server 7002/redis.conf # 第3个 redis-server 7003/redis.conf 启动后： redis集群启动 如果要一键停止，可以运行下面命令： printf '%s\\n' 7001 7002 7003 | xargs -I{} -t redis-cli -p {} shutdown ","date":"2023-05-03","objectID":"/blog/20230503_colony/:1:3","tags":["Redis","Java","NoSQL"],"title":"Redis集群","uri":"/blog/20230503_colony/"},{"categories":["Redis"],"content":"开启主从关系 现在三个实例还没有任何关系，要配置主从可以使用replicaof 或者slaveof（5.0以前）命令。 有临时和永久两种模式： 修改配置文件（永久生效） 在redis.conf中添加一行配置：slaveof \u003cmasterip\u003e \u003cmasterport\u003e 使用redis-cli客户端连接到redis服务，执行slaveof命令（重启后失效）： slaveof \u003cmasterip\u003e \u003cmasterport\u003e 注意：在5.0以后新增命令replicaof，与salveof效果一致。 这里我们为了演示方便，使用方式二。 通过redis-cli命令连接7002，执行下面命令： # 连接 7002 redis-cli -p 7002 # 执行slaveof slaveof 192.168.150.101 7001 通过redis-cli命令连接7003，执行下面命令： # 连接 7003 redis-cli -p 7003 # 执行slaveof slaveof 192.168.150.101 7001 然后连接 7001节点，查看集群状态： # 连接 7001 redis-cli -p 7001 # 查看状态 info replication 结果： 查看redis集群状态 ","date":"2023-05-03","objectID":"/blog/20230503_colony/:1:4","tags":["Redis","Java","NoSQL"],"title":"Redis集群","uri":"/blog/20230503_colony/"},{"categories":["Redis"],"content":"测试 执行下列操作以测试： 利用redis-cli连接7001，执行set num 123 利用redis-cli连接7002，执行get num，再执行set num 666 利用redis-cli连接7003，执行get num，再执行set num 888 可以发现，只有在7001这个master节点上可以执行写操作，7002和7003这两个slave节点只能执行读操作。 ","date":"2023-05-03","objectID":"/blog/20230503_colony/:1:5","tags":["Redis","Java","NoSQL"],"title":"Redis集群","uri":"/blog/20230503_colony/"},{"categories":["Redis"],"content":"搭建哨兵集群 ","date":"2023-05-03","objectID":"/blog/20230503_colony/:2:0","tags":["Redis","Java","NoSQL"],"title":"Redis集群","uri":"/blog/20230503_colony/"},{"categories":["Redis"],"content":"集群结构 这里我们搭建一个三节点形成的Sentinel集群，来监管之前的Redis主从集群。如图： redis哨兵集群结构 三个sentinel实例信息如下： 节点 IP PORT s1 192.168.150.101 27001 s2 192.168.150.101 27002 s3 192.168.150.101 27003 ","date":"2023-05-03","objectID":"/blog/20230503_colony/:2:1","tags":["Redis","Java","NoSQL"],"title":"Redis集群","uri":"/blog/20230503_colony/"},{"categories":["Redis"],"content":"准备实例和配置 要在同一台虚拟机开启3个实例，必须准备三份不同的配置文件和目录，配置文件所在目录也就是工作目录。 我们创建三个文件夹，名字分别叫s1、s2、s3： # 进入/tmp目录 cd /tmp # 创建目录 mkdir s1 s2 s3 如图： 准备实例 然后我们在s1目录创建一个sentinel.conf文件，添加下面的内容： port 27001 sentinel announce-ip 192.168.150.101 sentinel monitor mymaster 192.168.150.101 7001 2 sentinel down-after-milliseconds mymaster 5000 sentinel failover-timeout mymaster 60000 dir \"/tmp/s1\" 解读： port 27001：是当前sentinel实例的端口 sentinel monitor mymaster 192.168.150.101 7001 2：指定主节点信息 mymaster：主节点名称，自定义，任意写 192.168.150.101 7001：主节点的ip和端口 2：选举master时的quorum值 然后将s1/sentinel.conf文件拷贝到s2、s3两个目录中（在/tmp目录执行下列命令）： # 方式一：逐个拷贝 cp s1/sentinel.conf s2 cp s1/sentinel.conf s3 # 方式二：管道组合命令，一键拷贝 echo s2 s3 | xargs -t -n 1 cp s1/sentinel.conf 修改s2、s3两个文件夹内的配置文件，将端口分别修改为27002、27003： sed -i -e 's/27001/27002/g' -e 's/s1/s2/g' s2/sentinel.conf sed -i -e 's/27001/27003/g' -e 's/s1/s3/g' s3/sentinel.conf ","date":"2023-05-03","objectID":"/blog/20230503_colony/:2:2","tags":["Redis","Java","NoSQL"],"title":"Redis集群","uri":"/blog/20230503_colony/"},{"categories":["Redis"],"content":"启动 为了方便查看日志，我们打开3个ssh窗口，分别启动3个redis实例，启动命令： # 第1个 redis-sentinel s1/sentinel.conf # 第2个 redis-sentinel s2/sentinel.conf # 第3个 redis-sentinel s3/sentinel.conf 启动后： 哨兵集群启动 ","date":"2023-05-03","objectID":"/blog/20230503_colony/:2:3","tags":["Redis","Java","NoSQL"],"title":"Redis集群","uri":"/blog/20230503_colony/"},{"categories":["Redis"],"content":"测试 尝试让master节点7001宕机，查看sentinel日志： sentinel日志 查看7003的日志： 7003的日志 查看7002的日志： 7002的日志 ","date":"2023-05-03","objectID":"/blog/20230503_colony/:2:4","tags":["Redis","Java","NoSQL"],"title":"Redis集群","uri":"/blog/20230503_colony/"},{"categories":["Redis"],"content":"搭建分片集群 ","date":"2023-05-03","objectID":"/blog/20230503_colony/:3:0","tags":["Redis","Java","NoSQL"],"title":"Redis集群","uri":"/blog/20230503_colony/"},{"categories":["Redis"],"content":"集群结构 分片集群需要的节点数量较多，这里我们搭建一个最小的分片集群，包含3个master节点，每个master包含一个slave节点，结构如下： redis分片集群结构 这里我们会在同一台虚拟机中开启6个redis实例，模拟分片集群，信息如下： IP PORT 角色 192.168.150.101 7001 master 192.168.150.101 7002 master 192.168.150.101 7003 master 192.168.150.101 8001 slave 192.168.150.101 8002 slave 192.168.150.101 8003 slave ","date":"2023-05-03","objectID":"/blog/20230503_colony/:3:1","tags":["Redis","Java","NoSQL"],"title":"Redis集群","uri":"/blog/20230503_colony/"},{"categories":["Redis"],"content":"准备实例和配置 删除之前的7001、7002、7003这几个目录，重新创建出7001、7002、7003、8001、8002、8003目录： # 进入/tmp目录 cd /tmp # 删除旧的，避免配置干扰 rm -rf 7001 7002 7003 # 创建目录 mkdir 7001 7002 7003 8001 8002 8003 在/tmp下准备一个新的redis.conf文件，内容如下： port 6379 # 开启集群功能 cluster-enabled yes # 集群的配置文件名称，不需要我们创建，由redis自己维护 cluster-config-file /tmp/6379/nodes.conf # 节点心跳失败的超时时间 cluster-node-timeout 5000 # 持久化文件存放目录 dir /tmp/6379 # 绑定地址 bind 0.0.0.0 # 让redis后台运行 daemonize yes # 注册的实例ip replica-announce-ip 192.168.150.101 # 保护模式 protected-mode no # 数据库数量 databases 1 # 日志 logfile /tmp/6379/run.log 将这个文件拷贝到每个目录下： # 进入/tmp目录 cd /tmp # 执行拷贝 echo 7001 7002 7003 8001 8002 8003 | xargs -t -n 1 cp redis.conf 修改每个目录下的redis.conf，将其中的6379修改为与所在目录一致： # 进入/tmp目录 cd /tmp # 修改配置文件 printf '%s\\n' 7001 7002 7003 8001 8002 8003 | xargs -I{} -t sed -i 's/6379/{}/g' {}/redis.conf ","date":"2023-05-03","objectID":"/blog/20230503_colony/:3:2","tags":["Redis","Java","NoSQL"],"title":"Redis集群","uri":"/blog/20230503_colony/"},{"categories":["Redis"],"content":"启动 因为已经配置了后台启动模式，所以可以直接启动服务： # 进入/tmp目录 cd /tmp # 一键启动所有服务 printf '%s\\n' 7001 7002 7003 8001 8002 8003 | xargs -I{} -t redis-server {}/redis.conf 通过ps查看状态： ps -ef | grep redis 发现服务都已经正常启动： redis服务状态 如果要关闭所有进程，可以执行命令： ps -ef | grep redis | awk '{print $2}' | xargs kill 或者（推荐这种方式）： printf '%s\\n' 7001 7002 7003 8001 8002 8003 | xargs -I{} -t redis-cli -p {} shutdown ","date":"2023-05-03","objectID":"/blog/20230503_colony/:3:3","tags":["Redis","Java","NoSQL"],"title":"Redis集群","uri":"/blog/20230503_colony/"},{"categories":["Redis"],"content":"创建集群 虽然服务启动了，但是目前每个服务之间都是独立的，没有任何关联。 我们需要执行命令来创建集群，在Redis5.0之前创建集群比较麻烦，5.0之后集群管理命令都集成到了redis-cli中。 1）Redis5.0之前 Redis5.0之前集群命令都是用redis安装包下的src/redis-trib.rb来实现的。因为redis-trib.rb是有ruby语言编写的所以需要安装ruby环境。 # 安装依赖 yum -y install zlib ruby rubygems gem install redis 然后通过命令来管理集群： # 进入redis的src目录 cd /tmp/redis-6.2.4/src # 创建集群 ./redis-trib.rb create --replicas 1 192.168.150.101:7001 192.168.150.101:7002 192.168.150.101:7003 192.168.150.101:8001 192.168.150.101:8002 192.168.150.101:8003 2）Redis5.0以后 我们使用的是Redis6.2.4版本，集群管理以及集成到了redis-cli中，格式如下： redis-cli --cluster create --cluster-replicas 1 192.168.150.101:7001 192.168.150.101:7002 192.168.150.101:7003 192.168.150.101:8001 192.168.150.101:8002 192.168.150.101:8003 命令说明： redis-cli --cluster或者./redis-trib.rb：代表集群操作命令 create：代表是创建集群 --replicas 1或者--cluster-replicas 1 ：指定集群中每个master的副本个数为1，此时节点总数 ÷ (replicas + 1) 得到的就是master的数量。因此节点列表中的前n个就是master，其它节点都是slave节点，随机分配到不同master 运行后的样子： 服务运行详情 这里输入yes，则集群开始创建： 构建状态 通过命令可以查看集群状态： redis-cli -p 7001 cluster nodes 集群状态 ","date":"2023-05-03","objectID":"/blog/20230503_colony/:3:4","tags":["Redis","Java","NoSQL"],"title":"Redis集群","uri":"/blog/20230503_colony/"},{"categories":["Redis"],"content":"测试 尝试连接7001节点，存储一个数据： # 连接 redis-cli -p 7001 # 存储数据 set num 123 # 读取数据 get num # 再次存储 set a 1 结果悲剧了： 连接7001节点 集群操作时，需要给redis-cli加上-c参数才可以： redis-cli -c -p 7001 这次可以了： 连接重试 ","date":"2023-05-03","objectID":"/blog/20230503_colony/:3:5","tags":["Redis","Java","NoSQL"],"title":"Redis集群","uri":"/blog/20230503_colony/"},{"categories":["Technology"],"content":"设计模式讲解","date":"2022-12-05","objectID":"/blog/20221205_designpatterns/","tags":["Java","coding","principle"],"title":"设计模式","uri":"/blog/20221205_designpatterns/"},{"categories":["Technology"],"content":"浅谈设计模式 ","date":"2022-12-05","objectID":"/blog/20221205_designpatterns/:0:0","tags":["Java","coding","principle"],"title":"设计模式","uri":"/blog/20221205_designpatterns/"},{"categories":["Technology"],"content":"前言 编写软件过程中，程序员面临着来自耦合性，内聚性以及可维护性，可扩展性，重用性，灵活性 等多方面的挑战，设计模式是为了让程序(软件)，具有更好： 代码重用性（即：相同的代码，不用多次编写） 可读性（即：编程规范性，便于其他程序员的阅读与理解） 可扩展性（即：当需要增加新的功能时，非常方便，称为可维护性） 可靠性（即：当我们增加新的功能后，对原来的功能没有影响） 使程序呈现高内聚，低耦合的特性 设计模式包含了面向对象的精髓：“懂了设计模式，你就懂了面向对象分析和设计（OOA/D）的精要”。 Scott Mayers 在其巨著《Effective C++》就曾经说过：C++老手和 C++新手的区别就是前者手背上有很多伤疤。 ","date":"2022-12-05","objectID":"/blog/20221205_designpatterns/:1:0","tags":["Java","coding","principle"],"title":"设计模式","uri":"/blog/20221205_designpatterns/"},{"categories":["Technology"],"content":"设计模式七大原则 设计模式原则，其实就是程序员在编程时，应当遵守的原则，也是各种设计模式的基础（即：设计模式为什么这样设计的依据） 设计模式常用的七大原则 单一职责原则 接口隔离原则 依赖倒转（倒置）原则 里氏替换原则 开闭原则 迪米特法则 合成服用原则 ","date":"2022-12-05","objectID":"/blog/20221205_designpatterns/:2:0","tags":["Java","coding","principle"],"title":"设计模式","uri":"/blog/20221205_designpatterns/"},{"categories":["Technology"],"content":"单一职责原则 介绍 对类来说，一个类应该只负责一项职责。如类A负责两个不同的职责：职责1，职责2。当职责1需求变更而改变A时，可能造成职责2执行错误，所以需要将类A的粒度分解为A1，A2。类图如下所示 单一职责原则 单一职责原则注意事项和细节 单一职责原则 降低类的复杂度，一个类只负责一项职责。 提高类的可读性，可维护性。 降低变更引起的风险。 通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中的方法数量足够少，可以在方法级别保持单一职责原则。 ","date":"2022-12-05","objectID":"/blog/20221205_designpatterns/:2:1","tags":["Java","coding","principle"],"title":"设计模式","uri":"/blog/20221205_designpatterns/"},{"categories":["Technology"],"content":"接口隔离原则 介绍 客户端不应该依赖他不需要的接口，即对类对另一个类的依赖应该建立在最小的接口上。 接口隔离原则-未拆分 类A通过接口Interface1依赖类B，类C通过Interface1依赖类D，如果接口Interface1对于类A和类C来说不是最小接口，那么类B和类D必须去实现他们不需要的方法。 隔离原则应当如下处理： 将接口Interface1拆分成为几个独立的接口（这里我们拆分成为3个接口），类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。 使用接口隔离原则改进 步骤 类A通过接口Interface1依赖类B，类C通过接口Interface1依赖类D，如果接口Interface1对于类A和类C来说不是最小接口，那么类B和类D必须去实现他们不需要的方法 将接口Interface1拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则 接口Interface1中出现的方法，根据实际情况拆分为三个接口 拆分实现如下： 接口隔离原则-拆分 public class Segregation { public static void main(String[] args) { A a = new A(); a.depend1(new B()); // A类通过接口去依赖B类 a.depend2(new B()); a.depend3(new B()); C c = new C(); c.depend1(new D()); // C类通过接口去依赖D类 c.depend4(new D()); c.depend5(new D()); } } interface Interface1 { void operation1(); } interface Interface2 { void operation2(); void operation3(); } interface Interface3 { void operation4(); void operation5(); } class D implements Interface1, Interface3 { @Override public void operation1() { System.out.println(\"D 实现了 operation1\"); } @Override public void operation4() { System.out.println(\"D 实现了 operation4\"); } @Override public void operation5() { System.out.println(\"D 实现了 operation5\"); } } class B implements Interface1, Interface2 { @Override public void operation1() { System.out.println(\"B 实现了 operation1\"); } @Override public void operation2() { System.out.println(\"B 实现了 operation2\"); } @Override public void operation3() { System.out.println(\"B 实现了 operation3\"); } } // A类通过接口Interface依赖使用B类，用到了1，2，3方法 class A { public void depend1(Interface1 interface1) { interface1.operation1(); } public void depend2(Interface2 interface2) { interface2.operation2(); } public void depend3(Interface2 interface2) { interface2.operation3(); } } // C类通过接口Interface依赖D类，用到了1，4，5方法 class C { public void depend1(Interface1 interface1) { interface1.operation1(); } public void depend4(Interface3 interface3) { interface3.operation4(); } public void depend5(Interface3 interface3) { interface3.operation5(); } } ","date":"2022-12-05","objectID":"/blog/20221205_designpatterns/:2:2","tags":["Java","coding","principle"],"title":"设计模式","uri":"/blog/20221205_designpatterns/"},{"categories":["Technology"],"content":"依赖倒转原则 介绍 依赖倒转原则(Dependence Inversion Principle)是指： 高层模块不应该依赖底层模块，二者都应该依赖其抽象 抽象不应该依赖细节，细节应该依赖抽象 依赖倒转(倒置)的中心思想是面向接口编程 依赖倒转原则是基于这样的设计原理：相较于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的框架比以细节为基础的框架要稳定的多。在Java中，抽象指的是借口或抽象类，细节就是具体的实现类 使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成 依赖倒转 依赖关系传递的三种方式 接口传递 构造方法传递 setter方式传递 public class DependencyPass { public static void main(String[] args) { // TODO Auto-generated method stub } } // 方式1： 通过接口传递实现依赖 // 开关的接口 interface IOpenAndClose { public void open(ITV tv); //抽象方法,接收接口 } interface ITV { //ITV接口 public void play(); } // 实现接口 class OpenAndClose implements IOpenAndClose { public void open(ITV tv) { tv.play(); } } // 方式2: 通过构造方法依赖传递 interface IOpenAndClose { public void open(); //抽象方法 } interface ITV { //ITV接口 public void play(); } class OpenAndClose implements IOpenAndClose { public ITV tv; public OpenAndClose(ITV tv) { this.tv = tv; } public void open() { this.tv.play(); } } // 方式3 , 通过setter方法传递 interface IOpenAndClose { public void open(); // 抽象方法 public void setTv(ITV tv); } interface ITV { // ITV接口 public void play(); } class OpenAndClose implements IOpenAndClose { private ITV tv; public void setTv(ITV tv) { this.tv = tv; } public void open() { this.tv.play(); } } 依赖倒转原则的注意事项和细节 依赖倒转原则 底层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好 变量的声明类型尽量是抽象类或接口，这样我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化 继承时遵循里氏替换原则 ","date":"2022-12-05","objectID":"/blog/20221205_designpatterns/:2:3","tags":["Java","coding","principle"],"title":"设计模式","uri":"/blog/20221205_designpatterns/"},{"categories":["Technology"],"content":"里氏替换原则 OO中的继承性的思考和说明 继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然他不强制要求所有的子类必须遵循这些契约，但是如果自类对这些已经实现的方法随意修改，就会对整个继承体系造成破坏 继承在给程序设计带来便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加对象的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障 介绍 里氏替换原则(Liskov Substitution Principle)在1988年，由麻省理工学院里一位姓里的女士提出的 如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都替换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。换句话说，所有的引用基类的地方必须能透明地使用其子类的对象 在使用继承，遵循里氏替换原则，在子类中尽量不要重写父类的方法 里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过耦合、组合、依赖来解决问题 里氏替换 里氏替换原则通用做法：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖、聚合、组合等关系替代。 ","date":"2022-12-05","objectID":"/blog/20221205_designpatterns/:2:4","tags":["Java","coding","principle"],"title":"设计模式","uri":"/blog/20221205_designpatterns/"},{"categories":["Technology"],"content":"开闭原则 介绍 开闭原则(Open Closed Principle)是编程中最基础、最重要的设计原则 一个软件实体如类，模块和函数应该对扩展开放(对提供方)，对修改关闭(对使用方)。用抽象构建框架，用实现扩展细节 当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化 编程中遵循其他原则，以及使用设计模式的目的就是遵循开闭原则 类图演示 public class Ocp { public static void main(String[] args) { //使用看看存在的问题 GraphicEditor graphicEditor = new GraphicEditor(); graphicEditor.drawShape(new Rectangle()); graphicEditor.drawShape(new Circle()); graphicEditor.drawShape(new Triangle()); } } //这是一个用于绘图的类 [使用方] class GraphicEditor { //接收Shape对象，然后根据type，来绘制不同的图形 public void drawShape(Shape s) { if (s.m_type == 1) drawRectangle(s); else if (s.m_type == 2) drawCircle(s); else if (s.m_type == 3) drawTriangle(s); } //绘制矩形 public void drawRectangle(Shape r) { System.out.println(\" 绘制矩形 \"); } //绘制圆形 public void drawCircle(Shape r) { System.out.println(\" 绘制圆形 \"); } //绘制三角形 public void drawTriangle(Shape r) { System.out.println(\" 绘制三角形 \"); } } //Shape类，基类 class Shape { int m_type; } class Rectangle extends Shape { Rectangle() { super.m_type = 1; } } class Circle extends Shape { Circle() { super.m_type = 2; } } //新增画三角形 class Triangle extends Shape { Triangle() { super.m_type = 3; } } 演示方式优缺点 代码易于理解，操作简单 缺点是违反了设计模式的OCP原则，即对扩展开放（提供方），对修改关闭（适用方）。即当我们给类增加新功能的时候，尽量不修改代码，或者尽可能少修改代码 比如我们这时要新增加一个图形种类三角形，我们需要修改较多地方 优化分析 把创建Shape类做成抽象类，并提供一个抽象的draw方法，让子类去实现即可，这样我们有新的图形种类时，只需要让新的图形类继承Shape，并实现draw方法即可。（使用方的代码就不需要修改，即可满足开闭原则） public class Ocp { public static void main(String[] args) { //使用看看存在的问题 GraphicEditor graphicEditor = new GraphicEditor(); graphicEditor.drawShape(new Rectangle()); graphicEditor.drawShape(new Circle()); graphicEditor.drawShape(new Triangle()); graphicEditor.drawShape(new OtherGraphic()); } } //这是一个用于绘图的类 [使用方] class GraphicEditor { //接收Shape对象，调用draw方法 public void drawShape(Shape s) { s.draw(); } } //Shape类，基类 abstract class Shape { int m_type; public abstract void draw();//抽象方法 } class Rectangle extends Shape { Rectangle() { super.m_type = 1; } @Override public void draw() { // TODO Auto-generated method stub System.out.println(\" 绘制矩形 \"); } } class Circle extends Shape { Circle() { super.m_type = 2; } @Override public void draw() { // TODO Auto-generated method stub System.out.println(\" 绘制圆形 \"); } } //新增画三角形 class Triangle extends Shape { Triangle() { super.m_type = 3; } @Override public void draw() { // TODO Auto-generated method stub System.out.println(\" 绘制三角形 \"); } } //新增一个图形 class OtherGraphic extends Shape { OtherGraphic() { super.m_type = 4; } @Override public void draw() { // TODO Auto-generated method stub System.out.println(\" 绘制其它图形 \"); } } ","date":"2022-12-05","objectID":"/blog/20221205_designpatterns/:2:5","tags":["Java","coding","principle"],"title":"设计模式","uri":"/blog/20221205_designpatterns/"},{"categories":["Technology"],"content":"迪米特法则 介绍 一个对象应该对其他对象保持最少的了解 类和类关于越密切，耦合度就越大 迪米特法则(Demeter Principle)又叫最少知道原则，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的public方法，不对外泄露任何信息 迪米特法则还有个更简单的定义：只与直接的朋友通信 直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式有很多：依赖、关联、组合、聚合等。其中，我们成出现的成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部 实例应用 描述：有一个学校，下属有各个学院和总部，现要求打印出学校总部员工ID和学院员工的ID import java.util.ArrayList; import java.util.List; //客户端 public class Demeter { public static void main(String[] args) { //创建了一个 SchoolManager 对象 SchoolManager schoolManager = new SchoolManager(); //输出学院的员工id 和 学校总部的员工信息 schoolManager.printAllEmployee(new CollegeManager()); } } //学校总部员工类 class Employee { private String id; public void setId(String id) { this.id = id; } public String getId() { return id; } } //学院的员工类 class CollegeEmployee { private String id; public void setId(String id) { this.id = id; } public String getId() { return id; } } //管理学院员工的管理类 class CollegeManager { //返回学院的所有员工 public List\u003cCollegeEmployee\u003e getAllEmployee() { List\u003cCollegeEmployee\u003e list = new ArrayList\u003cCollegeEmployee\u003e(); for (int i = 0; i \u003c 10; i++) { //这里我们增加了10个员工到 list CollegeEmployee emp = new CollegeEmployee(); emp.setId(\"学院员工id= \" + i); list.add(emp); } return list; } } //学校管理类 //分析 SchoolManager 类的直接朋友类有哪些 Employee、CollegeManager //CollegeEmployee 不是 直接朋友 而是一个陌生类，这样违背了 迪米特法则 class SchoolManager { //返回学校总部的员工 public List\u003cEmployee\u003e getAllEmployee() { List\u003cEmployee\u003e list = new ArrayList\u003cEmployee\u003e(); for (int i = 0; i \u003c 5; i++) { //这里我们增加了5个员工到 list Employee emp = new Employee(); emp.setId(\"学校总部员工id= \" + i); list.add(emp); } return list; } //该方法完成输出学校总部和学院员工信息(id) void printAllEmployee(CollegeManager sub) { //分析问题 //1. 这里的 CollegeEmployee 不是 SchoolManager的直接朋友 //2. CollegeEmployee 是以局部变量方式出现在 SchoolManager //3. 违反了 迪米特法则 //获取到学院员工 List\u003cCollegeEmployee\u003e list1 = sub.getAllEmployee(); System.out.println(\"------------学院员工------------\"); for (CollegeEmployee e : list1) { System.out.println(e.getId()); } //获取到学校总部员工 List\u003cEmployee\u003e list2 = this.getAllEmployee(); System.out.println(\"------------学校总部员工------------\"); for (Employee e : list2) { System.out.println(e.getId()); } } } 应用实例改进 前面设计的问题在于SchoolManager中，CollegeEmployee类并不是SchoolManager类的直接朋友 按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合 import java.util.ArrayList; import java.util.List; //客户端 public class Demeter { public static void main(String[] args) { System.out.println(\"~~~使用迪米特法则的改进~~~\"); //创建了一个 SchoolManager 对象 SchoolManager schoolManager = new SchoolManager(); //输出学院的员工id 和 学校总部的员工信息 schoolManager.printAllEmployee(new CollegeManager()); } } //学校总部员工类 class Employee { private String id; public void setId(String id) { this.id = id; } public String getId() { return id; } } //学院的员工类 class CollegeEmployee { private String id; public void setId(String id) { this.id = id; } public String getId() { return id; } } //管理学院员工的管理类 class CollegeManager { //返回学院的所有员工 public List\u003cCollegeEmployee\u003e getAllEmployee() { List\u003cCollegeEmployee\u003e list = new ArrayList\u003cCollegeEmployee\u003e(); for (int i = 0; i \u003c 10; i++) { //这里我们增加了10个员工到 list CollegeEmployee emp = new CollegeEmployee(); emp.setId(\"学院员工id= \" + i); list.add(emp); } return list; } //输出学院员工的信息 public void printEmployee() { //获取到学院员工 List\u003cCollegeEmployee\u003e list1 = getAllEmployee(); System.out.println(\"------------学院员工------------\"); for (CollegeEmployee e : list1) { System.out.println(e.getId()); } } } //学校管理类 //分析 SchoolManager 类的直接朋友类有哪些 Employee、CollegeManager //CollegeEmployee 不是 直接朋友 而是一个陌生类，这样违背了 迪米特法则 class SchoolManager { //返回学校总部的员工 public List\u003cEmployee\u003e getAllEmployee() { List\u003cEmployee\u003e list = new ArrayList\u003cEmployee\u003e(); for (int i = 0; i \u003c 5; i++) { //这里我们增加了5个员工到 list Employee emp = new Employee(); emp.setId(\"学校总部员工id= \" + i); list.add(emp); } return list; } //该方法完成输出学校总部和学院员工信息(id) void printAllEmployee(CollegeManager sub) { //分析问题 //1. 将输出学院的员工方法，封装到CollegeManager sub.printEmployee(); //获取到学校总部员工 List\u003cEmployee\u003e list2 = this.getAllEmployee(); System.out.println(\"------------学校总部员工-----","date":"2022-12-05","objectID":"/blog/20221205_designpatterns/:2:6","tags":["Java","coding","principle"],"title":"设计模式","uri":"/blog/20221205_designpatterns/"},{"categories":["Technology"],"content":"合成复用原则 介绍 原则是尽量使用合成/聚合的方式，而不是使用继承 合成复用原则 设计原则核心思想 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起 针对接口编程，而不是针对实现编程 为了交互对象之间的松耦合设计而努力 ","date":"2022-12-05","objectID":"/blog/20221205_designpatterns/:2:7","tags":["Java","coding","principle"],"title":"设计模式","uri":"/blog/20221205_designpatterns/"},{"categories":["Technology"],"content":"UML类图 ","date":"2022-12-05","objectID":"/blog/20221205_designpatterns/:3:0","tags":["Java","coding","principle"],"title":"设计模式","uri":"/blog/20221205_designpatterns/"},{"categories":["Technology"],"content":"介绍 UML–Unified modeling language UML（统一建模语言），是一种用于软件系统分析和设计的语言工具，它用于帮助软件开发人员进行思考和记录思路的结果 UML本身是一套符号的规定，就像数学符号和化学符号一样，这些符号用于描述软件模型中的各个元素和他们之间的关系，比如类、接口、实现、泛化、依赖、组合、聚合等 类关系 UML图例分类 用例图（use case） 静态结构图：类图、对象图、包图、组件图、部署图 动态行为图：交互图（时序图与协作图）、状态图、活动图 说明： 类图用于描述系统中类（对象）本身的组成和类（对象）之间的各种静态关系，是UML图中最核心的图例 设计模式中使用类图描述模式设计过程 类之间关系：依赖、泛化（继承）、实现、关联、聚合与组合 ","date":"2022-12-05","objectID":"/blog/20221205_designpatterns/:3:1","tags":["Java","coding","principle"],"title":"设计模式","uri":"/blog/20221205_designpatterns/"},{"categories":["Technology"],"content":"依赖关系（Dependence） 只要在类中使用到了对方，那么他们之间就存在依赖关系。如果没有对方，连编译都通过不了。 依赖关系 ","date":"2022-12-05","objectID":"/blog/20221205_designpatterns/:3:2","tags":["Java","coding","principle"],"title":"设计模式","uri":"/blog/20221205_designpatterns/"},{"categories":["Technology"],"content":"泛化关系（Generalization） 如果一个模型元素（子代）基于另一个模型元素（父代），那么这两个元素之间就存在泛化关系（继承关系） 泛化关系 ","date":"2022-12-05","objectID":"/blog/20221205_designpatterns/:3:3","tags":["Java","coding","principle"],"title":"设计模式","uri":"/blog/20221205_designpatterns/"},{"categories":["Technology"],"content":"实现关系（Implementation） 实现关系实际上是A类实现B接口，它是依赖关系的特例 实现关系 ","date":"2022-12-05","objectID":"/blog/20221205_designpatterns/:3:4","tags":["Java","coding","principle"],"title":"设计模式","uri":"/blog/20221205_designpatterns/"},{"categories":["Technology"],"content":"关联关系（Association） 关联关系实际上是类与类之间的联系，它是依赖关系的特例 关联具有导航性：即双向关系或单向关系 关系具有多重性：如“1”（表示有且仅有一个），“0…”（表示0个或者多个），“0，1”（表示0个或者一个），“n…m”（表示n到m个都可以），“m…*”（表示至少m个） 关联关系 ","date":"2022-12-05","objectID":"/blog/20221205_designpatterns/:3:5","tags":["Java","coding","principle"],"title":"设计模式","uri":"/blog/20221205_designpatterns/"},{"categories":["Technology"],"content":"聚合关系（Aggregation） 是整体与部分的关系, 且部分可以离开整体而单独存在。 聚合关系是关联关系的一种，是强的关联关系 关联和聚合在语法上无法区分，必须考察具体的逻辑关系 如下所示：车和轮胎是整体和部分的关系，轮胎离开车仍然可以存在 聚合关系 ","date":"2022-12-05","objectID":"/blog/20221205_designpatterns/:3:6","tags":["Java","coding","principle"],"title":"设计模式","uri":"/blog/20221205_designpatterns/"},{"categories":["Technology"],"content":"组合关系（Composition） 组合关系：也是整体与部分的关系，但是整体与部分不可以分开 组合关系是关联关系中的一种，也是比聚合关系还要强的关系，它要求普通的聚合关系中代表整体的对象负责代表部分对象的生命周期 如下所示：公司和部分是整体和部门的关系，没有公司就不存在部门 组合关系 ","date":"2022-12-05","objectID":"/blog/20221205_designpatterns/:3:7","tags":["Java","coding","principle"],"title":"设计模式","uri":"/blog/20221205_designpatterns/"},{"categories":["Technology"],"content":"设计模式 ","date":"2022-12-05","objectID":"/blog/20221205_designpatterns/:4:0","tags":["Java","coding","principle"],"title":"设计模式","uri":"/blog/20221205_designpatterns/"},{"categories":["Technology"],"content":"介绍 设计模式是程序员在面对同类软件工程设计问题所总结出来的有用的经验，模式不是代码，而是某类问题的通用解决方案，设计模式（Design Pattern）代表了最佳的实践。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 设计模式的本质是提高软件的维护性、通用型和扩展性，并降低软件的复杂度。 《设计模式》是经典的书，作者是Erich Gamma、Richard Helm、Ralph Johnson和John Vlissides Design（俗称“四人组GOF”） 设计模式并不局限于某种语言，Java、PHP、C++都有设计模式。 ","date":"2022-12-05","objectID":"/blog/20221205_designpatterns/:4:1","tags":["Java","coding","principle"],"title":"设计模式","uri":"/blog/20221205_designpatterns/"},{"categories":["Technology"],"content":"设计模式分类 模式分为三种类型 创建型模式： 单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式。 结构型模式： 适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。 行为型模式： 模版方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式（Interpreter模式）、状态模式、策略模式、职责模式（责任链模式）。 ","date":"2022-12-05","objectID":"/blog/20221205_designpatterns/:4:2","tags":["Java","coding","principle"],"title":"设计模式","uri":"/blog/20221205_designpatterns/"},{"categories":["Technology"],"content":"单例模式 介绍 所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类中只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法（静态方法）。 单例模式举例： 比如Hibernate的SessionFactory，它充当数据存储源的代理，并负责创建Session对象。SessionFactory并不是一个轻量级的，一般情况下，一个项目通常只需要一个SessionFactory就够，这时就会使用到单例模式。 单例模式的八种方式 饿汉式（静态常量） 饿汉式（静态代码块） 懒汉式（线程不安全） 懒汉式（线程安全，同步方法） 懒汉式（线程安全，同步代码块） 双重检查 静态内部类 枚举 饿汉式（静态常量） 实现步骤 构造器私有化（防止new） 类的内部创建对象 向外暴露一个静态的公共方法 代码实现 public class SingletonTest01 { public static void main(String[] args) { //测试 Singleton instance = Singleton.getInstance(); Singleton instance2 = Singleton.getInstance(); System.out.println(instance == instance2); // true System.out.println(\"instance.hashCode=\" + instance.hashCode()); System.out.println(\"instance2.hashCode=\" + instance2.hashCode()); } } //饿汉式(静态变量) class Singleton { //1. 构造器私有化, 外部能new private Singleton() { } //2.本类内部创建对象实例 private final static Singleton instance = new Singleton(); //3. 提供一个公有的静态方法，返回实例对象 public static Singleton getInstance() { return instance; } } 模式优缺点说明： 优点： 这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。 缺点： 在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费。 这种方式基于classoder机制避免了多线程的同步问题，不过，instabce在类装载时就实例化，在单例模式中大多数都是调用getInstance方法，但是导致类装载的原因有很多种，因此不能确定有其他的方式（或者其他的静态方法）导致类装载，这个时候初始化instance就没有达到lazy loading的效果。 结论：这种单例模式可用，可能造成内存浪费。 饿汉式（静态代码块） 实例应用 package com.atguigu.singleton.type2; public class SingletonTest02 { public static void main(String[] args) { //测试 Singleton instance = Singleton.getInstance(); Singleton instance2 = Singleton.getInstance(); System.out.println(instance == instance2); // true System.out.println(\"instance.hashCode=\" + instance.hashCode()); System.out.println(\"instance2.hashCode=\" + instance2.hashCode()); } } //饿汉式(静态变量) class Singleton { //1. 构造器私有化, 外部能new private Singleton() { } //2.本类内部创建对象实例 private static Singleton instance; static { // 在静态代码块中，创建单例对象 instance = new Singleton(); } //3. 提供一个公有的静态方法，返回实例对象 public static Singleton getInstance() { return instance; } } 模式优缺点说明 这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。（优缺点与上面一致） 结论：这种单例模式可用，但是可能造成内存浪费。 懒汉式（线程不安全） 实例应用 public class SingletonTest03 { public static void main(String[] args) { System.out.println(\"懒汉式1 ， 线程不安全~\"); Singleton instance = Singleton.getInstance(); Singleton instance2 = Singleton.getInstance(); System.out.println(instance == instance2); // true System.out.println(\"instance.hashCode=\" + instance.hashCode()); System.out.println(\"instance2.hashCode=\" + instance2.hashCode()); } } class Singleton { private static Singleton instance; private Singleton() {} //提供一个静态的公有方法，当使用到该方法时，才去创建 instance //即懒汉式 public static Singleton getInstance() { if(instance == null) { instance = new Singleton(); } return instance; } } 模式优缺点说明 起到了Lazy Loading的效果，但是只能在单线程下使用。 如果在多线程下，一个线程进入了if(singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可以使用这种方式。 结论：在实际开发中，不要使用这种方式。 懒汉式（线程安全，同步方法） 应用实例 public class SingletonTest04 { public static void main(String[] args) { System.out.println(\"懒汉式2 ， 线程安全~\"); Singleton instance = Singleton.getInstance(); Singleton instance2 = Singleton.getInstance(); System.out.println(instance == instance2); // true System.out.println(\"instance.hashCode=\" + instance.hashCode()); System.out.println(\"instance2.hashCode=\" + instance2.hashCode()); } } // 懒汉式(线程安全，同步方法) class Singleton { private static Singleton instance; private Singleton() {} //提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题 //即懒汉式 public static synchronized Singleton getInstance() { if(instance == null) { instance = new Singleton(); } return instance; } } 模式优缺点说明 解决了线程不安全问题 效率太低了，每个线程再想获得类的实例时候，执行getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接return就行了。方法进行同步效率太低。 结论：在实际开发中，不推荐使用这种方式 懒汉式（线程安全，同步代码块） 应用实例 class Singleton { private static Singleton singleton; private Singleton() {} public Singleton getInstance() { if(singleton == null) { synchronized (Singleton.class) { singleton = new Singleton(); } } return singleton; } } // 不推荐使用 双重检查 public class SingletonTest06 { public static void main(String[] args) { System.out.println(\"双重检查\"); Singleton inst","date":"2022-12-05","objectID":"/blog/20221205_designpatterns/:4:3","tags":["Java","coding","principle"],"title":"设计模式","uri":"/blog/20221205_designpatterns/"},{"categories":["Technology"],"content":"工厂模式 简单工厂模式 应用举例 需求：有一个披萨的项目，要便于披萨种类的扩展，要便于维护 披萨的种类很多（比如 GreekPizz、CheesePizz等） 披萨的制作有 prepare、back、cut、box 完成披萨店的订购功能 传统方法分析 思路分析（类图） 披萨项目类图 简单工厂模式的设计方案：定义一个可以实例化的Pizaa对象的类，封装创建对象的代码。 //将Pizza 类做成抽象 public abstract class Pizza { protected String name; //名字 //准备原材料, 不同的披萨不一样，因此，我们做成抽象方法 public abstract void prepare(); public void bake() { System.out.println(name + \" baking;\"); } public void cut() { System.out.println(name + \" cutting;\"); } //打包 public void box() { System.out.println(name + \" boxing;\"); } public void setName(String name) { this.name = name; } } public class PepperPizza extends Pizza { @Override public void prepare() { // TODO Auto-generated method stub System.out.println(\" 给胡椒披萨准备原材料 \"); } } public class GreekPizza extends Pizza { @Override public void prepare() { // TODO Auto-generated method stub System.out.println(\" 给希腊披萨 准备原材料 \"); } } public class CheesePizza extends Pizza { @Override public void prepare() { // TODO Auto-generated method stub System.out.println(\" 给制作奶酪披萨 准备原材料 \"); } } import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; public class OrderPizza { Pizza pizza = null; String orderType = \"\"; // 构造器 public OrderPizza2() { do { orderType = getType(); pizza = SimpleFactory.createPizza2(orderType); // 输出pizza if (pizza != null) { // 订购成功 pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); } else { System.out.println(\" 订购披萨失败 \"); break; } } while (true); } // 写一个方法，可以获取客户希望订购的披萨种类 private String getType() { try { BufferedReader strin = new BufferedReader(new InputStreamReader(System.in)); System.out.println(\"input pizza 种类:\"); String str = strin.readLine(); return str; } catch (IOException e) { e.printStackTrace(); return \"\"; } } } 传统方法的优缺点 优点是比较好理解，简单易操作 缺点是违反了设计模式的OCP原则，即对扩展开放，对修改关闭。即当我们给类增加新功能的时候，尽量不修改代码，或者尽可能少修改代码 比如我们这时要新增加一个Pizza的种类（Pepper披萨），我们需要另外增加新种类进行修改 改进思路与分析 分析： 修改代码可以接受，但是如果我们在其他的地方有创建Pizza的代码，就意味着，也需要修改，而创建Pizza的代码，往往有多处 思路：把创建Pizza对象封装到一个类中，这样我们有新的Pizza种类时，只需要修改该类即可，其它有创建到Pizza对象的代码就不需要修改了 -\u003e 简单工厂模式 简单工厂模式介绍 简单工厂模式是属于创建型模式，是工厂模式的一种。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式 简单工厂模式：定义了一个创建对象的类，由这个类来封装实例化对象的行为（代码） 在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式 简单工厂模式改造 简单工厂模式的设计方案：定义一个可以实例化Pizza对象的类，封装创建对象的代码。 package com.atguigu.factory.simplefactory.pizzastore.order; //简单工厂类 public class SimpleFactory { //更加orderType 返回对应的Pizza 对象 public Pizza createPizza(String orderType) { Pizza pizza = null; System.out.println(\"使用简单工厂模式\"); if (orderType.equals(\"greek\")) { pizza = new GreekPizza(); pizza.setName(\" 希腊披萨 \"); } else if (orderType.equals(\"cheese\")) { pizza = new CheesePizza(); pizza.setName(\" 奶酪披萨 \"); } else if (orderType.equals(\"pepper\")) { pizza = new PepperPizza(); pizza.setName(\"胡椒披萨\"); } return pizza; } //简单工厂模式 也叫 静态工厂模式 public static Pizza createPizza2(String orderType) { Pizza pizza = null; System.out.println(\"使用简单工厂模式2\"); if (orderType.equals(\"greek\")) { pizza = new GreekPizza(); pizza.setName(\" 希腊披萨 \"); } else if (orderType.equals(\"cheese\")) { pizza = new CheesePizza(); pizza.setName(\" 奶酪披萨 \"); } else if (orderType.equals(\"pepper\")) { pizza = new PepperPizza(); pizza.setName(\"胡椒披萨\"); } return pizza; } } import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; public class OrderPizza { // 构造器 // public OrderPizza() { // Pizza pizza = null; // String orderType; // 订购披萨的类型 // do { // orderType = getType(); // if (orderType.equals(\"greek\")) { // pizza = new GreekPizza(); // pizza.setName(\" 希腊披萨 \"); // } else if (orderType.equals(\"cheese\")) { // pizza = new CheesePizza(); // pizza.setName(\" 奶酪披萨 \"); // } else if (orderType.equals(\"pepper\")) { // pizza = new PepperPizza(); // pizza.setName(\"胡椒披萨\"); // } else { // break; // } // //输出pizza 制作过程 // pizza.prepare(); // pizza.bake(); // pizza.cut(); // pizza.box(); // // } while (true); // } //定义一个简单工厂对象 SimpleFactory simpleFactory; Pizza pizza = null; //构造器 public OrderPizza(SimpleFactory simpleFactory) { setFactory(simpleFactory); } public void setFac","date":"2022-12-05","objectID":"/blog/20221205_designpatterns/:4:4","tags":["Java","coding","principle"],"title":"设计模式","uri":"/blog/20221205_designpatterns/"},{"categories":["Technology"],"content":"原型模式 传统方法 克隆羊问题 现在有一只羊tom，姓名为：tom，年龄为：1，颜色为：白色，请编写程序创建和tom羊属性完全相同的10只羊。 传统方式解决 思路分析：类图图解 克隆羊类图 public class Sheep { private String name; private int age; private String color; public Sheep(String name, int age, String color) { super(); this.name = name; this.age = age; this.color = color; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getColor() { return color; } public void setColor(String color) { this.color = color; } @Override public String toString() { return \"Sheep [name=\" + name + \", age=\" + age + \", color=\" + color + \"]\"; } } public class Client { public static void main(String[] args) { // TODO Auto-generated method stub //传统的方法 Sheep sheep = new Sheep(\"tom\", 1, \"白色\"); Sheep sheep2 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor()); Sheep sheep3 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor()); Sheep sheep4 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor()); Sheep sheep5 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor()); //.... System.out.println(sheep); System.out.println(sheep2); System.out.println(sheep3); System.out.println(sheep4); System.out.println(sheep5); //... } } 传统方式的优缺点 有点是比较好理解，简单易操作。 在创建新的对象时，总是需要重新获取原始对象的属性，如果创建的对象比较复杂时，效率较低。 总是需要重新初始化对象，而不是动态地获得对象运行时的状态，不够灵活。 改进思路与分析 思路：Java中Object类是所有类的根类，Object类提供了一个clone()方法，该方法可以将一个Java对象复制一份，但是需要实现clone的Java类必须要实现一个接口Cloneable，该接口表示该类能够复制且具有复制的能力-\u003e原型模式 原型模式 介绍 原型模式（Prototype模式）是指：用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象。 原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象，无需知道如何创建的细节。 工作原理：通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即 对象.clone() 形象的理解：孙大圣拔出猴毛，变出其他孙大圣。 原型模式原理结构图-UML类图 原型模式类图 原理结构图说明 Prototype：原型类，声明一个克隆自己的接口 ConcretePrototype：具体的原型类，实现一个克隆自己的操作 Client：让一个原型对象克隆自己，从而创建一个新的对象（属性一样） 原型模式解决克隆羊问题 使用原型模式改进传统方式，让程序具有更高的效率和扩展性 public class Sheep implements Cloneable { private String name; private int age; private String color; private String address = \"蒙古羊\"; public Sheep friend; //是对象, 克隆是会如何处理 public Sheep(String name, int age, String color) { super(); this.name = name; this.age = age; this.color = color; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getColor() { return color; } public void setColor(String color) { this.color = color; } @Override public String toString() { return \"Sheep [name=\" + name + \", age=\" + age + \", color=\" + color + \", address=\" + address + \"]\"; } //克隆该实例，使用默认的clone方法来完成 @Override protected Object clone() { Sheep sheep = null; try { sheep = (Sheep)super.clone(); } catch (Exception e) { // TODO: handle exception System.out.println(e.getMessage()); } // TODO Auto-generated method stub return sheep; } } public class Client { public static void main(String[] args) { System.out.println(\"原型模式完成对象的创建\"); // TODO Auto-generated method stub Sheep sheep = new Sheep(\"tom\", 1, \"白色\"); sheep.friend = new Sheep(\"jack\", 2, \"黑色\"); Sheep sheep2 = (Sheep)sheep.clone(); //克隆 Sheep sheep3 = (Sheep)sheep.clone(); //克隆 Sheep sheep4 = (Sheep)sheep.clone(); //克隆 Sheep sheep5 = (Sheep)sheep.clone(); //克隆 System.out.println(\"sheep2 =\" + sheep2 + \"sheep2.friend=\" + sheep2.friend.hashCode()); System.out.println(\"sheep3 =\" + sheep3 + \"sheep3.friend=\" + sheep3.friend.hashCode()); System.out.println(\"sheep4 =\" + sheep4 + \"sheep4.friend=\" + sheep4.friend.hashCode()); System.out.println(\"sheep5 =\" + sheep5 + \"sheep5.friend=\" + sheep5.friend.hashCode()); } } 原型模式在Spring框架中源码分析 Spring中原型bean的创建，就是原型模式的应用 代码分析 /** * 注释 * @author Administrator * */ public class Monster { private Integer id = 10 ; private String nickname = \"牛魔王\"; private String skill = \"芭蕉扇\"; public Monster() { System.out.println(\"monster 创建..\"); } public Monster(Integer id, String nickname, String skill) { //System.out.println(\"Integer id, String nickname, String skill被调用\");","date":"2022-12-05","objectID":"/blog/20221205_designpatterns/:4:5","tags":["Java","coding","principle"],"title":"设计模式","uri":"/blog/20221205_designpatterns/"},{"categories":["Technology"],"content":"建造者模式 传统方法 盖房问题 项目需求： 需要建造房子：这一过程为打桩、砌墙、封顶 房子有各种各样的，比如普通房，高楼，别墅，各种房子的过程虽然一样，但是要求不要相同的。 传统方式解决 传统方式分析类图 public abstract class AbstractHouse { //打地基 public abstract void buildBasic(); //砌墙 public abstract void buildWalls(); //封顶 public abstract void roofed(); public void build() { buildBasic(); buildWalls(); roofed(); } } public class CommonHouse extends AbstractHouse { @Override public void buildBasic() { // TODO Auto-generated method stub System.out.println(\" 普通房子打地基 \"); } @Override public void buildWalls() { // TODO Auto-generated method stub System.out.println(\" 普通房子砌墙 \"); } @Override public void roofed() { // TODO Auto-generated method stub System.out.println(\" 普通房子封顶 \"); } } public class Client { public static void main(String[] args) { // TODO Auto-generated method stub CommonHouse commonHouse = new CommonHouse(); commonHouse.build(); } } 传统方式的问题分析 优点是比较好理解，简单易操作。 设计的程序结构，过于简单，没有设计缓存层对象，程序的扩展和维护不好，也就是说，这种设计方案，把产品（即：房子）和创建产品的过程（即：建房子流程）封装在一起，耦合性增强了。 解决方案：将产品和产品建造过程耦合-\u003e建造者模式 建造者模式基本介绍 建造者模式（Builder Pattern）又叫生成器模式，是一种对象构造模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。 **建造者模式 **是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构造他们，用户不需要知道内部的具体构建细节。 建造者模式的四个角色 Product（产品角色）：一个具体的产品对象 Builder（抽象建造者）：创建一个Product对象的各个部件指定的接口/抽象类。 ConcreteBuilder（具体建造者）：实现接口，构造和装配各个部件。 Director（指挥者）：构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用，一：隔离了客户与对象的生产过程，二：负责控制产品对象的生产过程。 建造者模式原理类图 建造者模式类图 建造者模式解决盖房问题 盖房问题类图 // 抽象的建造者 public abstract class HouseBuilder { protected House house = new House(); //将建造的流程写好, 抽象的方法 public abstract void buildBasic(); public abstract void buildWalls(); public abstract void roofed(); //建造房子好， 将产品(房子) 返回 public House buildHouse() { return house; } } //指挥者，这里去指定制作流程，返回产品 public class HouseDirector { HouseBuilder houseBuilder = null; //构造器传入 houseBuilder public HouseDirector(HouseBuilder houseBuilder) { this.houseBuilder = houseBuilder; } //通过setter 传入 houseBuilder public void setHouseBuilder(HouseBuilder houseBuilder) { this.houseBuilder = houseBuilder; } //如何处理建造房子的流程，交给指挥者 public House constructHouse() { houseBuilder.buildBasic(); houseBuilder.buildWalls(); houseBuilder.roofed(); return houseBuilder.buildHouse(); } } //产品-\u003eProduct public class House { private String baise; private String wall; private String roofed; public String getBaise() { return baise; } public void setBaise(String baise) { this.baise = baise; } public String getWall() { return wall; } public void setWall(String wall) { this.wall = wall; } public String getRoofed() { return roofed; } public void setRoofed(String roofed) { this.roofed = roofed; } } public class HighBuilding extends HouseBuilder { @Override public void buildBasic() { // TODO Auto-generated method stub System.out.println(\" 高楼的打地基100米 \"); } @Override public void buildWalls() { // TODO Auto-generated method stub System.out.println(\" 高楼的砌墙20cm \"); } @Override public void roofed() { // TODO Auto-generated method stub System.out.println(\" 高楼的透明屋顶 \"); } } public class CommonHouse extends HouseBuilder { @Override public void buildBasic() { // TODO Auto-generated method stub System.out.println(\" 普通房子打地基5米 \"); } @Override public void buildWalls() { // TODO Auto-generated method stub System.out.println(\" 普通房子砌墙10cm \"); } @Override public void roofed() { // TODO Auto-generated method stub System.out.println(\" 普通房子屋顶 \"); } } public class Client { public static void main(String[] args) { //盖普通房子 CommonHouse commonHouse = new CommonHouse(); //准备创建房子的指挥者 HouseDirector houseDirector = new HouseDirector(commonHouse); //完成盖房子，返回产品(普通房子) House house = houseDirector.constructHouse(); //System.out.println(\"输出流程\"); System.out.println(\"--------------------------\"); //盖高楼 HighBuilding highBuilding = new HighBuilding(); //重置建造者 houseDirector.setHouseBuilder(highBuilding); //完成盖房子，返回产品(高楼) houseDirector.constructHouse(); } } 建造者模式在JDK的应用和源码分析 java.lang.StringBuilder中的建造者模式 abstract class AbstractStringBuilder implements Appendable, CharSequence { /** * The value is used for character storage. */ char[] value; ","date":"2022-12-05","objectID":"/blog/20221205_designpatterns/:4:6","tags":["Java","coding","principle"],"title":"设计模式","uri":"/blog/20221205_designpatterns/"},{"categories":["Technology"],"content":"适配器模式 介绍 适配器模式（Adapter Pattern）将某个类的接口转换成客户端期望的另一个接口表示，主要目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器（Wrapper） 适配器模式属于结构型模式 主要分为三类：类适配器模式、对象适配器模式、接口适配器模式 适配器模式工作原理 适配器模式：将一个类的接口转换成另一种接口，让原本接口不兼容的类可以兼容 从用户的角度看不到适配者，是解耦的 用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法 用户用收到反馈结果，感觉只是和目标交互 类适配器模式 介绍 Adapter类，通过继承src类，实现dst类接口，完成 src -\u003e dst 的适配 应用实例 生活中充电器的例子来反应适配器模式，充电器本身相当于Adapter，220V交流电相当于src（即被适配者），我们的dst（即目标)是5V直流电 类适配器实例 //适配接口 public interface IVoltage5V { public int output5V(); } //被适配的类 public class Voltage220V { //输出220V的电压 public int output220V() { int src = 220; System.out.println(\"电压=\" + src + \"伏\"); return src; } } //适配器类 public class VoltageAdapter extends Voltage220V implements IVoltage5V { @Override public int output5V() { // TODO Auto-generated method stub //获取到220V电压 int srcV = output220V(); int dstV = srcV / 44 ; //转成 5v return dstV; } } public class Phone { //充电 public void charging(IVoltage5V iVoltage5V) { if(iVoltage5V.output5V() == 5) { System.out.println(\"电压为5V, 可以充电~~\"); } else if (iVoltage5V.output5V() \u003e 5) { System.out.println(\"电压大于5V, 不能充电~~\"); } } } public class Client { public static void main(String[] args) { // TODO Auto-generated method stub System.out.println(\" === 类适配器模式 ====\"); Phone phone = new Phone(); phone.charging(new VoltageAdapter()); } } 类适配器模式注意事项和细节 Java是单继承机制，所以类适配器需要继承src类这一点算是一个缺点，因为这要求dst必须是接口，有一定局限性 src类的方法在Adapter中都会暴露出来，也增加了使用的成本 由于其继承了src类，所以它可以根据需求重写src类的方法，使得Adapter的灵活性增强了。 对象适配器模式 介绍 基本思路和类的适配器模式相同，只是将Adapter类作修改，不是继承src类，而是持有src类的实例，以解决兼容性的问题。即：持有src类，实现dst类接口，完成 src -\u003e dst 的适配 根据“合成复用原则”，在系统中尽量使用关联关系来代替继承关系 对象适配器模式是适配器模式常用的一种 应用实例 生活中充电器的例子来讲解适配器，充电器本身相当于Adapter，220V交流电相当于src（即被适配者），我们的dst（即目标）是5V直流电，使用对象适配器模式完成 ![对象适配器实例](https://cdn.jsdelivr.net/gh/Turbo-King/images/%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8%E5%AE%9E%E4%BE%8B.png ““对象适配器实例””) //适配接口 public interface IVoltage5V { public int output5V(); } //被适配的类 public class Voltage220V { //输出220V的电压，不变 public int output220V() { int src = 220; System.out.println(\"电压=\" + src + \"伏\"); return src; } } //适配器类 public class VoltageAdapter implements IVoltage5V { private Voltage220V voltage220V; // 关联关系-聚合 //通过构造器，传入一个 Voltage220V 实例 public VoltageAdapter(Voltage220V voltage220v) { this.voltage220V = voltage220v; } @Override public int output5V() { int dst = 0; if(null != voltage220V) { int src = voltage220V.output220V();//获取220V 电压 System.out.println(\"使用对象适配器，进行适配~~\"); dst = src / 44; System.out.println(\"适配完成，输出的电压为=\" + dst); } return dst; } } public class Phone { //充电 public void charging(IVoltage5V iVoltage5V) { if(iVoltage5V.output5V() == 5) { System.out.println(\"电压为5V, 可以充电~~\"); } else if (iVoltage5V.output5V() \u003e 5) { System.out.println(\"电压大于5V, 不能充电~~\"); } } } public class Client { public static void main(String[] args) { // TODO Auto-generated method stub System.out.println(\" === 对象适配器模式 ====\"); Phone phone = new Phone(); phone.charging(new VoltageAdapter(new Voltage220V())); } } 对象适配器模式注意事项和细节 对象适配器 对象适配器和类适配器其实算是同一种思想，只不过实现方式不同。根据合成复用原则，使用组合替代继承，所以它解决了类适配器必须继承src的局限性问题，也不再要求dst必须是接口 使用成本更低，更灵活 接口适配器模式 介绍 一些书籍称为：适配器模式（Default Adapter Pattern）或缺省适配器模式 当不需要全部实现接口提供的方法时，可以先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现（空方法），那么该抽象类的字类可有选择地覆盖父类的某些方法来实现需求 适用于一个接口不想使用其所有的方法的情况 应用实例 接口适配器实例 public interface InterfaceAdapter { public void m1(); public void m2(); public void m3(); public void m4(); } //在AbsAdapter 我们将 Interface4 的方法进行默认实现 public abstract class AbsAdapter implements InterfaceAdapter { //默认实现 public void m1() { } public void m2() { } public void m3() { } public void m4() { } } public class Client { public static void main(String[] args) { AbsAdapter absAdapter = new AbsAdapter() { //只需要去覆盖我们 需要使用 接口方法 @Override public void m1() { // TODO Auto-generated method stub System.out.println(\"使用了m1的方法\"); } }; absAdapter.m1(); } } 有时候我们不想实现InterfaceAdapter接口中的全部方法，我们只想监听m1方法，我们只需按如上方式实现接口适配器。 AbsAdapter类，就是一个接口适配器，它空实现了InterfaceAdapter接口中的所有方法。 适配器模式在SpringMVC框架应用的源码分析 SpringMVC中的HandleAdapter，就使用了适配器模式 使用HandleAdapter的原因分析： 根据源码分析可以看到处理器的类型不同，有多重实现方式，那么","date":"2022-12-05","objectID":"/blog/20221205_designpatterns/:4:7","tags":["Java","coding","principle"],"title":"设计模式","uri":"/blog/20221205_designpatterns/"},{"categories":["Technology"],"content":"桥接模式 传统方法 手机操作问题 现在对于不同手机类型的不同品牌实现操作编程（比如：开机、关机、上网、打电话等），如下图所示： Phone 传统方案解决手机使用问题 传统方法对应的类图 手机使用问题类图 传统方案解决手机操作类型 扩展性问题（类爆炸），如果我们再增加手机的样式（旋转式）,就需要增加各个品牌手机的类，同样如果我们增加一个手机品牌，也要在各个手机样式类下增加 违反了单一职责原则，当我们增加手机样式时，要同时增加所有品牌的手机，这样增加了代码维护成本 解决方案-使用桥接模式 桥接模式 基本介绍 **桥接模式（Bridge模式）**是指：将实现与抽象放在两个不同的类层次中，使两个层次可以独立改变 是一种结构型设计模式 Bridge模式基于类的最小设计原则，通过使用封装、聚合及继承等行为让不同的类承担不同的职责。它的主要特点是把抽象（Abstraction）与行为实现（Implementation）分离开来，从而可以保持各部分的独立性以及应对他们的功能扩展 桥接模式原理类图 桥接模式类图 类图说明 Client类：桥接模式模式的调用者 抽象类（Abstraction）：维护了Implementor/即它的实现类Concrete ImplementorA..，二者是聚合关系，Abstraction充当桥接类 RefinedAbstraction：是Abstraction抽象类的字类 Implementor：行为实现类的接口 Concrete ImplementorA/B：行为的具体实现类 从UML图：这里的抽象类和接口是聚合的关系，其实调用和被调用关系 桥接模式解决手机操作问题 使用桥接模式改进传统方式，让程序具有搞好的扩展性，利用程序维护 桥接模式解决手机操作问题类图 //接口 public interface Brand { void open(); void close(); void call(); } public abstract class Phone { //组合品牌 private Brand brand; //构造器 public Phone(Brand brand) { super(); this.brand = brand; } protected void open() { this.brand.open(); } protected void close() { brand.close(); } protected void call() { brand.call(); } } //折叠式手机类，继承 抽象类 Phone public class FoldedPhone extends Phone { //构造器 public FoldedPhone(Brand brand) { super(brand); } public void open() { super.open(); System.out.println(\" 折叠样式手机 \"); } public void close() { super.close(); System.out.println(\" 折叠样式手机 \"); } public void call() { super.call(); System.out.println(\" 折叠样式手机 \"); } } public class UpRightPhone extends Phone { //构造器 public UpRightPhone(Brand brand) { super(brand); } public void open() { super.open(); System.out.println(\" 直立样式手机 \"); } public void close() { super.close(); System.out.println(\" 直立样式手机 \"); } public void call() { super.call(); System.out.println(\" 直立样式手机 \"); } } public class Vivo implements Brand { @Override public void open() { // TODO Auto-generated method stub System.out.println(\" Vivo手机开机 \"); } @Override public void close() { // TODO Auto-generated method stub System.out.println(\" Vivo手机关机 \"); } @Override public void call() { // TODO Auto-generated method stub System.out.println(\" Vivo手机打电话 \"); } } public class XiaoMi implements Brand { @Override public void open() { // TODO Auto-generated method stub System.out.println(\" 小米手机开机 \"); } @Override public void close() { // TODO Auto-generated method stub System.out.println(\" 小米手机关机 \"); } @Override public void call() { // TODO Auto-generated method stub System.out.println(\" 小米手机打电话 \"); } } public class Client { public static void main(String[] args) { //获取折叠式手机 (样式 + 品牌 ) Phone phone1 = new FoldedPhone(new XiaoMi()); phone1.open(); phone1.call(); phone1.close(); System.out.println(\"=======================\"); Phone phone2 = new FoldedPhone(new Vivo()); phone2.open(); phone2.call(); phone2.close(); System.out.println(\"==============\"); UpRightPhone phone3 = new UpRightPhone(new XiaoMi()); phone3.open(); phone3.call(); phone3.close(); System.out.println(\"==============\"); UpRightPhone phone4 = new UpRightPhone(new Vivo()); phone4.open(); phone4.call(); phone4.close(); } } 桥接模式在JDBC的源码剖析 JDBC的Driver接口，如果从桥接模式来看，Driver就是一个接口，下面可以有MySQL的Driver，Oracle的Driver，这些就可以当作实现接口类 JDBC源码分析类图 import java.sql.SQLException; /** * The Java SQL framework allows for multiple database drivers. Each driver should supply a class that implements the Driver interface * * \u003cp\u003e * The DriverManager will try to load as many drivers as it can find and then for any given connection request, it will ask each driver in turn to try to * connect to the target URL. * * \u003cp\u003e * It is strongly recommended that each Driver class should be small and standalone so that the Driver class can be loaded and queried without bringing in vast * quantities of supporting code. * * \u003cp\u003e * When a Driver class is loaded, it should create an instance of itself and register it with the DriverManager. This means that a user can load and register a * driver by doing Class.forName(\"foo.bah.Driver\") */ public class Driver extends NonRegisteringDriver implements java.sql.Driver { // // Register ourselves with the DriverM","date":"2022-12-05","objectID":"/blog/20221205_designpatterns/:4:8","tags":["Java","coding","principle"],"title":"设计模式","uri":"/blog/20221205_designpatterns/"},{"categories":["Technology"],"content":"装饰者模式 传统方法 咖啡订单项目（咖啡馆） 咖啡种类/单品咖啡：Espresso（意大利浓缩咖啡）、ShortBlack、LongBlack（美式咖啡）、Decaf（无因咖啡） 调料：Milk、Soy（豆浆）、Chocolate 要求在扩展新的咖啡种类时，具有良好的扩展性、改动方便、维护方便 使用OO的来计算不同种类咖啡的费用：客户可以点单品咖啡、也可以点单品咖啡+调料组合 解决方案一 咖啡订单解决方案一 方案一问题分析 Drink是一个抽象类，表示饮料 des就是对咖啡的描述，比如咖啡的名字 cost()方法就是计算费用，Drink类中做一个抽象方法 Decaf就是单品咖啡，继承Drink，并实现cost方法 Espress \u0026\u0026 Milk 就是单品咖啡+调料，这个组合很多 问题：这样设计会有很多类，当我们增加一个单品咖啡或者一个新的调料，类的数量就会倍增，就会出现类爆炸 解决方案二 前面分析到方案一因为咖啡单品+调料组合会造成类的倍增，因此可以做改进，将调料内置到Drink类，这样就不会造成类数量过多。从而提高项目的维护性（如下图） 咖啡馆解决方案二 **说明：**milk，soy，chocolate 可以设计为Boolean，表示是否要添加相应的调料 方案二分析 方案二可以控制类的数量，不至于造成很多的类 在增加或者删除调料种类时，代码的维护量很大 考虑到用户可以添加多份调料时，可以将hasMIlk返回一个对应的int 考虑使用装饰者模式 装饰者模式 基本介绍 装饰者模式：动态的将新功能附加到对象上。在对象功能扩展方面，它比继承更有弹性，装饰者模式也体现了开闭原则（OCP） 这里提到的动态的将新功能附加到对象和OCP原则，在后面的应用实例上会以代码的形式体现，请读者注意。 装饰者模式原理 原理图 装饰者模式就像打包一个快递 主体：比如：陶瓷、衣服（Component） //被装饰者 包装：比如：报纸填充、塑料泡沫、纸板、木板（Decorator） Component主体：比如类似前面的Drink ConcreteComponent：具体的主体，比如前面各个单品咖啡 Decorator：装饰者，比如各种调料 如图中Component与ConcreteComponent之间，如果ConcreteComponent类很多，还可以设计一个缓冲层，将共有的部分提取出来，抽象层一个类 装饰者模式解决咖啡订单 装饰者模式解决咖啡订单 说明： Drink 类就是前面说的抽象类，Component ShortBlack 就是单品咖啡 Decorator是一个装饰类，含有一个被装饰的对象（Drink obj） Decorator的cost方法进行一个费用的叠加计算，递归的计算价格 装饰者模式下的订单：2份巧克力+1份牛奶的LongBlack 装饰者模式下的订单 说明： Milk包含了LongBlack 一份Chocolate包含了（Milk+LongBlack） 一份Chocolate包含了（Chocolate+Milk+LongBlack） 这样是不管什么形式的单品咖啡+调料组合，通过递归方式可以方便的组合和维护 装饰者模式咖啡订单应用实例 public abstract class Drink { public String des; // 描述 private float price = 0.0f; public String getDes() { return des; } public void setDes(String des) { this.des = des; } public float getPrice() { return price; } public void setPrice(float price) { this.price = price; } //计算费用的抽象方法 //子类来实现 public abstract float cost(); } public class Coffee extends Drink { @Override public float cost() { // TODO Auto-generated method stub return super.getPrice(); } } public class DeCaf extends Coffee { public DeCaf() { setDes(\" 无因咖啡 \"); setPrice(1.0f); } } public class Decorator extends Drink { private Drink obj; public Decorator(Drink obj) { //组合 // TODO Auto-generated constructor stub this.obj = obj; } @Override public float cost() { // TODO Auto-generated method stub // getPrice 自己价格 return super.getPrice() + obj.cost(); } @Override public String getDes() { // TODO Auto-generated method stub // obj.getDes() 输出被装饰者的信息 return des + \" \" + getPrice() + \" \u0026\u0026 \" + obj.getDes(); } } public class Espresso extends Coffee { public Espresso() { setDes(\" 意大利咖啡 \"); setPrice(6.0f); } } //具体的Decorator， 这里就是调味品 public class Chocolate extends Decorator { public Chocolate(Drink obj) { super(obj); setDes(\" 巧克力 \"); setPrice(3.0f); // 调味品 的价格 } } public class LongBlack extends Coffee { public LongBlack() { setDes(\" longblack \"); setPrice(5.0f); } } public class ShortBlack extends Coffee{ public ShortBlack() { setDes(\" shortblack \"); setPrice(4.0f); } } public class Milk extends Decorator { public Milk(Drink obj) { super(obj); // TODO Auto-generated constructor stub setDes(\" 牛奶 \"); setPrice(2.0f); } } public class Soy extends Decorator{ public Soy(Drink obj) { super(obj); // TODO Auto-generated constructor stub setDes(\" Soy \"); setPrice(1.5f); } } public class CoffeeBar { public static void main(String[] args) { // TODO Auto-generated method stub // 装饰者模式下的订单：2份巧克力+一份牛奶的LongBlack // 1. 点一份 LongBlack Drink order = new LongBlack(); System.out.println(\"费用1=\" + order.cost()); System.out.println(\"描述=\" + order.getDes()); // 2. order 加入一份牛奶 order = new Milk(order); System.out.println(\"order 加入一份牛奶 费用 =\" + order.cost()); System.out.println(\"order 加入一份牛奶 描述 = \" + order.getDes()); // 3. order 加入一份巧克力 order = new Chocolate(order); System.out.println(\"order 加入一份牛奶 加入一份巧克力 费用 =\" + order.cost()); System.out.println(\"order 加入一份牛奶 加入一份巧克力 描述 = \" + order.getDes()); // 3. order 加入一份巧克力 order = new Chocolate(order); System.out.println(\"order 加入一份牛奶 加入2份巧克力 费用 =\" + order.cost()); System.out.println(\"order 加入一份牛奶 加入2份巧克力 描述 = \" + order.getDes()); System.out.println(\"===========================\"); Drink order2 = new DeCaf(); System.out.println(\"order2 无因咖啡 费用 =\" + orde","date":"2022-12-05","objectID":"/blog/20221205_designpatterns/:4:9","tags":["Java","coding","principle"],"title":"设计模式","uri":"/blog/20221205_designpatterns/"},{"categories":["Technology"],"content":"组合模式 传统方法 学校院系展示需求 编写程序展示一个学校院系结构：需求是这样的，要在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系。如下图所示。 学院展示需求 传统方案解决学校院系展示（类图） 传统解决方案类图 传统方案解决学校院系展示存在的问题分析 将学院看作是学校的子类，系是学院的子类，这样实际上是站在组织大小来进行分层次的 实际上我们的要求是：在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个院系，因此这种方案，不能很好实现的管理操作，比如对学院、系的添加，删除，遍历等 解决方案：把学校、院、系都看做是组织结构，他们之间没有继承的关系，而是一个树形结构，可以更好的实现管理操作-\u003e(组合模式) 组合模式 基本介绍 组合模式（Composite Pattern），又叫部分整体模式，它创建了对象组的树形结构，将对象组合成树状结构以表示“整体-部分”的层次关系 组合模式依据树形结构来组合对象，用来表示部分以及整体层次 这种类型的设计模式属于结构型模式 组合模式使得用户对单个对象和组合对象的访问具有一致性，即：组合能让客户以一致的方式处理个别对象以及组合对象 组合模式的原理类图 组合模式原理类图 组合模式的角色及职责 Component：这是组合中对象声明接口，在适当情况下，实现所有类共有的接口默认行为，用于访问和管理Component子部件，Component可以是抽象类或者接口 Leaf：在组合中表示叶子节点，叶子节点没有子节点 Composite：非叶子节点，用于存储子部件，在Component接口中实现子部件的相关操作，比如增加（add），删除（delete） 组合模式解决学校院系展示的应用实例 需求：编写程序展示一个学校院系结构，要在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系 组合模式解决学校院系展示 public abstract class OrganizationComponent { private String name; // 名字 private String des; // 说明 protected void add(OrganizationComponent organizationComponent) { //默认实现 throw new UnsupportedOperationException(); } protected void remove(OrganizationComponent organizationComponent) { //默认实现 throw new UnsupportedOperationException(); } //构造器 public OrganizationComponent(String name, String des) { super(); this.name = name; this.des = des; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getDes() { return des; } public void setDes(String des) { this.des = des; } //方法print, 做成抽象的, 子类都需要实现 protected abstract void print(); } import java.util.ArrayList; import java.util.List; //University 就是 Composite , 可以管理College public class University extends OrganizationComponent { List\u003cOrganizationComponent\u003e organizationComponents = new ArrayList\u003cOrganizationComponent\u003e(); // 构造器 public University(String name, String des) { super(name, des); // TODO Auto-generated constructor stub } // 重写add @Override protected void add(OrganizationComponent organizationComponent) { // TODO Auto-generated method stub organizationComponents.add(organizationComponent); } // 重写remove @Override protected void remove(OrganizationComponent organizationComponent) { // TODO Auto-generated method stub organizationComponents.remove(organizationComponent); } @Override public String getName() { // TODO Auto-generated method stub return super.getName(); } @Override public String getDes() { // TODO Auto-generated method stub return super.getDes(); } // print方法，就是输出University 包含的学院 @Override protected void print() { // TODO Auto-generated method stub System.out.println(\"--------------\" + getName() + \"--------------\"); //遍历 organizationComponents for (OrganizationComponent organizationComponent : organizationComponents) { organizationComponent.print(); } } } public class Department extends OrganizationComponent { //没有集合 public Department(String name, String des) { super(name, des); // TODO Auto-generated constructor stub } //add , remove 就不用写了，因为他是叶子节点 @Override public String getName() { // TODO Auto-generated method stub return super.getName(); } @Override public String getDes() { // TODO Auto-generated method stub return super.getDes(); } @Override protected void print() { // TODO Auto-generated method stub System.out.println(getName()); } } import java.util.ArrayList; import java.util.List; public class College extends OrganizationComponent { //List 中 存放的Department List\u003cOrganizationComponent\u003e organizationComponents = new ArrayList\u003cOrganizationComponent\u003e(); // 构造器 public College(String name, String des) { super(name, des); // TODO Auto-generated constructor stub } // 重写add @Override protected void add(OrganizationComponent organizationComponent) { // TODO Auto-generated method stub // 将来实际业务中，Colleage 的 add 和 University add 不一定完全一样 organizationComponents.add(organizationComponent); } // 重写remove @Override protected void remove(OrganizationComponent organizationComponent) { // TODO Auto-generated method stub organizationComponents.remove(organizationComponent); } @Override public String getName() { // TODO Auto-generated method","date":"2022-12-05","objectID":"/blog/20221205_designpatterns/:4:10","tags":["Java","coding","principle"],"title":"设计模式","uri":"/blog/20221205_designpatterns/"},{"categories":["Technology"],"content":"外观模式 传统方法 影院管理项目 组建一个家庭影院： DVD播放器、投影仪、自动屏幕、环绕立体声、爆米花机，要求完成使用家庭影院的功能，其过程如下： 直接用遥控器：统筹各系统开关 开爆米花机 放下投影幕布 开投影仪 开音响 开DVD，选DVD片源 去拿爆米花 调暗灯关 播放 观影结束，关闭各种设备 传统方式解决影院管理 传统方式解决影院管理 传统方式解决影院管理问题分析 在ClientTest的main方法中，创建各个子系统的对象，并直接去调用子系统（对象）相关方法，会造成调用过程混乱，没有清晰的过程 不利于在ClientTest中，去维护对子系统的操作 解决思路：定义一个高层接口，给子系统中的一组接口提供一个一致的界面（比如在高层接口提供四个方法：ready，play，pause，end），用来访问子系统中的一群接口 就是通过定义一个一致的接口（界面类），用以屏蔽内部子系统的细节，使得调用端只需跟这个接口发生调用，而无须关心这个子系统的内部细节-\u003e外观模式 外观模式 基本介绍 外观模式（Facade），也叫“过程模式：外观模式为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用” 外观模式通过定义个一致的接口，用以屏蔽内部子系统的细节，使得调用端只需跟这个接口发生调用，而无需关心这个子系统的内部细节 外观模式原理类图 外观模式原理类图 外观模式的角色及职责 外观类（Facade）：为调用端提供统一的调用接口，外观类知道哪些子系统负责处理请求，从而将调用端的请求代理给适当子系统对象 调用着（Client）：外观接口的调用者 子系统的集合：指模块或者子系统，处理Facade对象指派的任务，它是功能的实际提供者 外观模式解决影院管理 外观模式可以理解为转换一群接口，客户只要调用一个接口，而不用调用多个接口才能达到目的。比如：在PC上安装软件的时候经常有一键安装选项（省去选择安装目录、安装的组件等等），还有就是手机的重启功能（把关机和启动合为一个操作） 外观模式就是解决多个复杂接口带来的使用困难，起到简化用户操作的作用 示意图说明如下： 外观模式解决影院管理示意图 外观模式解决影院管理应用实例 外观模式解决影院管理应用实例 public class HomeTheaterFacade { //定义各个子系统对象 private TheaterLight theaterLight; private Popcorn popcorn; private Stereo stereo; private Projector projector; private Screen screen; private DVDPlayer dVDPlayer; //构造器 public HomeTheaterFacade() { super(); this.theaterLight = TheaterLight.getInstance(); this.popcorn = Popcorn.getInstance(); this.stereo = Stereo.getInstance(); this.projector = Projector.getInstance(); this.screen = Screen.getInstance(); this.dVDPlayer = DVDPlayer.getInstanc(); } //操作分成 4 步 public void ready() { popcorn.on(); popcorn.pop(); screen.down(); projector.on(); stereo.on(); dVDPlayer.on(); theaterLight.dim(); } public void play() { dVDPlayer.play(); } public void pause() { dVDPlayer.pause(); } public void end() { popcorn.off(); theaterLight.bright(); screen.up(); projector.off(); stereo.off(); dVDPlayer.off(); } } public class Stereo { private static Stereo instance = new Stereo(); public static Stereo getInstance() { return instance; } public void on() { System.out.println(\" Stereo on \"); } public void off() { System.out.println(\" Screen off \"); } public void up() { System.out.println(\" Screen up.. \"); } //... } public class DVDPlayer { //使用单例模式, 使用饿汉式 private static DVDPlayer instance = new DVDPlayer(); public static DVDPlayer getInstanc() { return instance; } public void on() { System.out.println(\" dvd on \"); } public void off() { System.out.println(\" dvd off \"); } public void play() { System.out.println(\" dvd is playing \"); } //.... public void pause() { System.out.println(\" dvd pause ..\"); } } public class TheaterLight { private static TheaterLight instance = new TheaterLight(); public static TheaterLight getInstance() { return instance; } public void on() { System.out.println(\" TheaterLight on \"); } public void off() { System.out.println(\" TheaterLight off \"); } public void dim() { System.out.println(\" TheaterLight dim.. \"); } public void bright() { System.out.println(\" TheaterLight bright.. \"); } } public class Projector { private static Projector instance = new Projector(); public static Projector getInstance() { return instance; } public void on() { System.out.println(\" Projector on \"); } public void off() { System.out.println(\" Projector ff \"); } public void focus() { System.out.println(\" Projector is Projector \"); } //... } public class Popcorn { private static Popcorn instance = new Popcorn(); public static Popcorn getInstance() { return instance; } public void on() { System.out.println(\" popcorn on \"); } public void off() { System.out.println(\" popcorn ff \"); } public void pop() { System.out.println(\" popcorn is poping \"); } } public class Screen { private static Screen instance = new Screen(); public static Screen getInstance() { return instance; } public void up() { System.out.println(\" Screen up \"); } public void down() { System.out.println(\" Screen down \"); } } 外观模式在MyBatis框架应用的源码分析 Mybatis中的Configuration去创建MetaObject对象使用到外观模式 mybatis中使用外观模式角色类图 public class Configuration { protected ReflectorFactory reflectorFactory = new DefaultReflectorFactory(); protected","date":"2022-12-05","objectID":"/blog/20221205_designpatterns/:4:11","tags":["Java","coding","principle"],"title":"设计模式","uri":"/blog/20221205_designpatterns/"},{"categories":["Technology"],"content":"享元模式 传统方法 展示网站项目需求 小型的外包项目，给客户A做一个产品展示网站，客户A的朋友感觉效果不错，也希望做这样的产品展示网站，但是要求都有些不同： 客户要求以新闻的形式发布 有客户人要求以博客的形式发布 有客户希望以微信公众号的形式发布 传统方案解决网站展现项目 直觉复制粘贴一份，然后根据客户不同要求，进行定制修改 给每个网站租用一个空间 方案设计示意图如下： 展示网站方案设计示意图 传统方案解决网站展现项目问题分析 需要的网站结构相似度很高，而且都不是高访问量网站，如果分成多个虚拟空间来处理，相当于一个相同的网站的实例对象有很多，造成服务器的资源浪费 解决思路：整合到一个网站中，共享其相关的代码和数据，对于硬盘、内存、CPu、数据库空间等服务器资源都可以达到共享，减少服务器资源 对于上面代码来说，由于是一份实例，维护和扩展都更加容易 上面的解决思路就可以使用享元模式来解决 享元模式 基本介绍 享元模式（Flyweight Pattern）也叫蝇量模式，运用共享技术有效地支持大量细粒度的对象 常用于系统底层开发，解决系统的性能问题。像数据库连接池，里面都是创建好的连接对象，在这些连接对象中我们需要的则直接拿来用，避免重新创建，如果没有我们需要的，则创建一个 享元模式能够解决重复对象的内存浪费问题，当系统中有大量相似对象，需要缓存池时。不需总是创建新对象，可以从缓存池里拿。这样可以降低系统内存，同时提高效率 享元模式经典的应用常见就是池技术了，String常量池、数据库连接池、缓冲池等等都是享元模式的应用，享元吗模式是池技术的重要实现方式 String常量池 享元模式的原理类图 享元模式原理类图 享元模式的角色及职责 FlyWeight是抽象的享元角色，它是产品的抽象类，同时定义出对象的外部状态和内部状态的接口或实现 ConcreteFlyWeight是具体的享元角色，是具体的产品类，实现抽象角色定义相关业务 UnSharedConcreteFlyWeight是不可共享的角色，一般不会出现在享元工厂 FlyWeightFactory享元工厂类，用于创建一个池容器（集合），同时提供从池中获取对象方法 内部状态和外部状态 比如围棋、五子棋、跳棋、它们都有大量的棋子对象，围棋和五子棋只有黑白两色，跳棋颜色多一点，所以棋子颜色就是棋子的内部状态；而各个棋子之间的差别就是位置的不同，当我们落子后，落子颜色是定的，但位置是变化的，所以棋子坐标就是棋子的外部状态 享元模式提出两个要求：细粒度和共享对象。这里就涉及到内部状态和外部状态了，即将对象的信息分为两个部分，内部状态和外部状态 内部状态指对象共享出来的信息，存储在享元对象内部且不会随环境的改变而变化 外部状态指对象得以依赖的一个标记，是随环境改变而变化的、不可共享的状态 举个例子：围棋理论上有361个空位可以放棋子，每个棋盘都有可能有两三百个棋子对象产生，因为内存空间有限，一台服务器很难支持更多的玩家玩围棋游戏，如果用享元模式来处理棋子，那么棋子对象就可以减少到只有两个实例，这样就很好的解决了对象的开销问题 享元模式解决网站展现项目应用实例 享元模式解决网站展现类图 import java.util.HashMap; // 网站工厂类，根据需要返回压一个网站 public class WebSiteFactory { //集合， 充当池的作用 private HashMap\u003cString, ConcreteWebSite\u003e pool = new HashMap\u003c\u003e(); //根据网站的类型，返回一个网站, 如果没有就创建一个网站，并放入到池中,并返回 public WebSite getWebSiteCategory(String type) { if(!pool.containsKey(type)) { //就创建一个网站，并放入到池中 pool.put(type, new ConcreteWebSite(type)); } return (WebSite)pool.get(type); } //获取网站分类的总数 (池中有多少个网站类型) public int getWebSiteCount() { return pool.size(); } } public abstract class WebSite { public abstract void use(User user);//抽象方法 } //具体网站 public class ConcreteWebSite extends WebSite { //共享的部分，内部状态 private String type = \"\"; //网站发布的形式(类型) //构造器 public ConcreteWebSite(String type) { this.type = type; } @Override public void use(User user) { // TODO Auto-generated method stub System.out.println(\"网站的发布形式为:\" + type + \" 在使用中 .. 使用者是\" + user.getName()); } } public class User { private String name; public User(String name) { super(); this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } } public class Client { public static void main(String[] args) { // TODO Auto-generated method stub // 创建一个工厂类 WebSiteFactory factory = new WebSiteFactory(); // 客户要一个以新闻形式发布的网站 WebSite webSite1 = factory.getWebSiteCategory(\"新闻\"); webSite1.use(new User(\"tom\")); // 客户要一个以博客形式发布的网站 WebSite webSite2 = factory.getWebSiteCategory(\"博客\"); webSite2.use(new User(\"jack\")); // 客户要一个以博客形式发布的网站 WebSite webSite3 = factory.getWebSiteCategory(\"博客\"); webSite3.use(new User(\"smith\")); // 客户要一个以博客形式发布的网站 WebSite webSite4 = factory.getWebSiteCategory(\"博客\"); webSite4.use(new User(\"king\")); System.out.println(\"网站的分类共=\" + factory.getWebSiteCount()); } } 享元模式在JDK-Interge的应用源码分析 public class FlyWeight { public static void main(String[] args) { // TODO Auto-generated method stub //如果 Integer.valueOf(x) x 在 -128 --- 127 直接，就是使用享元模式返回,如果不在 //范围类，则仍然 new //小结: //1. 在valueOf 方法中，先判断值是否在 IntegerCache 中，如果不在，就创建新的Integer(new), 否则，就直接从 缓存池返回 //2. valueOf 方法，就使用到享元模式 //3. 如果使用valueOf 方法得到一个Integer 实例，范围在 -128 - 127 ，执行速度比 new 快 Integer x = Integer.valueOf(127); // 得到 x实例，类型 Integer Integer y = new Integer(127); // 得到 y 实例，类型 Integer Integer z = Integer.valueOf(127);//.. Integer w = new Integer(127); System.out.println(x.equals(y)); // 大小，true System.out.println(x == y ); // false System.out.println(x == z ); // true System.out.println(w == x ); // false System.out.println(w == y ); // false Integer x1 = Integer.valueOf(200); Integer x2 = Integer.valueOf(200); System.out.println(\"x1==x2\" + (x1 == x2)); // false } } 享元模式的注意事项和细节 享元模式 在享元模式这样理解，“享”就表示共享，“元”表示对象 系统中有大量对象，这些对象消耗大量内存，并且对象的状态大部分可以外部化时，我们就可以考虑选用享元模式 用唯一标识码判断，如果在内存中有，则返回这个唯","date":"2022-12-05","objectID":"/blog/20221205_designpatterns/:4:12","tags":["Java","coding","principle"],"title":"设计模式","uri":"/blog/20221205_designpatterns/"},{"categories":["Technology"],"content":"代理模式 基本介绍 代理模式(Proxy)：为一个对象提供一个替身，以控制对这个对象的访问。即通过代理对象访问目标对象，这样做的好处是：可以在目标对象实现的基础上，增强额外的功能操作，即扩展目标对象的功能。 被代理的对象可以是远程对象、创建开销大的对象或需要安全控制的对象。 代理模式有不同的形式，主要有三种：静态代理、动态代理（JDK代理、接口代理）和Cglib代理（可以在内存动态的创建对象，而不需要实现接口，它是属于动态代理的范畴） 代理模式示意图如下： 代理模式示意图 静态代理 基本介绍 静态代理在使用时，需要定义接口或者父类，被代理对象（即目标对象）与代理对象一起实现相同的接口或者是继承相同父类 应用实例 具体要求 定义一个接口：ITeacherDao 目标对象TeacherDao实现接口ITeacherDAO 使用静态代理方式，就需要在代理对象TeacherDAOProxy中也实现ITeacherDAO 调用的时候通过调用代理对象的方法来调用目标对象 特别提醒：代理对象与目标对象要实现相同的接口，然后通过调用相同的方法来调用目标对象的方法 静态代理分类图解（类图） //代理对象,静态代理 public class TeacherDaoProxy implements ITeacherDao{ private ITeacherDao target; // 目标对象，通过接口来聚合 //构造器 public TeacherDaoProxy(ITeacherDao target) { this.target = target; } @Override public void teach() { // TODO Auto-generated method stub System.out.println(\"开始代理 完成某些操作。。。。。 \");//方法 target.teach(); System.out.println(\"提交。。。。。\");//方法 } } //接口 public interface ITeacherDao { void teach(); // 授课的方法 } public class TeacherDao implements ITeacherDao { @Override public void teach() { // TODO Auto-generated method stub System.out.println(\" 老师授课中 。。。。。\"); } } public class Client { public static void main(String[] args) { // TODO Auto-generated method stub //创建目标对象(被代理对象) TeacherDao teacherDao = new TeacherDao(); //创建代理对象, 同时将被代理对象传递给代理对象 TeacherDaoProxy teacherDaoProxy = new TeacherDaoProxy(teacherDao); //通过代理对象，调用到被代理对象的方法 //即：执行的是代理对象的方法，代理对象再去调用目标对象的方法 teacherDaoProxy.teach(); } } 静态代理优缺点 优点：在不修改目标对象的功能前提下，能通过代理对象对目标功能扩展 缺点：因为代理对象需要与目标对象实现一样的接口，所以会有很多代理类 一旦接口增加方法，目标对象与代理对象都要维护 动态代理 基本介绍 代理对象，不需要实现接口，但是目标对象要实现接口，否则不能用动态代理 代理对象的生成，是利用JDK的API，动态的在内存中构建代理对象 动态代理也叫做：JDK代理、接口代理 JDK中生成代理对象的API 代理类所在包：java.lang.reflect.Proxy JDK实现代理只需要使用newProxyInstance方法，但是该方法需要接收三个参数，完成写法如下： static Object newProxyInstance(ClassLoader loader,Class\u003c?\u003e[] interfaces,InvocationHandler handler) 应用实例 将前面的静态代理该进成动态代理模式（即：JDK代理模式） 动态代理应用实例类图 Cglib代理模式 基本介绍 静态代理和JDK代理模式都要求目标对象是实现一个接口，但是有时候目标对象只是一个单独的对象，并没有实现任何的接口，这个时候可使用目标对象子类来实现代理-\u003e这就是Cglib代理 Cglib代理也叫作子类代理，它是在内存中构建一个字类对象从而实现对目标对象功能扩展，有些书也将Cglib代理归属到动态代理 Cglib是一个强大的高性能的代码生成包，它可以在运行期扩展Java类与实现Java接口，它广泛的被许多AOP的框架使用，例如Spring AOP，实现方法拦截 在AOP编程中如何选择代理模式 目标对象需要实现接口，用JDK代理 目标对象不需要实现接口，用Cglib代理 Cglib包的底层是通过使用字节码处理框架ASM来转换字节码并生成新的类 Cglib代理模式实现步骤 需要引入cglib的jar包 在内存中动态构建字类，注意代理的类不能为final，否则报错（java.lang.IllegalArgumentException） 目标对象的方法如果为final/static，那么就不会被拦截，即不会执行目标对象额外的业务方法 Cglib代理模式应用实例 将前面案例用Cglib代理模式实现 Cglib代理模式应用实例类图 import java.lang.reflect.Method; import net.sf.cglib.proxy.Enhancer; import net.sf.cglib.proxy.MethodInterceptor; import net.sf.cglib.proxy.MethodProxy; public class ProxyFactory implements MethodInterceptor { //维护一个目标对象 private Object target; //构造器，传入一个被代理的对象 public ProxyFactory(Object target) { this.target = target; } //返回一个代理对象: 是 target 对象的代理对象 public Object getProxyInstance() { //1. 创建一个工具类 Enhancer enhancer = new Enhancer(); //2. 设置父类 enhancer.setSuperclass(target.getClass()); //3. 设置回调函数 enhancer.setCallback(this); //4. 创建子类对象，即代理对象 return enhancer.create(); } //重写 intercept 方法，会调用目标对象的方法 @Override public Object intercept(Object arg0, Method method, Object[] args, MethodProxy arg3) throws Throwable { // TODO Auto-generated method stub System.out.println(\"Cglib代理模式 ~~ 开始\"); Object returnVal = method.invoke(target, args); System.out.println(\"Cglib代理模式 ~~ 提交\"); return returnVal; } } public class TeacherDao { public String teach() { System.out.println(\" 老师授课中 ， 我是cglib代理，不需要实现接口 \"); return \"hello\"; } } public class Client { public static void main(String[] args) { // TODO Auto-generated method stub //创建目标对象 TeacherDao target = new TeacherDao(); //获取到代理对象，并且将目标对象传递给代理对象 TeacherDao proxyInstance = (TeacherDao)new ProxyFactory(target).getProxyInstance(); //执行代理对象的方法，触发intecept 方法，从而实现 对目标对象的调用 String res = proxyInstance.teach(); System.out.println(\"res=\" + res); } } 代理模式（Proxy）的变体 防火墙代理 内网通过代理穿透防火墙，实现对公网的访问 缓存代理 比如：当请求图片文件等资源时，先到缓存代理取，如果取到资源则OK，如果取不到资源，再到公网或者数据库中取，然后缓存 远程代理 远程对象的本地代表，通过它可以把远程对象当本地对象来调用。远程代理通过网络和真正的远程对象沟通信息 同步代理 主要使用在多线程编程中，完成多线程间同步工作 ","date":"2022-12-05","objectID":"/blog/20221205_designpatterns/:4:13","tags":["Java","coding","principle"],"title":"设计模式","uri":"/blog/20221205_designpatterns/"},{"categories":["Technology"],"content":"模版方法模式 豆浆制作问题 编写制作豆浆的程序，说明如下： 制作豆浆的流程 选材-\u003e添加配料-\u003e浸泡-\u003e放到豆浆机打碎 通过添加不同的配料，可以制作出不同口味的豆浆 选材、浸泡和放到豆浆机打碎这几个步骤对于制作每种口味的豆浆都是一样的 请使用模版方法模式完成（说明：因为模版方法模式，比较简单，很容易就想到这个方案，因此就直接使用，不再使用传统方案引出模版方法模式） 模版方法模式基本介绍 模版方法模式（Template Method Pattern），又叫模版模式（Template Pattern），在一个抽象类公开定义了执行它的方法的模版。它的字类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。 简单说，模版方法模式定义了一个操作中的算法骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构，就可以重定义该算法的某些特定步骤 这种类型的设计模式属于-\u003e行为型模式 模版方法模式原理类图 模版方法模式原理类图 模版方法模式的角色及职责 AbstractClass 抽象类，类中实现了模版方法（Template），定义了算法的骨架，具体子类需要去实现其它的抽象方法 operation2，3，4 ConcreteClass实现抽象方法operation2，3，4，以完成算法中特定子类的步骤 模版方法模式解决豆浆制作问题 模版方法模式解决豆浆制作问题类图 //抽象类，表示豆浆 public abstract class SoyaMilk { //模板方法, make , 模板方法可以做成final , 不让子类去覆盖. final void make() { select(); addCondiments(); soak(); beat(); } //选材料 void select() { System.out.println(\"第一步：选择好的新鲜黄豆 \"); } //添加不同的配料， 抽象方法, 子类具体实现 abstract void addCondiments(); //浸泡 void soak() { System.out.println(\"第三步， 黄豆和配料开始浸泡， 需要3小时 \"); } void beat() { System.out.println(\"第四步：黄豆和配料放到豆浆机去打碎 \"); } } public class RedBeanSoyaMilk extends SoyaMilk { @Override void addCondiments() { // TODO Auto-generated method stub System.out.println(\" 加入上好的红豆 \"); } } public class PeanutSoyaMilk extends SoyaMilk { @Override void addCondiments() { // TODO Auto-generated method stub System.out.println(\" 加入上好的花生 \"); } } public class Client { public static void main(String[] args) { // TODO Auto-generated method stub //制作红豆豆浆 System.out.println(\"----制作红豆豆浆----\"); SoyaMilk redBeanSoyaMilk = new RedBeanSoyaMilk(); redBeanSoyaMilk.make(); System.out.println(\"----制作花生豆浆----\"); SoyaMilk peanutSoyaMilk = new PeanutSoyaMilk(); peanutSoyaMilk.make(); } } 模版方法模式的钩子方法 在模版方法模式的父类中，我们定义一个方法，它默认不做任何事，子类可以视情况要不要覆盖它，该方法称为“钩子” 还是用上面做豆浆的例子来讲解，比如，我们还希望制作纯豆浆，不添加任何的配料，请使用钩子方法对前面的模版方法进行改造 //抽象类，表示豆浆 public abstract class SoyaMilk { //模板方法, make , 模板方法可以做成final , 不让子类去覆盖. final void make() { select(); if(customerWantCondiments()) { addCondiments(); } soak(); beat(); } //选材料 void select() { System.out.println(\"第一步：选择好的新鲜黄豆 \"); } //添加不同的配料， 抽象方法, 子类具体实现 abstract void addCondiments(); //浸泡 void soak() { System.out.println(\"第三步， 黄豆和配料开始浸泡， 需要3小时 \"); } void beat() { System.out.println(\"第四步：黄豆和配料放到豆浆机去打碎 \"); } //钩子方法，决定是否需要添加配料 boolean customerWantCondiments() { return true; } } public class RedBeanSoyaMilk extends SoyaMilk { @Override void addCondiments() { // TODO Auto-generated method stub System.out.println(\" 加入上好的红豆 \"); } } public class PureSoyaMilk extends SoyaMilk{ @Override void addCondiments() { // TODO Auto-generated method stub //空实现 } @Override boolean customerWantCondiments() { // TODO Auto-generated method stub return false; } } public class PeanutSoyaMilk extends SoyaMilk { @Override void addCondiments() { // TODO Auto-generated method stub System.out.println(\" 加入上好的花生 \"); } } public class Client { public static void main(String[] args) { // TODO Auto-generated method stub //制作红豆豆浆 System.out.println(\"----制作红豆豆浆----\"); SoyaMilk redBeanSoyaMilk = new RedBeanSoyaMilk(); redBeanSoyaMilk.make(); System.out.println(\"----制作花生豆浆----\"); SoyaMilk peanutSoyaMilk = new PeanutSoyaMilk(); peanutSoyaMilk.make(); System.out.println(\"----制作纯豆浆----\"); SoyaMilk pureSoyaMilk = new PureSoyaMilk(); pureSoyaMilk.make(); } } 模版方法模式在Spring框架应用的源码分析 Spring IOC容器初始化时运用到的模版方法模式 Spring源码使用模版方法模式类图 模版方法模式注意事项和细节 模版方法模式 基本思想：算法只存在于一个地方，也就是在父类中，容易修改。需要修改算法时，只要修改父类的模版方法或者已经实现的某些步骤，子类就会继承这些修改 实现了最大化代码复用。父类的模版方法和已经实现的某些步骤会被子类继承而直接使用 即统一了算法，也提供了很大的灵活性。父类的模版方法确保了算法的结构保持不变，同时由子类提供部分步骤的实现 该模式的不足之处：每一个不同的实现都需要一个子类实现，导致类的个数增加，使得系统更加庞大 一般模版方法都加上final关键字，防止子类重写模版方法 模版方法模式使用场景：当要完成在某个过程，该过程要执行一系列步骤，这一系列的步骤基本相同，但其个别步骤在实现时可能不同，通常考虑用模版方法模式来处理 ","date":"2022-12-05","objectID":"/blog/20221205_designpatterns/:4:14","tags":["Java","coding","principle"],"title":"设计模式","uri":"/blog/20221205_designpatterns/"},{"categories":["Technology"],"content":"命令模式 智能生活项目 智能生活项目具体需求 我们买了一套智能家电，有照明灯、风扇冰箱、洗衣机，我们只要在手机上安装app就可以控制对这些家电工作 这些职能家电来自不同的厂家，我们不想针对每一种家电都安装一个App，分别控制，我们希望只要一个app就可以控制全部职能家电 要实现一个app控制所有智能家电的需求，则每个智能家电厂家都要提供一个统一的接口给app调用，这时就可以考虑使用命令模式 命令模式可将“动作的请求者”从“动作的执行者”对象中解耦出来 在上面例子中，动作的请求者是手机app，动作的执行者是每个厂商的一个家电产品 命令模式基本介绍 命令模式（Command Pattern）：在软件设计中，我们经常需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个，我们只需在程序运行时指定具体的请求接收者即可，此时，可以使用命令模式来进行设计 命令模式使得请求发送者与请求接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活，实现解耦 在命令模式中，会将一个请求封装为一个对象，以便使用不同参数来表示不同的请求（即命名），同时命令模式也支持可撤销的操作 通俗易懂的理解：将军发布命令，士兵去执行。其中有几个角色：将军（命令发布者）、士兵（命令的具体执行者）、命令（连接将军和士兵）。Invoker是调用者（将军），Receiver是被调用者（士兵），MyCommand是命令，实现了Command接口，持有接收对象 命令模式的原理类图 命令模式的原理类图 命令模式的角色及职责 Invoker：是调用者角色 Command：是命令角色，需要执行的所有命令都在这里，可以是接口或抽象类 Receiver：是接收者角色，知道如何实施和执行一个请求相关的操作 ConcreteCommand：将一个接收者对象与一个动作绑定，调用接收者相应的操作，实现execute 命令模式解决智能生活项目 命令模式解决智能生活项目类图 //创建命令接口 public interface Command { //执行动作(操作) public void execute(); //撤销动作(操作) public void undo(); } /** * 没有任何命令，即空执行: 用于初始化每个按钮, 当调用空命令时，对象什么都不做 * 其实，这样是一种设计模式, 可以省掉对空判断 * @author Administrator * */ public class NoCommand implements Command { @Override public void execute() { // TODO Auto-generated method stub } @Override public void undo() { // TODO Auto-generated method stub } } public class LightOffCommand implements Command { // 聚合LightReceiver LightReceiver light; // 构造器 public LightOffCommand(LightReceiver light) { super(); this.light = light; } @Override public void execute() { // TODO Auto-generated method stub // 调用接收者的方法 light.off(); } @Override public void undo() { // TODO Auto-generated method stub // 调用接收者的方法 light.on(); } } public class LightOnCommand implements Command { //聚合LightReceiver LightReceiver light; //构造器 public LightOnCommand(LightReceiver light) { super(); this.light = light; } @Override public void execute() { // TODO Auto-generated method stub //调用接收者的方法 light.on(); } @Override public void undo() { // TODO Auto-generated method stub //调用接收者的方法 light.off(); } } public class LightReceiver { public void on() { System.out.println(\" 电灯打开了.. \"); } public void off() { System.out.println(\" 电灯关闭了.. \"); } } public class RemoteController { // 开 按钮的命令数组 Command[] onCommands; Command[] offCommands; // 执行撤销的命令 Command undoCommand; // 构造器，完成对按钮初始化 public RemoteController() { onCommands = new Command[5]; offCommands = new Command[5]; for (int i = 0; i \u003c 5; i++) { onCommands[i] = new NoCommand(); offCommands[i] = new NoCommand(); } } // 给我们的按钮设置你需要的命令 public void setCommand(int no, Command onCommand, Command offCommand) { onCommands[no] = onCommand; offCommands[no] = offCommand; } // 按下开按钮 public void onButtonWasPushed(int no) { // no 0 // 找到你按下的开的按钮， 并调用对应方法 onCommands[no].execute(); // 记录这次的操作，用于撤销 undoCommand = onCommands[no]; } // 按下开按钮 public void offButtonWasPushed(int no) { // no 0 // 找到你按下的关的按钮， 并调用对应方法 offCommands[no].execute(); // 记录这次的操作，用于撤销 undoCommand = offCommands[no]; } // 按下撤销按钮 public void undoButtonWasPushed() { undoCommand.undo(); } } public class TVOffCommand implements Command { // 聚合TVReceiver TVReceiver tv; // 构造器 public TVOffCommand(TVReceiver tv) { super(); this.tv = tv; } @Override public void execute() { // TODO Auto-generated method stub // 调用接收者的方法 tv.off(); } @Override public void undo() { // TODO Auto-generated method stub // 调用接收者的方法 tv.on(); } } public class TVOnCommand implements Command { // 聚合TVReceiver TVReceiver tv; // 构造器 public TVOnCommand(TVReceiver tv) { super(); this.tv = tv; } @Override public void execute() { // TODO Auto-generated method stub // 调用接收者的方法 tv.on(); } @Override public void undo() { // TODO Auto-generated method stub // 调用接收者的方法 tv.off(); } } public class TVReceiver { public void on() { System.out.println(\" 电视机打开了.. \"); } public void off() { System.out.println(\" 电视机关闭了.. \"); } } public class Client { public static void main(String[] args) { // TODO Auto-generated method stub //使用命令设计模式，完成通过遥控器，对电灯的操作 //创建电灯的对象(接受者) LightReceiver lightReceiver = new LightReceiver(); //创建电灯相关的开关命令 LightOnCommand lightOnCommand = new LightOnCommand(lightReceive","date":"2022-12-05","objectID":"/blog/20221205_designpatterns/:4:15","tags":["Java","coding","principle"],"title":"设计模式","uri":"/blog/20221205_designpatterns/"},{"categories":["Technology"],"content":"访问者模式 评测系统 评测系统需求 将观众分为男人和女人，对歌手进行评测，当看完某个歌手表演后，得到他们对该歌手不同的评价（评价有不同的种类，比如成功、失败等） 传统方法 传统方式的问题分析 评测系统传统方式解决 如果系统比较小，还是OK的，但是考虑系统增加越来越多新的功能时，对代码改动比较大，违反了OCP原则，不利于维护 扩展性不好，比如增加了新的人员类型，或者管理方法，都不好做 引出我们会使用新的设计模式-\u003e访问者模式 访问者模式 基本介绍 访问者模式（Visitor Patter），封装一些作用于某种数据结构的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作 主要将数据结构与数据操作分离，解决数据结构和操作耦合性问题 访问者模式的基本工作原理是：在被访问的类里面加一个对外提供接待访问者的接口 访问者模式应用场景是：需要对一个对象结构中的对象进行很多不同操作（这些操作彼此没有关联），同时需要避免让这些操作“污染”这些对象的类，可以选用访问者模式解决 访问者模式的原理类图 访问者模式的原理类图 访问者模式的角色及职责 Visitor：是抽象访问者，为该对象结构中的ConcreteElement的每一个类声明一个visit操作 ConcreteVisitor：是一个具体的访问值，实现每一个有Visitor声明的操作，是每个操作实现的部分 ObjectStructure：能枚举它的元素，可以提供一个高层的接口，用来允许访问者访问元素 Element：定义一个accept方法，接收一个访问者对象 ConcreteElement为具体元素，实现了accept方法 访问者模式应用实例 访问者模式应用实例 public abstract class Action { //得到男性 的测评 public abstract void getManResult(Man man); //得到女的 测评 public abstract void getWomanResult(Woman woman); } public class Fail extends Action { @Override public void getManResult(Man man) { // TODO Auto-generated method stub System.out.println(\" 男人给的评价该歌手失败 !\"); } @Override public void getWomanResult(Woman woman) { // TODO Auto-generated method stub System.out.println(\" 女人给的评价该歌手失败 !\"); } } public abstract class Person { //提供一个方法，让访问者可以访问 public abstract void accept(Action action); } public class Man extends Person { @Override public void accept(Action action) { // TODO Auto-generated method stub action.getManResult(this); } } //说明 //1. 这里我们使用到了双分派, 即首先在客户端程序中，将具体状态作为参数传递Woman中(第一次分派) //2. 然后Woman 类调用作为参数的 \"具体方法\" 中方法getWomanResult, 同时将自己(this)作为参数 // 传入，完成第二次的分派 public class Woman extends Person{ @Override public void accept(Action action) { // TODO Auto-generated method stub action.getWomanResult(this); } } public class Success extends Action { @Override public void getManResult(Man man) { // TODO Auto-generated method stub System.out.println(\" 男人给的评价该歌手很成功 !\"); } @Override public void getWomanResult(Woman woman) { // TODO Auto-generated method stub System.out.println(\" 女人给的评价该歌手很成功 !\"); } } import java.util.LinkedList; import java.util.List; //数据结构，管理很多人（Man , Woman） public class ObjectStructure { //维护了一个集合 private List\u003cPerson\u003e persons = new LinkedList\u003c\u003e(); //增加到list public void attach(Person p) { persons.add(p); } //移除 public void detach(Person p) { persons.remove(p); } //显示测评情况 public void display(Action action) { for(Person p: persons) { p.accept(action); } } } public class Wait extends Action { @Override public void getManResult(Man man) { // TODO Auto-generated method stub System.out.println(\" 男人给的评价是该歌手待定 ..\"); } @Override public void getWomanResult(Woman woman) { // TODO Auto-generated method stub System.out.println(\" 女人给的评价是该歌手待定 ..\"); } } public class Client { public static void main(String[] args) { // TODO Auto-generated method stub //创建ObjectStructure ObjectStructure objectStructure = new ObjectStructure(); objectStructure.attach(new Man()); objectStructure.attach(new Woman()); //成功 Success success = new Success(); objectStructure.display(success); System.out.println(\"===============\"); Fail fail = new Fail(); objectStructure.display(fail); System.out.println(\"=======给的是待定的测评========\"); Wait wait = new Wait(); objectStructure.display(wait); } } 应用实例小结 上面提到了双分派，所谓双分派是指不管类怎么变化，我们都能找到期望的方法运行。 双分派意味着得到执行的操作取决于请求的种类和两个接收者的类型 对于以上实例为例，假设我们要添加一个Wait的状态类，考察Man类和Woman类的反应，由于使用了双分派，只需增加一个Action子类即可在客户端调用即可，不需要改动任何其他类的代码。 访问者模式的注意事项和细节 访问者模式 优点 访问者模式符合单一职责原则，让程序具有优秀的扩展性、灵活性非常高 访问者模式可以对功能进行统一，可以做报表、UI、拦截器与过滤器，适用于数据结构相对稳定的系统 缺点 具体元素对访问者公布细节，也就是说访问者关注了其他类的内部细节，这是迪米特法则所不建议的，这样就造成了具体元素变更比较困难 违背了依赖倒转原则。访问者依赖的是具体元素，而不是抽象元素 因此，如果一个系统有比较稳定的数据结构，又有经常变化的功能需求，那么访问者模式就是比较合适的 ","date":"2022-12-05","objectID":"/blog/20221205_designpatterns/:4:16","tags":["Java","coding","principle"],"title":"设计模式","uri":"/blog/20221205_designpatterns/"},{"categories":["Technology"],"content":"迭代器模式 学校院系展示系统 编写程序展示一个学校院系结构：要求在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系。功能展示如下所示。 学校院系构成 传统的设计方案 学校院系构成传统设计方案 传统方式的问题分析 将学院看做是学校的子类，系是学院的子类，这样实际上是站在组织大小来进行分层次的 实际上我们的需求是：在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系，因此这种方案，不能很好实现遍历的操作 解决方案 -\u003e 迭代器模式 迭代器模式 基本介绍 迭代器模式（Iterator Pattern）是常用的设计模式，属于行为型模式 如果我们的集合元素使用不同的方式实现，有数组，还有Java的集合类，或者还有其他方式，当客户端要遍历这些集合元素的时候就要使用多种遍历方式，而且还会暴露元素的内部结构，可以考虑使用迭代器模式解决 迭代器模式，提供一种遍历集合元素的统一接口，用一致的方式遍历集合元素，不需要知道集合对象的底层表示，即：不暴露其内部的结构 迭代器模式原理类图 迭代器模式的角色及职责 Iterator：迭代器接口，是系统提供，含义 hasNext，next，remove ConcreteIterator：具体的迭代器类，管理迭代 Aggregate：一个统一的聚合接口，将客户端和具体聚合解耦 ConcreteAggreage：具体的聚合持有对象集合，并提供一个方法，返回一个迭代器，该迭代器可以正确遍历集合 Client：客户端，通过 Iterator 和 Aggregate 依赖子类 迭代器模式应用实例 迭代器模式应用实例 import java.util.Iterator; public interface College { public String getName(); //增加系的方法 public void addDepartment(String name, String desc); //返回一个迭代器,遍历 public Iterator createIterator(); } public class Department { private String name; private String desc; public Department(String name, String desc) { super(); this.name = name; this.desc = desc; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getDesc() { return desc; } public void setDesc(String desc) { this.desc = desc; } } import java.util.Iterator; import java.util.List; public class OutPutImpl { //学院集合 List\u003cCollege\u003e collegeList; public OutPutImpl(List\u003cCollege\u003e collegeList) { this.collegeList = collegeList; } //遍历所有学院,然后调用printDepartment 输出各个学院的系 public void printCollege() { //从collegeList 取出所有学院, Java 中的 List 已经实现Iterator Iterator\u003cCollege\u003e iterator = collegeList.iterator(); while(iterator.hasNext()) { //取出一个学院 College college = iterator.next(); System.out.println(\"=== \"+college.getName() +\"=====\" ); printDepartment(college.createIterator()); //得到对应迭代器 } } //输出 学院输出 系 public void printDepartment(Iterator iterator) { while(iterator.hasNext()) { Department d = (Department)iterator.next(); System.out.println(d.getName()); } } } import java.util.ArrayList; import java.util.Iterator; import java.util.List; public class InfoCollege implements College { List\u003cDepartment\u003e departmentList; public InfoCollege() { departmentList = new ArrayList\u003cDepartment\u003e(); addDepartment(\"信息安全专业\", \" 信息安全专业 \"); addDepartment(\"网络安全专业\", \" 网络安全专业 \"); addDepartment(\"服务器安全专业\", \" 服务器安全专业 \"); } @Override public String getName() { // TODO Auto-generated method stub return \"信息工程学院\"; } @Override public void addDepartment(String name, String desc) { // TODO Auto-generated method stub Department department = new Department(name, desc); departmentList.add(department); } @Override public Iterator createIterator() { // TODO Auto-generated method stub return new InfoColleageIterator(departmentList); } } import java.util.Iterator; import java.util.List; public class InfoColleageIterator implements Iterator { List\u003cDepartment\u003e departmentList; // 信息工程学院是以List方式存放系 int index = -1;//索引 public InfoColleageIterator(List\u003cDepartment\u003e departmentList) { this.departmentList = departmentList; } //判断list中还有没有下一个元素 @Override public boolean hasNext() { // TODO Auto-generated method stub if(index \u003e= departmentList.size() - 1) { return false; } else { index += 1; return true; } } @Override public Object next() { // TODO Auto-generated method stub return departmentList.get(index); } //空实现remove public void remove() { } } import java.util.Iterator; public class ComputerCollege implements College { Department[] departments; int numOfDepartment = 0 ;// 保存当前数组的对象个数 public ComputerCollege() { departments = new Department[5]; addDepartment(\"Java专业\", \" Java专业 \"); addDepartment(\"PHP专业\", \" PHP专业 \"); addDepartment(\"大数据专业\", \" 大数据专业 \"); } @Override public String getName() { // TODO Auto-generated method stub return \"计算机学院\"; } @Override public void addDepartment(String name, String desc) { // TODO Auto-generated method stub Department department = new Department(name, desc); departments[numOfDepartment] = department; numOfDepartment += 1; } @Override public Iterator createIterator() { // TODO Auto-generated ","date":"2022-12-05","objectID":"/blog/20221205_designpatterns/:4:17","tags":["Java","coding","principle"],"title":"设计模式","uri":"/blog/20221205_designpatterns/"},{"categories":["Technology"],"content":"观察者模式 天气预报项目 具体需求如下： 气象站可以将每天测量到的温度、湿度、气压等等以公告的形式发布出去（比如发布到自己的网站或第三方） 需要设计开放型API，便于其他第三方也能接入气象站获取数据 提供温度、气压和湿度的接口 测量数据更新时，要能实时的通知给第三方 传统方案 通过对气象站项目的分析，我们可以初步设计出一个WeatherData类 weather 说明： 通过getXxx方法，可以让第三方接入，并得到相关信息 当数据有更新时，气象站通过调用 dataChange() 去个更新数据，当第三方再次获取时，就能得到最新数据，当然也可以推送 解决示意图： 解决示意图解决示意图 CurrentConditions(当前的天气情况) 可以理解成是我们气象局的网站 // 推送 /** * 显示当前天气情况（可以理解成是气象站自己的网站） * @author Administrator * */ public class CurrentConditions { // 温度，气压，湿度 private float temperature; private float pressure; private float humidity; //更新 天气情况，是由 WeatherData 来调用，我使用推送模式 public void update(float temperature, float pressure, float humidity) { this.temperature = temperature; this.pressure = pressure; this.humidity = humidity; display(); } //显示 public void display() { System.out.println(\"***Today mTemperature: \" + temperature + \"***\"); System.out.println(\"***Today mPressure: \" + pressure + \"***\"); System.out.println(\"***Today mHumidity: \" + humidity + \"***\"); } } /** * 类是核心 * 1. 包含最新的天气情况信息 * 2. 含有 CurrentConditions 对象 * 3. 当数据有更新时，就主动的调用 CurrentConditions对象update方法(含 display), 这样他们（接入方）就看到最新的信息 * @author Administrator * */ public class WeatherData { private float temperatrue; private float pressure; private float humidity; private CurrentConditions currentConditions; //加入新的第三方 public WeatherData(CurrentConditions currentConditions) { this.currentConditions = currentConditions; } public float getTemperature() { return temperatrue; } public float getPressure() { return pressure; } public float getHumidity() { return humidity; } public void dataChange() { //调用 接入方的 update currentConditions.update(getTemperature(), getPressure(), getHumidity()); } //当数据有更新时，就调用 setData public void setData(float temperature, float pressure, float humidity) { this.temperatrue = temperature; this.pressure = pressure; this.humidity = humidity; //调用dataChange， 将最新的信息 推送给 接入方 currentConditions dataChange(); } } public class Client { public static void main(String[] args) { //创建接入方 currentConditions CurrentConditions currentConditions = new CurrentConditions(); //创建 WeatherData 并将 接入方 currentConditions 传递到 WeatherData中 WeatherData weatherData = new WeatherData(currentConditions); //更新天气情况 weatherData.setData(30, 150, 40); //天气情况变化 System.out.println(\"============天气情况变化=============\"); weatherData.setData(40, 160, 20); } } 传统方案问题分析 其他第三方接入气象站获取数据的问题 无法在运行时动态的添加第三方（新浪网站） 违反 OCP 原则 -\u003e 观察者模式 // 在WeatherData中，当增加一个第三方，都需要创建一个对应的第三方的公告板对象，并加入到dataChange，不利于维护也不是动态加入 public void dataChange(){ currentConditions.update(getTemperature,getPressure,getHumidity()); } 观察者模式 基本介绍 观察者模式（Observer Pattern）：指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式，它是对象行为型模式。 观察者模式原理 观察者模式原理-Subject 观察者模式的角色及职责 观察者模式类似用户订购牛奶业务 奶站：Subject 用户：Observer Subject：登记注册、移除和通知 registerObserver 注册 removeObserver 移除 notifyObserver 通知所有的注册用户，根据不同的需求，可以是更新数据，让用户来取，也可能是实施推送，根据具体需求定 Observer：接收输入 观察者模式：对象之间多对一依赖的一种设计方案，被依赖的对象为 Subject，依赖的对象为 Observer，Subject 通知 Observer 变化，比如这里的奶站是 Subject，是“1”的一方，用户是 Observer，是“多”的一方 观察者模式应用实例 观察者模式解决天气预报需求 观察者模式解决天气预报需求类图 //观察者接口，有观察者来实现 public interface Observer { public void update(float temperature, float pressure, float humidity); } //接口, 让WeatherData 来实现 public interface Subject { public void registerObserver(Observer o); public void removeObserver(Observer o); public void notifyObservers(); } import java.util.ArrayList; /** * 类是核心 * 1. 包含最新的天气情况信息 * 2. 含有 观察者集合，使用ArrayList管理 * 3. 当数据有更新时，就主动的调用 ArrayList, 通知所有的（接入方）就看到最新的信息 * @author Administrator * */ public class WeatherData implements Subject { private float temperatrue; private float pressure; private float humidity; //观察者集合 private ArrayList\u003cObserver\u003e observers; //加入新的第三方 public WeatherData() { observers = new ArrayList\u003cObserver\u003e(); } public float getTemperature() { return temperatrue; } public float getPressure() { return pressure; } public float getHumidity() { return humidity; } public void dataChange() { //调用 接入方的 update notifyObservers(); } //当数据有更新时，就调用 setData public void setData(float","date":"2022-12-05","objectID":"/blog/20221205_designpatterns/:4:18","tags":["Java","coding","principle"],"title":"设计模式","uri":"/blog/20221205_designpatterns/"},{"categories":["Technology"],"content":"中介者模式 智能家庭管理系统 项目需求： 智能家庭包括各种设备，闹钟、咖啡机、电视机、窗帘等 主人要看电视时，各个设备可以协同工作，自动完成看电视的准备工作，比如流程为：闹钟响起 -\u003e 咖啡机开始做咖啡 -\u003e 窗帘自动落下 -\u003e 电视机开始播放 传统方案 传统设计方案类图 传统设计方案问题分析 当各电器对象有多种状态改变时，相互之间的调用关系会比较复杂 各个电器对象彼此联系，你中有我，我中有你，不利于松耦合 各个电器对象之间所传递的消息（参数），容易混乱 当系统增加一个新的电器对象时，或者执行流程改变时，代码的可维护性、扩展性都不理想 -\u003e 这时可以考虑中介者模式 中介者模式 基本介绍 中介者模式（Mediator Pattern），用一个中介者对象封装一系列的对象交互。中介者使各个对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互 中介者模式属于行为型模式，使代码易于维护 比如 MVC 模式，C（Controller 控制器）是 M（Model 模型）和 V（View 视图）的中介者，在前后端交互时起到了中间人的作用 中介者模式原理类图 中介者模式原理类图 中介者模式中角色及职责 Mediator 就是抽象中介者，定义了同事对象到中介者对象的接口 Colleague 是抽象同事类 ConcreteMediator 具体的中介者对象，实现抽象方法，它需要知道所有的具体同事类，即以一个集合来管理HashMap，并接受某个同事对象消息，完成相应的任务 ConcreteColleague 具体的同事类，会有很多，每个同事只知道自己的行为，而不了解其他同事类的行为（方法），但是它们都依赖中介者对象 中介者模式应用实例 中介者模式解决智能家庭管理类图 public abstract class Mediator { //将给中介者对象，加入到集合中 public abstract void Register(String colleagueName, Colleague colleague); //接收消息, 具体的同事对象发出 public abstract void GetMessage(int stateChange, String colleagueName); public abstract void SendMessage(); } //同事抽象类 public abstract class Colleague { private Mediator mediator; public String name; public Colleague(Mediator mediator, String name) { this.mediator = mediator; this.name = name; } public Mediator GetMediator() { return this.mediator; } public abstract void SendMessage(int stateChange); } //具体的同事类 public class Alarm extends Colleague { //构造器 public Alarm(Mediator mediator, String name) { super(mediator, name); // TODO Auto-generated constructor stub //在创建Alarm 同事对象时，将自己放入到ConcreteMediator 对象中[集合] mediator.Register(name, this); } public void SendAlarm(int stateChange) { SendMessage(stateChange); } @Override public void SendMessage(int stateChange) { // TODO Auto-generated method stub //调用的中介者对象的getMessage this.GetMediator().GetMessage(stateChange, this.name); } } public class TV extends Colleague { public TV(Mediator mediator, String name) { super(mediator, name); // TODO Auto-generated constructor stub mediator.Register(name, this); } @Override public void SendMessage(int stateChange) { // TODO Auto-generated method stub this.GetMediator().GetMessage(stateChange, this.name); } public void StartTv() { // TODO Auto-generated method stub System.out.println(\"It's time to StartTv!\"); } public void StopTv() { // TODO Auto-generated method stub System.out.println(\"StopTv!\"); } } public class Curtains extends Colleague { public Curtains(Mediator mediator, String name) { super(mediator, name); // TODO Auto-generated constructor stub mediator.Register(name, this); } @Override public void SendMessage(int stateChange) { // TODO Auto-generated method stub this.GetMediator().GetMessage(stateChange, this.name); } public void UpCurtains() { System.out.println(\"I am holding Up Curtains!\"); } } import java.util.HashMap; //具体的中介者类 public class ConcreteMediator extends Mediator { //集合，放入所有的同事对象 private HashMap\u003cString, Colleague\u003e colleagueMap; private HashMap\u003cString, String\u003e interMap; public ConcreteMediator() { colleagueMap = new HashMap\u003cString, Colleague\u003e(); interMap = new HashMap\u003cString, String\u003e(); } @Override public void Register(String colleagueName, Colleague colleague) { // TODO Auto-generated method stub colleagueMap.put(colleagueName, colleague); // TODO Auto-generated method stub if (colleague instanceof Alarm) { interMap.put(\"Alarm\", colleagueName); } else if (colleague instanceof CoffeeMachine) { interMap.put(\"CoffeeMachine\", colleagueName); } else if (colleague instanceof TV) { interMap.put(\"TV\", colleagueName); } else if (colleague instanceof Curtains) { interMap.put(\"Curtains\", colleagueName); } } //具体中介者的核心方法 //1. 根据得到消息，完成对应任务 //2. 中介者在这个方法，协调各个具体的同事对象，完成任务 @Override public void GetMessage(int stateChange, String colleagueName) { // TODO Auto-generated method stub //处理闹钟发出的消息 if (colleagueMap.get(colleagueName) instanceof Alarm) { if (stateChange == 0) { ((CoffeeMachine) (colleagueMap.get(interMap .get(\"CoffeeMachine\")))).StartCoffee(); ((TV) (colleagueMap.get(interMap.get(\"TV\")))).StartTv(); } else if (stateChange == 1) { ((TV) (colleagueMap.get(","date":"2022-12-05","objectID":"/blog/20221205_designpatterns/:4:19","tags":["Java","coding","principle"],"title":"设计模式","uri":"/blog/20221205_designpatterns/"},{"categories":["Technology"],"content":"备忘录模式 游戏角色状态恢复问题 游戏角色有攻击力和防御力，在大战Boss前保存自身的状态（攻击力和防御力），当大战Boss后攻击力和防御力下降，从备忘录对象恢复到大战前的状态 传统方案 传统的设计方案（类图） 传统方案的问题分析 一个对象，就对应一个保存对象状态的对象，这样当我们游戏的对象很多时，不利于管理，开销也很大 传统的方式是简单地做备份，new出另一个对象出来，再把需要备份的数据放到这个新对象，但这就暴露了对象内部的细节 解决方案 -\u003e 备忘录模式 备忘录模式 基本介绍 备忘录模式（Memento Pattern）在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态 可以这样理解备忘录模式：显示生活中的备忘录是用来记录某些要去做的事情，或者是记录已经达到的共同意见的事情，以防忘记了。而在软件层面，备忘录模式有着相同的含义，备忘录对象主要用来记录一个对象的某种状态，或者某些数据，当要做回退时，可以从备忘录对象里获取原来的数据进行恢复操作 备忘录模式属于行为型模式 备忘录模式原理 备忘录模式原理类图 备忘录模式中角色及职责 Originator：对象（需要保存状态的对象） Memento：备忘录对象，负责保存好记录。即 Originator 内部状态 Caretaker：守护者对象，负责保存多个备忘录对象，使用集合管理，提高效率 说明：如果希望保存多个 Orifginator 对象的不同时间的状态，也可以，只需要 HashMap\u003cString,集合\u003e 针对上面的备忘录模式原理结构图，我们使用代码简单实现，注意体会体现出 Caretaker 可以保存多个备忘录对象，方便管理，提高效率 public class Originator { private String state;//状态信息 public String getState() { return state; } public void setState(String state) { this.state = state; } //编写一个方法，可以保存一个状态对象 Memento //因此编写一个方法，返回 Memento public Memento saveStateMemento() { return new Memento(state); } //通过备忘录对象，恢复状态 public void getStateFromMemento(Memento memento) { state = memento.getState(); } } public class Memento { private String state; //构造器 public Memento(String state) { super(); this.state = state; } public String getState() { return state; } } import java.util.ArrayList; import java.util.List; public class Caretaker { //在List 集合中会有很多的备忘录对象 private List\u003cMemento\u003e mementoList = new ArrayList\u003cMemento\u003e(); public void add(Memento memento) { mementoList.add(memento); } //获取到第index个Originator 的 备忘录对象(即保存状态) public Memento get(int index) { return mementoList.get(index); } } import java.util.ArrayList; import java.util.HashMap; public class Client { public static void main(String[] args) { // TODO Auto-generated method stub Originator originator = new Originator(); Caretaker caretaker = new Caretaker(); originator.setState(\" 状态#1 攻击力 100 \"); //保存了当前的状态 caretaker.add(originator.saveStateMemento()); originator.setState(\" 状态#2 攻击力 80 \"); caretaker.add(originator.saveStateMemento()); originator.setState(\" 状态#3 攻击力 50 \"); caretaker.add(originator.saveStateMemento()); System.out.println(\"当前的状态是 =\" + originator.getState()); //希望得到状态 1, 将 originator 恢复到状态1 originator.getStateFromMemento(caretaker.get(0)); System.out.println(\"恢复到状态1 , 当前的状态是\"); System.out.println(\"当前的状态是 =\" + originator.getState()); } } 备忘录模式应用实例 备忘录模式应用实例类图 public class Memento { //攻击力 private int vit; //防御力 private int def; public Memento(int vit, int def) { super(); this.vit = vit; this.def = def; } public int getVit() { return vit; } public void setVit(int vit) { this.vit = vit; } public int getDef() { return def; } public void setDef(int def) { this.def = def; } } public class GameRole { private int vit; private int def; //创建Memento ,即根据当前的状态得到Memento public Memento createMemento() { return new Memento(vit, def); } //从备忘录对象，恢复GameRole的状态 public void recoverGameRoleFromMemento(Memento memento) { this.vit = memento.getVit(); this.def = memento.getDef(); } //显示当前游戏角色的状态 public void display() { System.out.println(\"游戏角色当前的攻击力：\" + this.vit + \" 防御力: \" + this.def); } public int getVit() { return vit; } public void setVit(int vit) { this.vit = vit; } public int getDef() { return def; } public void setDef(int def) { this.def = def; } } import java.util.ArrayList; import java.util.HashMap; //守护者对象, 保存游戏角色的状态 public class Caretaker { //如果只保存一次状态 private Memento memento; //对GameRole 保存多次状态 //private ArrayList\u003cMemento\u003e mementos; //对多个游戏角色保存多个状态 //private HashMap\u003cString, ArrayList\u003cMemento\u003e\u003e rolesMementos; public Memento getMemento() { return memento; } public void setMemento(Memento memento) { this.memento = memento; } } public class Client { public static void main(String[] args) { // TODO Auto-generated method stub //创建游戏角色 GameRole gameRole = new GameRole(); gameRole.setVit(100); gameRole.setDef(100); System.out.println(\"和boss大战前的状态\"); gameRole.display(); //把当前状态保存caretaker Caretaker caretaker = new Caretaker(); caretaker.setMemento(gameRole.createMemento()); System.out.println(\"和boss","date":"2022-12-05","objectID":"/blog/20221205_designpatterns/:4:20","tags":["Java","coding","principle"],"title":"设计模式","uri":"/blog/20221205_designpatterns/"},{"categories":["Technology"],"content":"解释器模式 未完待续··· ","date":"2022-12-05","objectID":"/blog/20221205_designpatterns/:4:21","tags":["Java","coding","principle"],"title":"设计模式","uri":"/blog/20221205_designpatterns/"},{"categories":["Hugo"],"content":"基本 Markdown 语法. 注意 这篇文章借鉴了一篇很棒的来自 Grav 的文章. 我们都知道编写 Web 内容很麻烦.但市面上有一种 WYSIWYG所见即所得 编辑器可以帮助我们减轻了这一任务. 但通常会导致代码太糟, 但有时更糟糕的是, 网页也会很丑，毕竟代码不是我们亲手所写，讲究的就是两字——省事，以至于其他都与我无关. 对于通常伴随的所有复杂和丑陋的问题, Markdown 生成 HTML 内容的方式是一种更好的选择. 一些主要好处是: Markdown 简单易学, 几乎没有多余的字符, 因此编写内容也更快. 用 Markdown 书写时出错的机会更少. 可以产生有效的 XHTML 输出. 将内容和视觉显示保持分开, 这样就不会打乱网站的外观. 可以在你喜欢的任何文本编辑器或 Markdown 应用程序中编写内容. Markdown 使用起来很有趣! John Gruber, Markdown 的作者说: Markdown 格式的首要设计目标是更具可读性. 最初的想法是 Markdown 格式的文档应当以纯文本形式发布, 而不会看起来像被标签或格式说明所标记. 虽然 Markdown 的语法受到几种现有的文本到 HTML 转换工具的影响, 但 Markdown 语法的最大灵感来源是纯文本电子邮件的格式. – John Gruber 话不多说, 我们来回顾一下 Markdown 的主要语法以及生成的 HTML 样式! 技巧  将此页保存为书签，以备将来参考! ","date":"2022-09-19","objectID":"/blog/markdown/:0:0","tags":["Markdown","HTML","Posts","grammar"],"title":"Markdown 基本语法","uri":"/blog/markdown/"},{"categories":["Hugo"],"content":"1 标题 从 h2 到 h6 的标题在每个级别上都加上一个 ＃: ## h2 标题 ### h3 标题 #### h4 标题 ##### h5 标题 ###### h6 标题 输出的 HTML 看起来像这样: \u003ch2\u003eh2 标题\u003c/h2\u003e \u003ch3\u003eh3 标题\u003c/h3\u003e \u003ch4\u003eh4 标题\u003c/h4\u003e \u003ch5\u003eh5 标题\u003c/h5\u003e \u003ch6\u003eh6 标题\u003c/h6\u003e 标题 ID 要添加自定义标题 ID, 请在与标题相同的行中将自定义 ID 放在花括号中: ### 一个很棒的标题 {#custom-id} 输出的 HTML 看起来像这样: \u003ch3 id=\"custom-id\"\u003e一个很棒的标题\u003c/h3\u003e ","date":"2022-09-19","objectID":"/blog/markdown/:1:0","tags":["Markdown","HTML","Posts","grammar"],"title":"Markdown 基本语法","uri":"/blog/markdown/"},{"categories":["Hugo"],"content":"2 注释 注释是和 HTML 兼容的： \u003c!-- 这是一段注释 --\u003e 不能看到以下的注释: ","date":"2022-09-19","objectID":"/blog/markdown/:2:0","tags":["Markdown","HTML","Posts","grammar"],"title":"Markdown 基本语法","uri":"/blog/markdown/"},{"categories":["Hugo"],"content":"3 水平线 HTML 中的 \u003chr\u003e 标签是用来在段落元素之间创建一个 “专题间隔” 的. 使用 Markdown, 你可以用以下方式创建一个 \u003chr\u003e 标签: ___: 三个连续的下划线 ---: 三个连续的破折号 ***: 三个连续的星号 呈现的输出效果如下: ","date":"2022-09-19","objectID":"/blog/markdown/:3:0","tags":["Markdown","HTML","Posts","grammar"],"title":"Markdown 基本语法","uri":"/blog/markdown/"},{"categories":["Hugo"],"content":"4 段落 按照纯文本的方式书写段落, 纯文本在呈现的 HTML 中将用 \u003cp\u003e/\u003c/p\u003e 标签包裹. 如下段落: Lorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad. 输出的 HTML 看起来像这样: \u003cp\u003eLorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad.\u003c/p\u003e 可以使用一个空白行进行换行. ","date":"2022-09-19","objectID":"/blog/markdown/:4:0","tags":["Markdown","HTML","Posts","grammar"],"title":"Markdown 基本语法","uri":"/blog/markdown/"},{"categories":["Hugo"],"content":"5 内联 HTML 元素 如果你需要某个 HTML 标签 (带有一个类), 则可以简单地像这样使用: Markdown 格式的段落. \u003cdiv class=\"class\"\u003e 这是 \u003cb\u003eHTML\u003c/b\u003e \u003c/div\u003e Markdown 格式的段落. ","date":"2022-09-19","objectID":"/blog/markdown/:5:0","tags":["Markdown","HTML","Posts","grammar"],"title":"Markdown 基本语法","uri":"/blog/markdown/"},{"categories":["Hugo"],"content":"6 强调 ","date":"2022-09-19","objectID":"/blog/markdown/:6:0","tags":["Markdown","HTML","Posts","grammar"],"title":"Markdown 基本语法","uri":"/blog/markdown/"},{"categories":["Hugo"],"content":"加粗 用于强调带有较粗字体的文本片段. 以下文本片段会被 渲染为粗体. **渲染为粗体** __渲染为粗体__ 输出的 HTML 看起来像这样: \u003cstrong\u003e渲染为粗体\u003c/strong\u003e ","date":"2022-09-19","objectID":"/blog/markdown/:6:1","tags":["Markdown","HTML","Posts","grammar"],"title":"Markdown 基本语法","uri":"/blog/markdown/"},{"categories":["Hugo"],"content":"斜体 用于强调带有斜体的文本片段. 以下文本片段被 渲染为斜体. *渲染为斜体* _渲染为斜体_ 输出的 HTML 看起来像这样: \u003cem\u003e渲染为斜体\u003c/em\u003e ","date":"2022-09-19","objectID":"/blog/markdown/:6:2","tags":["Markdown","HTML","Posts","grammar"],"title":"Markdown 基本语法","uri":"/blog/markdown/"},{"categories":["Hugo"],"content":"删除线 按照 GFMGitHub flavored Markdown 你可以使用删除线. ~~这段文本带有删除线.~~ 呈现的输出效果如下: 这段文本带有删除线. 输出的 HTML 看起来像这样: \u003cdel\u003e这段文本带有删除线.\u003c/del\u003e ","date":"2022-09-19","objectID":"/blog/markdown/:6:3","tags":["Markdown","HTML","Posts","grammar"],"title":"Markdown 基本语法","uri":"/blog/markdown/"},{"categories":["Hugo"],"content":"组合 加粗, 斜体, 和删除线可以 组合使用. ***加粗和斜体*** ~~**删除线和加粗**~~ ~~*删除线和斜体*~~ ~~***加粗, 斜体和删除线***~~ 呈现的输出效果如下: 加粗和斜体 删除线和加粗 删除线和斜体 加粗, 斜体和删除线 输出的 HTML 看起来像这样: \u003cem\u003e\u003cstrong\u003e加粗和斜体\u003c/strong\u003e\u003c/em\u003e \u003cdel\u003e\u003cstrong\u003e删除线和加粗\u003c/strong\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e删除线和斜体\u003c/em\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e\u003cstrong\u003e加粗, 斜体和删除线\u003c/strong\u003e\u003c/em\u003e\u003c/del\u003e ","date":"2022-09-19","objectID":"/blog/markdown/:6:4","tags":["Markdown","HTML","Posts","grammar"],"title":"Markdown 基本语法","uri":"/blog/markdown/"},{"categories":["Hugo"],"content":"7 引用 用于在文档中引用其他来源的内容块. 在要引用的任何文本之前添加 \u003e: \u003e **Fusion Drive** combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 呈现的输出效果如下: Fusion Drive combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 输出的 HTML 看起来像这样: \u003cblockquote\u003e \u003cp\u003e \u003cstrong\u003eFusion Drive\u003c/strong\u003e combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. \u003c/p\u003e \u003c/blockquote\u003e 引用也可以嵌套: \u003e Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. \u003e\u003e Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. 呈现的输出效果如下: Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. ","date":"2022-09-19","objectID":"/blog/markdown/:7:0","tags":["Markdown","HTML","Posts","grammar"],"title":"Markdown 基本语法","uri":"/blog/markdown/"},{"categories":["Hugo"],"content":"8 列表 ","date":"2022-09-19","objectID":"/blog/markdown/:8:0","tags":["Markdown","HTML","Posts","grammar"],"title":"Markdown 基本语法","uri":"/blog/markdown/"},{"categories":["Hugo"],"content":"无序列表 一系列项的列表, 其中项的顺序没有明显关系. 你可以使用以下任何符号来表示无序列表中的项: * 一项内容 - 一项内容 + 一项内容 例如: * Lorem ipsum dolor sit amet * Consectetur adipiscing elit * Integer molestie lorem at massa * Facilisis in pretium nisl aliquet * Nulla volutpat aliquam velit * Phasellus iaculis neque * Purus sodales ultricies * Vestibulum laoreet porttitor sem * Ac tristique libero volutpat at * Faucibus porta lacus fringilla vel * Aenean sit amet erat nunc * Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Phasellus iaculis neque Purus sodales ultricies Vestibulum laoreet porttitor sem Ac tristique libero volutpat at Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 输出的 HTML 看起来像这样: \u003cul\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit \u003cul\u003e \u003cli\u003ePhasellus iaculis neque\u003c/li\u003e \u003cli\u003ePurus sodales ultricies\u003c/li\u003e \u003cli\u003eVestibulum laoreet porttitor sem\u003c/li\u003e \u003cli\u003eAc tristique libero volutpat at\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ul\u003e ","date":"2022-09-19","objectID":"/blog/markdown/:8:1","tags":["Markdown","HTML","Posts","grammar"],"title":"Markdown 基本语法","uri":"/blog/markdown/"},{"categories":["Hugo"],"content":"有序列表 一系列项的列表, 其中项的顺序确实很重要. 1. Lorem ipsum dolor sit amet 2. Consectetur adipiscing elit 3. Integer molestie lorem at massa 4. Facilisis in pretium nisl aliquet 5. Nulla volutpat aliquam velit 6. Faucibus porta lacus fringilla vel 7. Aenean sit amet erat nunc 8. Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 输出的 HTML 看起来像这样: \u003col\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit\u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ol\u003e 技巧 如果你对每一项使用 1., Markdown 将自动为每一项编号. 例如: 1. Lorem ipsum dolor sit amet 1. Consectetur adipiscing elit 1. Integer molestie lorem at massa 1. Facilisis in pretium nisl aliquet 1. Nulla volutpat aliquam velit 1. Faucibus porta lacus fringilla vel 1. Aenean sit amet erat nunc 1. Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem ","date":"2022-09-19","objectID":"/blog/markdown/:8:2","tags":["Markdown","HTML","Posts","grammar"],"title":"Markdown 基本语法","uri":"/blog/markdown/"},{"categories":["Hugo"],"content":"任务列表 任务列表使你可以创建带有复选框的列表. 要创建任务列表, 请在任务列表项之前添加破折号 (-) 和带有空格的方括号 ([ ]). 要选择一个复选框，请在方括号之间添加 x ([x]). - [x] Write the press release - [ ] Update the website - [ ] Contact the media 呈现的输出效果如下: Write the press release Update the website Contact the media ","date":"2022-09-19","objectID":"/blog/markdown/:8:3","tags":["Markdown","HTML","Posts","grammar"],"title":"Markdown 基本语法","uri":"/blog/markdown/"},{"categories":["Hugo"],"content":"9 代码 ","date":"2022-09-19","objectID":"/blog/markdown/:9:0","tags":["Markdown","HTML","Posts","grammar"],"title":"Markdown 基本语法","uri":"/blog/markdown/"},{"categories":["Hugo"],"content":"行内代码 用 ` 包装行内代码段. 在这个例子中, `\u003csection\u003e\u003c/section\u003e` 会被包裹成 **代码**. 呈现的输出效果如下: 在这个例子中, \u003csection\u003e\u003c/section\u003e 会被包裹成 代码. 输出的 HTML 看起来像这样: \u003cp\u003e 在这个例子中, \u003ccode\u003e\u0026lt;section\u0026gt;\u0026lt;/section\u0026gt;\u003c/code\u003e 会被包裹成 \u003cstrong\u003e代码\u003c/strong\u003e. \u003c/p\u003e ","date":"2022-09-19","objectID":"/blog/markdown/:9:1","tags":["Markdown","HTML","Posts","grammar"],"title":"Markdown 基本语法","uri":"/blog/markdown/"},{"categories":["Hugo"],"content":"缩进代码 将几行代码缩进至少四个空格，例如: // Some comments line 1 of code line 2 of code line 3 of code 呈现的输出效果如下: // Some comments line 1 of code line 2 of code line 3 of code 输出的 HTML 看起来像这样: \u003cpre\u003e \u003ccode\u003e // Some comments line 1 of code line 2 of code line 3 of code \u003c/code\u003e \u003c/pre\u003e ","date":"2022-09-19","objectID":"/blog/markdown/:9:2","tags":["Markdown","HTML","Posts","grammar"],"title":"Markdown 基本语法","uri":"/blog/markdown/"},{"categories":["Hugo"],"content":"围栏代码块 使用 “围栏” ``` 来生成一段带有语言属性的代码块. ```markdown Sample text here... ``` 输出的 HTML 看起来像这样: \u003cpre language-html\u003e \u003ccode\u003eSample text here...\u003c/code\u003e \u003c/pre\u003e ","date":"2022-09-19","objectID":"/blog/markdown/:9:3","tags":["Markdown","HTML","Posts","grammar"],"title":"Markdown 基本语法","uri":"/blog/markdown/"},{"categories":["Hugo"],"content":"语法高亮 GFMGitHub Flavored Markdown 也支持语法高亮. 要激活它，只需在第一个代码 “围栏” 之后直接添加你要使用的语言的文件扩展名, ```js, 语法高亮显示将自动应用于渲染的 HTML 中. 例如, 在以下 JavaScript 代码中应用语法高亮: ```js grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; ``` 呈现的输出效果如下: grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; 注意 Hugo 文档中的 语法高亮页面 介绍了有关语法高亮的更多信息, 包括语法高亮的 shortcode. ","date":"2022-09-19","objectID":"/blog/markdown/:9:4","tags":["Markdown","HTML","Posts","grammar"],"title":"Markdown 基本语法","uri":"/blog/markdown/"},{"categories":["Hugo"],"content":"10 表格 通过在每个单元格之间添加竖线作为分隔线, 并在标题下添加一行破折号 (也由竖线分隔) 来创建表格. 注意, 竖线不需要垂直对齐. | Option | Description | | ------ | ----------- | | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的输出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. 输出的 HTML 看起来像这样: \u003ctable\u003e \u003cthead\u003e \u003ctr\u003e \u003cth\u003eOption\u003c/th\u003e \u003cth\u003eDescription\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003ctd\u003edata\u003c/td\u003e \u003ctd\u003epath to data files to supply the data that will be passed into templates.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eengine\u003c/td\u003e \u003ctd\u003eengine to be used for processing templates. Handlebars is the default.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eext\u003c/td\u003e \u003ctd\u003eextension to be used for dest files.\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e 文本右对齐或居中对齐 在任何标题下方的破折号右侧添加冒号将使该列的文本右对齐. 在任何标题下方的破折号两边添加冒号将使该列的对齐文本居中. | Option | Description | |:------:| -----------:| | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的输出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. ","date":"2022-09-19","objectID":"/blog/markdown/:10:0","tags":["Markdown","HTML","Posts","grammar"],"title":"Markdown 基本语法","uri":"/blog/markdown/"},{"categories":["Hugo"],"content":"11 链接 ","date":"2022-09-19","objectID":"/blog/markdown/:11:0","tags":["Markdown","HTML","Posts","grammar"],"title":"Markdown 基本语法","uri":"/blog/markdown/"},{"categories":["Hugo"],"content":"基本链接 \u003chttps://assemble.io\u003e \u003ccontact@revolunet.com\u003e [Assemble](https://assemble.io) 呈现的输出效果如下 (将鼠标悬停在链接上，没有提示): https://assemble.io contact@revolunet.com Assemble 输出的 HTML 看起来像这样: \u003ca href=\"https://assemble.io\"\u003ehttps://assemble.io\u003c/a\u003e \u003ca href=\"mailto:contact@revolunet.com\"\u003econtact@revolunet.com\u003c/a\u003e \u003ca href=\"https://assemble.io\"\u003eAssemble\u003c/a\u003e ","date":"2022-09-19","objectID":"/blog/markdown/:11:1","tags":["Markdown","HTML","Posts","grammar"],"title":"Markdown 基本语法","uri":"/blog/markdown/"},{"categories":["Hugo"],"content":"添加一个标题 [Upstage](https://github.com/upstage/ \"Visit Upstage!\") 呈现的输出效果如下 (将鼠标悬停在链接上，会有一行提示): Upstage 输出的 HTML 看起来像这样: \u003ca href=\"https://github.com/upstage/\" title=\"Visit Upstage!\"\u003eUpstage\u003c/a\u003e ","date":"2022-09-19","objectID":"/blog/markdown/:11:2","tags":["Markdown","HTML","Posts","grammar"],"title":"Markdown 基本语法","uri":"/blog/markdown/"},{"categories":["Hugo"],"content":"定位标记 定位标记使你可以跳至同一页面上的指定锚点. 例如, 每个章节: ## Table of Contents * [Chapter 1](#chapter-1) * [Chapter 2](#chapter-2) * [Chapter 3](#chapter-3) 将跳转到这些部分: ## Chapter 1 \u003ca id=\"chapter-1\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 2 \u003ca id=\"chapter-2\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 3 \u003ca id=\"chapter-3\"\u003e\u003c/a\u003e Content for chapter one. 注意 定位标记的位置几乎是任意的. 因为它们并不引人注目, 所以它们通常被放在同一行了. ","date":"2022-09-19","objectID":"/blog/markdown/:11:3","tags":["Markdown","HTML","Posts","grammar"],"title":"Markdown 基本语法","uri":"/blog/markdown/"},{"categories":["Hugo"],"content":"12 脚注 脚注使你可以添加注释和参考, 而不会使文档正文混乱. 当你创建脚注时, 会在添加脚注引用的位置出现带有链接的上标编号. 读者可以单击链接以跳至页面底部的脚注内容. 要创建脚注引用, 请在方括号中添加插入符号和标识符 ([^1]). 标识符可以是数字或单词, 但不能包含空格或制表符. 标识符仅将脚注引用与脚注本身相关联 - 在脚注输出中, 脚注按顺序编号. 在中括号内使用插入符号和数字以及用冒号和文本来添加脚注内容 ([^1]：这是一段脚注). 你不一定要在文档末尾添加脚注. 可以将它们放在除列表, 引用和表格等元素之外的任何位置. 这是一个数字脚注[^1]. 这是一个带标签的脚注[^label] [^1]: 这是一个数字脚注 [^label]: 这是一个带标签的脚注 这是一个数字脚注1. 这是一个带标签的脚注2 ","date":"2022-09-19","objectID":"/blog/markdown/:12:0","tags":["Markdown","HTML","Posts","grammar"],"title":"Markdown 基本语法","uri":"/blog/markdown/"},{"categories":["Hugo"],"content":"13 图片 图片的语法与链接相似, 但包含一个在前面的感叹号. ![Minion](https://octodex.github.com/images/minion.png) 或者: ![Alt text](https://octodex.github.com/images/stormtroopocat.jpg \"The Stormtroopocat\") The Stormtroopocat 像链接一样, 图片也具有脚注样式的语法: ![Alt text][id] The Dojocat 这是一个数字脚注 ↩︎ 这是一个带标签的脚注 ↩︎ ","date":"2022-09-19","objectID":"/blog/markdown/:13:0","tags":["Markdown","HTML","Posts","grammar"],"title":"Markdown 基本语法","uri":"/blog/markdown/"},{"categories":["Technology"],"content":"Docker安装SQLServer","date":"2022-08-31","objectID":"/blog/20220831_sqlserver/","tags":["study","Docker","SQLServer","Mac"],"title":"Mac使用SQLServer数据库","uri":"/blog/20220831_sqlserver/"},{"categories":["Technology"],"content":"Mac 安装 SQL Server ","date":"2022-08-31","objectID":"/blog/20220831_sqlserver/:0:0","tags":["study","Docker","SQLServer","Mac"],"title":"Mac使用SQLServer数据库","uri":"/blog/20220831_sqlserver/"},{"categories":["Technology"],"content":"前言 由于最近学习需要使用到 SQL Server 数据库，但我本人使用的操作系统是 Mac ，众所周知， SQL Server 是微软旗下的关系型数据库（具体有关SQL Server优点自行去微软官方查看👀 Microsoft - SQL Server | Microsoft Docs ），所以微软肯定更加亲近自己的亲儿子 Windows 操作系统，以至于到现在 SQL Server 并不支持 Mac，那怎么办呢？总不能安装虚拟机使用吧，对于我们如此珍惜内存使用的程序猿那是不可能的😂，经过我查阅资料，我发现微软当前支持 Ubuntu 16.04，和 RHEL 7.2（红帽子企业版 Linux ），既然支持 Linux 那就好办了，我们可以使用Docker🤔应用去虚拟化实例。 ","date":"2022-08-31","objectID":"/blog/20220831_sqlserver/:0:1","tags":["study","Docker","SQLServer","Mac"],"title":"Mac使用SQLServer数据库","uri":"/blog/20220831_sqlserver/"},{"categories":["Technology"],"content":"Docker 介绍 Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。 Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。 Docker 最好的一点在于你需要什么环境就可以下载仅拥有该环境的 Linux 系统，即缩小了使用的体积，也拥有了需要使用的环境，轻便又高效。 ","date":"2022-08-31","objectID":"/blog/20220831_sqlserver/:0:2","tags":["study","Docker","SQLServer","Mac"],"title":"Mac使用SQLServer数据库","uri":"/blog/20220831_sqlserver/"},{"categories":["Technology"],"content":"Mac 安装 Docker Docker 官网手动安装 Docker HomeBrew 托管安装 brew cask install docker 对于能偷懒就偷懒的我来说😎，肯定选择后者一条命令解决了，官网安装下载还需要去寻找点击下载，对于程序猿来说多不优雅呀🤓，想要了解 macOS（或 Linux）缺失的软件包的管理器 — Homebrew 的可以自行去了解一下，真是可以大大提高效率，让你安装程序变得如此优雅。 ==\u003e Downloading https://download.docker.com/mac/stable/42716/Docker.dmg ######################################################################## 100.0% ==\u003e Verifying SHA-256 checksum for Cask 'docker'. ==\u003e Installing Cask docker ==\u003e Moving App 'Docker.app' to '/Applications/Docker.app'. docker was successfully installed! 显示 successfully 便已经成功下载 ","date":"2022-08-31","objectID":"/blog/20220831_sqlserver/:0:3","tags":["study","Docker","SQLServer","Mac"],"title":"Mac使用SQLServer数据库","uri":"/blog/20220831_sqlserver/"},{"categories":["Technology"],"content":"Docker 配置并拉取容器镜像 基本环境配置 根据自己电脑相应配置，自己分配Docker占用资源大小，内存一定要大于2G，我记得好像SQL Server最基本要保证内存2G才能成功启动（以下是我的Docker资源分配配置）。 Docker环境配置 镜像加速 鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，我们可以需要配置加速器来解决，我使用的是网易的镜像地址：http://hub-mirror.c.163.com。 Docker镜像加速 配置完成后重启 Docker 应用，打开 Terminal 输入 docker info 查看配置是否成功。 docker info .... Registry Mirrors: http://hub-mirror.c.163.com/ Live Restore Enabled: false Product License: Community Engine 拉取并运行 SQL Server 容器镜像 拉取并运行 SQL Server 容器映像，参考了Docker: Install containers for SQL Server on Linux - SQL Server | Microsoft Docs 从 Microsoft 容器注册表中拉取 SQL Server 2017 Linux 容器映像，打开我们的终端，输入命令： sudo docker pull mcr.microsoft.com/mssql/server:2017-latest 这里会将sql server for linux docker下载到我们计算机上。 使用 Docker 运行容器镜像 要使用 Docker 运行容器映像，可以从 Terminal (Linux/macOS) 使用以下命令。(也就是终端)。 sudo docker run -e \"ACCEPT_EULA=Y\" -e \"SA_PASSWORD=\u003cYourStrong@Passw0rd\u003e\" \\ -p 1433:1433 --name sqlserver \\ -d mcr.microsoft.com/mssql/server:2017-latest 备注: 密码应符合 SQL Server 默认密码策略，否则容器无法设置 SQL Server，将停止工作。 默认情况下，密码的长度必须至少为 8 个字符，并且必须包含以下四种字符中的三种：大写字母、小写字母、十进制数字和符号。 你可以通过执行 docker logs 命令检查错误日志。 参数说明: -e \"ACCEPT_EULA=Y\" 将 ACCEPT_EULA 变量设置为任意值，以确认接受最终用户许可协议。 SQL Server 映像的必须设置。 \"SA_PASSWORD=\u003cYourStrong@Passw0rd\u003e\" 指定至少包含 8 个字符且符合 SQL Server 密码要求的强密码。 SQL Server 映像的必需设置。 -p 1433:1433 将主机环境中的 TCP 端口（第一个值）映射到容器中的 TCP 端口（第二个值）。 在此示例中，SQL Server 侦听容器中的 TCP 1433，并对主机上的端口 1433 公开。 name sqlserver 为容器指定一个自定义名称，而不是使用随机生成的名称。 如果运行多个容器，则无法重复使用相同的名称。 mcr.microsoft.com/mssql/server:2017-latest SQL Server 2017 Linux 容器映像 查看 Docker 容器 要查看 Docker 容器，请在 Terminal 中使用 docker ps 命令。 sudo docker ps -a 显示结果如下： CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 78c2deca0bd6 mcr.microsoft.com/mssql/server:2017-latest \"/opt/mssql/bin/nonr…\" 30 minutes ago Exited (0) 2 minutes ago sqlserver 如果“状态”列显示“正常运行”，则 SQL Server 将在容器中运行，并侦听“端口”列中指定的端口（我现在是关闭状态，可以使用 docker start CONTAINER ID 重新启动 ） 。 更改 SA 密码 SA 帐户是安装过程中在 SQL Server 实例上创建的系统管理员。 创建 SQL Server 容器后，通过在容器中运行 echo $SA_PASSWORD，可发现指定的 SA_PASSWORD 环境变量。 出于安全考虑，请考虑更改 SA 密码。 选择 SA 用户要使用的强密码。 使用 docker exec 运行sqlcmd ，以使用 Transact-SQL 更改密码。 在下面的示例中，将旧密码 \u003cYourStrong!Passw0rd\u003e和新密码 \u003cYourNewStrong!Passw0rd\u003e 替换为你自己的密码值。 sudo docker exec -it sqlserver /opt/mssql-tools/bin/sqlcmd \\ -S localhost -U SA -P \"\u003cYourStrong@Passw0rd\u003e\" \\ -Q 'ALTER LOGIN SA WITH PASSWORD=\"\u003cYourNewStrong@Passw0rd\u003e\"' 连接 SQL Server 下列步骤在容器内部使用 SQL Server 命令行工具 sqlcmd 来连接 SQL Server。 使用 docker exec -it 命令在运行的容器内部启动交互式 Bash Shell。 在下面的示例中，sqlserver 是在创建容器时由 –name 参数指定的名称。 sudo docker exec -it sql1 \"bash\" 在容器内部使用 sqlcmd 进行本地连接。 默认情况下，sqlcmd 不在路径之中，因此需要指定完整路径。 /opt/mssql-tools/bin/sqlcmd -S localhost -U SA -P \"\u003cYourNewStrong@Passw0rd\u003e\" 如果成功，应会显示 sqlcmd 命令提示符：1\u003e ","date":"2022-08-31","objectID":"/blog/20220831_sqlserver/:0:4","tags":["study","Docker","SQLServer","Mac"],"title":"Mac使用SQLServer数据库","uri":"/blog/20220831_sqlserver/"},{"categories":["Technology"],"content":"利用Navicat可视化工具连接Sql Server 下载 navicat 应用选择SQL Server服务，输入连接名、主机、用户名、密码进行连接。 Navicat连接SQLServer 提示： 密码一定不要填错，如果密码填错，会出现以下错误(一定要学会去Docker里面查看LOG): Docker日志LOG 注意： 创建sa账号时候的密码的左右\u003c\u003e两个尖括号也是属于密码的 我就是在实际操作中犯了如此低级的错误，望以鉴！ ","date":"2022-08-31","objectID":"/blog/20220831_sqlserver/:0:5","tags":["study","Docker","SQLServer","Mac"],"title":"Mac使用SQLServer数据库","uri":"/blog/20220831_sqlserver/"},{"categories":["Technology"],"content":"总结 越努力越幸运! 以上就是本次分享的在Mac上如何使用 SQL Server 的详细教程,我们一起讨论！如果哪里有写的不好的地方，还希望大家提出来，在下方评论区留言，我加以修正！ ","date":"2022-08-31","objectID":"/blog/20220831_sqlserver/:0:6","tags":["study","Docker","SQLServer","Mac"],"title":"Mac使用SQLServer数据库","uri":"/blog/20220831_sqlserver/"},{"categories":["Java"],"content":"Java学习路线","date":"2022-08-13","objectID":"/blog/20220813_route/","tags":["java","study","Java学习路线"],"title":"Java 学习路线","uri":"/blog/20220813_route/"},{"categories":["Java"],"content":"Java 学习路线 ","date":"2022-08-13","objectID":"/blog/20220813_route/:0:0","tags":["java","study","Java学习路线"],"title":"Java 学习路线","uri":"/blog/20220813_route/"},{"categories":["Java"],"content":"前言 首先呢，我们要了解 Java 的应用场景和就业方向，看看和自己的学习目的是否一致，目前，Java 的岗位需求多，是后台开发的主流编程语言，功能强大，还是很值得学习的。 ","date":"2022-08-13","objectID":"/blog/20220813_route/:1:0","tags":["java","study","Java学习路线"],"title":"Java 学习路线","uri":"/blog/20220813_route/"},{"categories":["Java"],"content":"阶段 1：Java 入门 ","date":"2022-08-13","objectID":"/blog/20220813_route/:2:0","tags":["java","study","Java学习路线"],"title":"Java 学习路线","uri":"/blog/20220813_route/"},{"categories":["Java"],"content":"目标 培养兴趣、快速上手 ","date":"2022-08-13","objectID":"/blog/20220813_route/:2:1","tags":["java","study","Java学习路线"],"title":"Java 学习路线","uri":"/blog/20220813_route/"},{"categories":["Java"],"content":"前期准备 准备好一款在线、随时随地写代码的工具，不用在本地去安装和配置，是初学者的好帮手 推荐网站 - 菜鸟工具 准备一款记笔记的软件，学编程的过程中老师的思路、自己遇到的问题、解决问题的方法、心得感悟、遇到的好资料，都要记下来哦，好记性不如烂笔头，可以帮助你事半功倍。 推荐软件 - Typora 推荐使用 Markdown 语法编写（我的教程文章） 想学好编程，别背代码，要多写，把这句话刻到脑子里。 选视频和找资料的小技巧：多看评论区、多看隔壁评论区，不要看过期的视频。 ","date":"2022-08-13","objectID":"/blog/20220813_route/:2:2","tags":["java","study","Java学习路线"],"title":"Java 学习路线","uri":"/blog/20220813_route/"},{"categories":["Java"],"content":"Java 编程基础（45 天） 知识 Java 特点（看不懂没事，别背！） 环境搭建 Java 基础语法 数据类型 流程控制 数组 面向对象 方法 重载 封装 继承 多态 抽象类 接口 枚举 常用类 String 日期时间 集合类 泛型 注解 异常处理 多线程 IO 流 反射 学习建议 一定要持续学习，不能断！ 跟着书上的例子敲代码后，自主编写代码，并完成课后练习。 资源 视频 ⭐ 韩顺平 - 零基础 30 天学会 Java（900 多集，顺序安排很合理，每个知识真正的打碎了，通俗、有示例、有实战、有思想） 文档 ⭐ 菜鸟教程（可以在线练习） 廖雪峰 Java 教程 书籍 《Head First Java》 在线游戏 Codegym（玩玩前几关培养兴趣不错，但后面收费了） ","date":"2022-08-13","objectID":"/blog/20220813_route/:2:3","tags":["java","study","Java学习路线"],"title":"Java 学习路线","uri":"/blog/20220813_route/"},{"categories":["Java"],"content":"Java 8（3 天） 知识 Stream API Lambda 表达式 新日期时间 API 接口默认方法 资源 视频 ⭐ 宋红康 - 全网最全Java零基础入门教程（只看 Java 8 部分即可） 文档 ⭐ 菜鸟教程 书籍 《Java 8 实战》 工具 ⭐ 在线编写运行 Java 8 项目 Java 8 小代码片段 ","date":"2022-08-13","objectID":"/blog/20220813_route/:2:4","tags":["java","study","Java学习路线"],"title":"Java 学习路线","uri":"/blog/20220813_route/"},{"categories":["Java"],"content":"尾声 学完了 Java 基础后，有些同学会感到迷茫了啊，感觉好像啥也做不出来，不知道下一步做什么，我这一身的本领该如何施展啊？ 不要慌，也不要急着去学新技术，接下来我们要多用 Java 来写代码了，巩固基础，但是写什么呢？ 当然是数据结构和算法！ ","date":"2022-08-13","objectID":"/blog/20220813_route/:2:5","tags":["java","study","Java学习路线"],"title":"Java 学习路线","uri":"/blog/20220813_route/"},{"categories":["Java"],"content":"阶段 2：巩固基础 ","date":"2022-08-13","objectID":"/blog/20220813_route/:3:0","tags":["java","study","Java学习路线"],"title":"Java 学习路线","uri":"/blog/20220813_route/"},{"categories":["Java"],"content":"目标 想学好编程，计算机基础知识要学好。 比如算法，是程序员的灵魂。学好算法有助于我们理解程序、开拓思路，因此也是很多公司面试时考察的关键，在找工作前，还是要刷个上百道算法题目的。 我们这个阶段的目标是：熟练使用 Java 语言来编写程序，巩固 Java 的基础。 那直接用 Java 来写算法题目，一举两得，岂不美哉？ ","date":"2022-08-13","objectID":"/blog/20220813_route/:3:1","tags":["java","study","Java学习路线"],"title":"Java 学习路线","uri":"/blog/20220813_route/"},{"categories":["Java"],"content":"Java 基础（30 天） 学习建议 建议大家去阅读 《Java 核心技术卷 1》，这本书堪称经典，是帮助你复习巩固 Java 的不二之选，其中图形界面章节可以选择不看。 之后可以刷牛客的 Java 练习题，检验自己的水平，我当时刷了两遍。 资源 书籍 ⭐《Java 核心技术卷 1》 练习 ⭐ 牛客题库 ","date":"2022-08-13","objectID":"/blog/20220813_route/:3:2","tags":["java","study","Java学习路线"],"title":"Java 学习路线","uri":"/blog/20220813_route/"},{"categories":["Java"],"content":"数据结构与算法 知识 时间 / 空间复杂度分析 数据结构 数组 字符串 队列 栈 链表 集合 哈希表 二叉树 算法 排序 双指针 查找 分治 动态规划 递归 回溯 贪心 位运算 DFS BFS 图 学习建议 学算法一定要多思考、多练习！！！ 在复习 Java、巩固基础的过程中，每天可以坚持用 Java 做 2 - 3 道算法题目。 不用担心看不懂，直接进入 LeetCode 学习板块 LeetBook，提供了免费的教程，文字、图解、动画讲算法、在线练习应有尽有，从 0 开始，跟着学习基础知识、跟着教程刷一些同类题目，培养算法思路。 之后再由简单到复杂、由通过率高到低，自主刷题，多看题解，举一反三。 有条件的朋友也可以试着参与竞赛，没什么门槛，可以帮助你集中精神，而且周赛的题目还是挺友好的~ 资源 文章 ⭐ 刷了 1000 多道算法题，一点心得：鱼皮原创 在线教程 ⭐ LeetCode LeetBook 在线刷题 ⭐ LeetCode 书籍 ⭐《小灰的漫画算法》 ⭐《剑指 Offer》 《程序员代码面试指南》 图解算法数据结构 LeetCode 101（C++） LeetCode 题解（C++） LeetCode Cookbook（Go 语言） 视频 尚硅谷 Java 数据结构与算法（难度比面试的要求大一些，适合希望更全面学习的朋友） Leetcode 真题解析 工具 VisuAlgo 数据结构和算法动态可视化 数据结构可视化 网站 五分钟学算法 ","date":"2022-08-13","objectID":"/blog/20220813_route/:3:3","tags":["java","study","Java学习路线"],"title":"Java 学习路线","uri":"/blog/20220813_route/"},{"categories":["Java"],"content":"计算机基础 知识 计算机网络 HTTP / HTTPS 协议 网络模型 UDP / TCP 协议 网络安全 域名解析 操作系统 进程、线程 进程 / 线程间通讯方式 进程调度算法 进程 / 线程状态 死锁 内存管理 学习建议 在巩固基础期间，我建议大家多去了解计算机基础知识，比如操作系统、计算机网络。 但这一块知识说实话挺枯燥的，对吧，你说说我现在项目都不会做，你又让我看这些理论，是不是想让我头秃。 我的建议是，可以先看有趣的课外书，比如《图解 HTTP》等等，对基础知识先有个大致的印象，等后面有时间了再系统学习。 比如还在校园就跟着学校的进度学习就成，自学的话可以看下 《计算机网络微课堂》、 《清华操作系统原理》视频，有实力的小伙伴，能看懂大黑书就更好了。 资源 视频 《计算机网络微课堂》 《清华操作系统原理》 书籍 ⭐《图解 HTTP》 《网络是怎样连接的》 ⭐《图解 TCP / IP》 《编码》 《30天自制操作系统》 《计算机网络-自顶向下方法》（难度较大，不推荐新手看） 《现代操作系统》（难度较大，不推荐新手看） 《深入理解计算机系统》（难度较大，不推荐新手看） ","date":"2022-08-13","objectID":"/blog/20220813_route/:3:4","tags":["java","study","Java学习路线"],"title":"Java 学习路线","uri":"/blog/20220813_route/"},{"categories":["Java"],"content":"尾声 巩固基础要花至少 1 个月的时间，当你读完《Java 核心技术卷1》并且不用查询文档也能熟练地用 Java 做题时，就可以接着往下了。 ","date":"2022-08-13","objectID":"/blog/20220813_route/:3:5","tags":["java","study","Java学习路线"],"title":"Java 学习路线","uri":"/blog/20220813_route/"},{"categories":["Java"],"content":"阶段 3：Java 企业开发基础 ","date":"2022-08-13","objectID":"/blog/20220813_route/:4:0","tags":["java","study","Java学习路线"],"title":"Java 学习路线","uri":"/blog/20220813_route/"},{"categories":["Java"],"content":"目标 面向薪资编程，学习实际工作要用的技术，并能 独立 做出一个具有完整功能的 Java Web 项目。 ","date":"2022-08-13","objectID":"/blog/20220813_route/:4:1","tags":["java","study","Java学习路线"],"title":"Java 学习路线","uri":"/blog/20220813_route/"},{"categories":["Java"],"content":"MySQL 数据库（7 天） 企业中大部分业务数据都是用关系型数据库存储的，因此数据库是后台开发同学的必备技能，其中 MySQL 数据库是目前的主流，也是面试时的重点。 知识 基本概念 MySQL 搭建 SQL 语句编写 约束 索引 事务 设计数据库表 性能优化 学习建议 其中，SQL 语句编写 和 设计数据库表 这两个能力一定要有！ 比如让你做一个学生管理系统，你要能想到需要哪些表，比如学生表、班级表；每个表需要哪些字段、字段类型。 这就要求大家多写 SQL、多根据实际的业务场景去练习设计能力。 资源 视频 ⭐ 老杜 - mysql入门基础 + 数据库实战（较新、内容相对精炼，有习题） 尚硅谷 - MySQL基础教程（小姐姐讲课，但感觉音质一般） 在线练习 ⭐ SQL 自学网 ⭐ SQL 在线运行 文档 SQL - 菜鸟教程 MySQL - 菜鸟教程 ","date":"2022-08-13","objectID":"/blog/20220813_route/:4:2","tags":["java","study","Java学习路线"],"title":"Java 学习路线","uri":"/blog/20220813_route/"},{"categories":["Java"],"content":"开发框架（60 天） Java 之所以能成为主流的企业开发语言，很大一部分原因是它完善的框架生态，用好框架，不仅能够大大提升开发效率，还能提高项目的稳定性、减少维护成本。 开发框架是后台开发工作中不可或缺的，也是面试考察的重点，一定要好好学！ 不知道 Java 能做什么的朋友们，学完开发框架，就会有答案啦。 下面给大家推荐的都是企业中应用最多的主流开发框架，知识点比较零碎，就放在一起讲了。 知识 Java Web 描述：Java 网页应用开发基础 前端基础 XML JSON Servlet Filter Listener JSP JSTL Cookie Session Spring 5 描述：Java 轻量级应用框架 IOC AOP 事务 SpringMVC 描述：Java 轻量级 web 开发框架 什么是 MVC？ 请求与响应 Restful API 拦截器 配置 执行过程 MyBatis 描述：数据访问框架，操作数据库进行增删改查等操作 增删改查 全局配置 动态 SQL 缓存 和其他框架的整合 逆向工程 MyBatis Plus 描述：Mybatis 的增强工具，能够简化开发、提高效率 引入 通用 CRUD 条件构造器 代码生成器 插件扩展 自定义全局操作 SpringBoot 2 描述：简化 Spring 应用的初始搭建以及开发过程，提高效率 常用注解 资源整合 高级特性 本地热部署 Spring Security 描述：Spring 的安全管理框架 用户认证 权限管理 Maven / Gradle 描述：项目管理工具 构建 依赖管理 插件 配置 子父工程 学习建议 由于技术较多，且框架之间存在一定的联系，因此建议大家看同一系列的视频教程（尚硅谷、狂神说等等都可以），以保证学习内容的连续以及体验上的一致。 学这些技术的时候，千万不能懒 ！一定要多记笔记，并且跟着老师写代码。原理部分不要太过纠结，先以能跟着敲出代码、写出可运行的项目为主，有些东西做出来也能帮助你更好地理解理论。 学习顺序挺重要的，建议按我推荐的顺序学，不要一上手就学 SpringBoot。只有先学习下自己整合框架的方法，才能帮你理解 SpringBoot 解决的问题，感受到它的方便和高效。 Maven / Gradle 当工具用就好，面试基本不问，跟着框架教程去用就行了，先不用花太多时间去深入学。 资源 视频（按顺序看） ⭐ 尚硅谷最新版 JavaWeb 全套教程（前端部分最好也看下） ⭐ 尚硅谷 - Spring 5 框架最新版教程（idea版） ⭐ 尚硅谷 - SpringMVC 2021 最新教程 ⭐ 尚硅谷 - MyBatis 实战教程全套完整版 ⭐ 尚硅谷 - MyBatisPlus 教程 Maven 零基础入门教程（搞不懂 Maven 可以看看） ⭐ 雷丰阳 2021 版 SpringBoot2 零基础入门 尚硅谷 - SpringSecurity 框架教程 ","date":"2022-08-13","objectID":"/blog/20220813_route/:4:3","tags":["java","study","Java学习路线"],"title":"Java 学习路线","uri":"/blog/20220813_route/"},{"categories":["Java"],"content":"开发规范（3 天） 开发不规范，同事两行泪。 开发规范是团队开发中必须遵守的，有利于提高项目的开发效率、降低维护成本。 知识 代码规范 代码风格 命名 其他规则 提交规范 学习建议 简单过一遍大厂团队的规范手册就好了，以后做项目的时候能想起来的话就去使用，或者从书中、网上查规范，再去遵守。 项目做得多了，自然会养成好的习惯，不用刻意去记（毕竟每个团队规范也不完全相同，背了也没用）。 资源 书籍 ⭐ 阿里巴巴 Java 开发手册（搜索《Java开发手册》） 视频 华山版《Java开发手册》独家讲解 文档 Google Java Style Guide（谷歌 Java 代码规范） ","date":"2022-08-13","objectID":"/blog/20220813_route/:4:4","tags":["java","study","Java学习路线"],"title":"Java 学习路线","uri":"/blog/20220813_route/"},{"categories":["Java"],"content":"Git（3 天） 此前大家可能听说过 GitHub，一流的代码开源托管平台。 Git 和它可不一样，是一个版本控制工具，可以更好地管理和共享项目代码，比如把自己的代码传到 GitHub 上、或者从远程下载。 无论自己做项目、还是团队开发，Git 都是现在不可或缺的神器。 知识 工作区 分支 代码提交、推送、拉取、回退、重置 分支操作 代码合并、解决冲突 标签 cherry-pick 学习建议 每个命令跟着敲一遍，有个大致的印象，会用即可，用的多了自然熟悉了。 资源 视频 ⭐【尚硅谷】5h打通Git全套教程丨2021最新IDEA版 书籍 猴子都能懂的 Git 入门 ⭐ GitHub 漫游指南 文档 GitHub 官方文档 游戏 Learning Git Branching ","date":"2022-08-13","objectID":"/blog/20220813_route/:4:5","tags":["java","study","Java学习路线"],"title":"Java 学习路线","uri":"/blog/20220813_route/"},{"categories":["Java"],"content":"Linux（10 天） 企业中的很多前后台项目都是部署在 Linux 服务器上的，因此很有必要熟悉 Linux 的操作和脚本的编写。 后面学微服务、学架构都是在多台服务器操作，如果你不熟悉 Linux，会有点吃力。 知识 Linux 系统安装 环境变量 文件管理 用户管理 内存管理 磁盘管理 进程管理 网络管理 软件包管理 服务管理 日志管理 Linux 内核 常用命令 常用环境搭建 Shell 脚本编程 VIM 的使用 学习建议 多动手实践，建议自己购买一台云服务器，并且在本地搭建 Linux 虚拟机环境。 一定要自己从 0 开始手敲命令安装软件、部署服务，熟悉整个项目的上线流程。 每个命令至少要跟着敲一遍，了解它们的作用，并通过自然地练习，熟悉常用的 Linux 命令。 记不住没关系，用文档查就行了。 先会用，再理解。 资源 视频 ⭐ 2021 韩顺平 一周学会Linux（基于 CentOS 7.6 版本较新） 书籍 《鸟哥的 Linux 私房菜 —— 基础篇》（经典） 文档 Linux 工具快速教程（基础、工具进阶、工具参考） 实战 ⭐ 蓝桥云课 Linux 基础入门 腾讯云动手实验室 阿里云体验实验室 阿里云知行实验室 华为云沙箱实验室 社区 Linux 中国 工具 ⭐ Linux 命令搜索 Linux 命令大全手册 Linux 命令示例 宝塔 Linux 面板 ","date":"2022-08-13","objectID":"/blog/20220813_route/:4:6","tags":["java","study","Java学习路线"],"title":"Java 学习路线","uri":"/blog/20220813_route/"},{"categories":["Java"],"content":"前端基础（14 天） 虽然 Java 程序员面试时基本不会出现前端相关问题，但是在企业中，往往需要前后端程序员配合完成工作。会一些前端，不仅可以提高你们的协作效率，还能提高自己对整个项目的了解和掌控力，甚至能独立开发出一个完整项目！这点也是能给面试加分的。 知识 HTML CSS JavaScript Ajax Vue 学习建议 不需要学习太多的前端技术，熟悉下基础的前端三件套，了解前端是如何向后端发送请求来做数据交互的一般就够了。有时间的话可以学下 Vue ，是比较容易上手的主流前端开发框架，Vue + SpringBoot 还是很香的。 ","date":"2022-08-13","objectID":"/blog/20220813_route/:4:7","tags":["java","study","Java学习路线"],"title":"Java 学习路线","uri":"/blog/20220813_route/"},{"categories":["Java"],"content":"阶段 4：Java 企业开发进阶 ","date":"2022-08-13","objectID":"/blog/20220813_route/:5:0","tags":["java","study","Java学习路线"],"title":"Java 学习路线","uri":"/blog/20220813_route/"},{"categories":["Java"],"content":"目标 学习更多企业级开发技术和编程思想，能够结合多种技术，独立开发出架构合理的完整系统，解决实际问题 。 要了解为什么需要这个技术？什么时候用哪些技术？ ","date":"2022-08-13","objectID":"/blog/20220813_route/:5:1","tags":["java","study","Java学习路线"],"title":"Java 学习路线","uri":"/blog/20220813_route/"},{"categories":["Java"],"content":"设计模式（21 天） 设计模式是软件开发中解决一类问题的通用方法。 使用设计模式能让你写出更优雅、可维护的代码，也正因如此，很多框架源码都用到了设计模式，你不学很难看懂。 知识 创建型模式：对象实例化的模式，创建型模式用于解耦对象的实例化过程 单例模式 工厂方法模式 抽象工厂 建造者模式 原型模式 结构型模式：把类或对象结合在一起形成一个更大的结构 适配器模式 组合模式 装饰器模式 代理模式 享元模式 外观模式 桥接模式 行为型模式：类和对象如何交互，及划分责任和算法 迭代器模式 模板方法模式 策略模式 命令模式 状态模式 责任链模式 备忘录模式 观察者模式 访问者模式 中介者模式 解释器模式 学习建议 先理解概念，了解每个设计模式的特点和应用场景，再多加练习，运用到实际项目。 资源 书籍 ⭐《图解设计模式》（强烈推荐这本书，正是用 Java 语言实现，图多、有示例代码、有习题和答案，很不错） 《Head First 设计模式》 《大话设计模式》 《设计模式：可复用面向对象软件的基础》（大黑书，有能力的话也可以去读） 视频 尚硅谷图解 Java 设计模式 文档 菜鸟教程 图说设计模式 ","date":"2022-08-13","objectID":"/blog/20220813_route/:5:2","tags":["java","study","Java学习路线"],"title":"Java 学习路线","uri":"/blog/20220813_route/"},{"categories":["Java"],"content":"中间件（14 天） 除了框架外，企业项目开发也会用到大量独立的中间件，以解决某些实际问题，比如提高项目的性能、提高项目的稳定性和可靠性等。 下面分享几个最常用的主流中间件。 知识 Redis 缓存 数据类型 常用操作 Java 操作 Redis 主从模型搭建 哨兵集群搭建 日志持久化 应用场景 RabbitMQ 消息队列 消息队列的作用 生产消费模型 交换机模型 死信队列 延迟队列 消息持久化 Java 操作 集群搭建 Nginx 网关 Nginx 作用 正向代理 反向代理（负载均衡） 常用命令 配置 动静分离（网站部署） 集群搭建 学习建议 学会如何使用中间件并不难，先能够独立使用，了解他们的应用场景；再用 Java 来操作中间件，和项目相结合。 跟着视频教程实操一遍即可，可以等到面试前再去深入了解原理和高级特性。 资源 视频 ⭐ 尚硅谷 - 2021 最新 Redis 6 入门到精通教程（基于 Redis 6 的，推荐） ⭐ 尚硅谷 - 2021 最新 RabbitMQ 教程（很新很全面） ⭐ 尚硅谷 - Nginx 教程由浅入深（讲的比较全面） ⭐ Nginx 鱼皮 - 手把手带你从0搭建个人网站（简单演示 Nginx 部署网站） 文档 Redis 命令参考 Redis 面试题整理 RabbitMQ 中文文档 Nginx 中文文档 书籍 《Redis 实战》（经典） 《RabbitMQ 实战：高效部署分布式消息队列》（经典） 工具 ⭐ Redis 在线练习（强烈推荐） ⭐ RabbitMQ 在线模拟器 Nginx 配置在线生成 相关技术 缓存：Memcached、Ehcache 队列：Kafka、ActiveMQ、TubeMQ、RocketMQ 网关：HAProxy ","date":"2022-08-13","objectID":"/blog/20220813_route/:5:3","tags":["java","study","Java学习路线"],"title":"Java 学习路线","uri":"/blog/20220813_route/"},{"categories":["Java"],"content":"Netty 网络编程（14 天） 开源的 Java 网络编程框架，用于开发高性能（事件驱动、异步非阻塞）、高可靠的网络服务器和客户端程序。 很多网络框架和服务器程序都用到了 Netty 作为底层，学好 Netty 不仅可以让我们自己实现高性能服务器，也能更好地理解其他的框架应用、阅读源码。 知识 IO 模型（BIO / NIO） Channel Buffer Seletor Netty 模型 WebSocket 编程（动手做个聊天室） 学习建议 不同于之前学的 SSM 框架，Netty 还是需要一定学习成本的，一方面是国内资源太缺乏，另一方面很多重要的概念（比如 NIO）还是要多动手写代码调试才能理解。 还是建议先从视频入门，并且不建议在 Netty 上花太多时间，面试的时候一般也就考察一些 Netty 思想。 资源 视频 ⭐ 尚硅谷Netty教程 Netty 技术演讲（中文字幕版） 文档 Netty 4 用户指南 书籍 《Netty 实战》 相关技术 Vertx（比 Netty 简单多了，实在看不懂 Netty 也可以学习下这个） ","date":"2022-08-13","objectID":"/blog/20220813_route/:5:4","tags":["java","study","Java学习路线"],"title":"Java 学习路线","uri":"/blog/20220813_route/"},{"categories":["Java"],"content":"微服务（60 天） 随着互联网的发展，项目越来越复杂，单机且庞大的巨石项目已无法满足开发、运维、并发、可靠性等需求。 因此，后台架构不断演进，可以将庞大的项目拆分成一个个职责明确、功能独立的细小模块，模块可以部署在多台服务器上，相互配合协作，提供完整的系统能力。 换言之，想做大型项目，这块儿一定要好好学！ 知识 Dubbo 架构演进 RPC Zookeeper 服务提供者 服务消费者 项目搭建 微服务 微服务概念 Spring Cloud 框架 子父工程 服务注册与发现 注册中心 Eureka、Zookeeper、Consul Ribbon 负载均衡 Feign 服务调用 Hystrix 服务限流、降级、熔断 Resilience4j 服务容错 Gateway（Zuul）微服务网关 Config 分布式配置中心 分布式服务总线 分布式链路追踪 Spring Cloud Alibaba Nacos 注册、配置中心 OpenFeign 服务调用 Sentinel 流控 Seata 分布式事务 接口管理 Swagger 接口文档 Postman 接口测试 学习建议 时间不急的话，建议先从 Dubbo 学起，对分布式、RPC、微服务有些基本的了解，再去食用 Spring Cloud 全家桶会更香。 这部分内容的学习，原理 + 实践都很重要，也不要被各种高大上的词汇唬住了，都是上层（应用层）的东西，基本没有什么算法，跟着视频教程学，其实还是很好理解的。 分布式相关知识非常多，但这里不用刻意去背，先通过视频教程实战使用一些微服务框架，也能对其中的概念有基本的了解。 资源 视频 ⭐ 尚硅谷 Dubbo 教程 ⭐ 尚硅谷 SpringCloud（H版\u0026alibaba）框架开发教程（微服务分布式架构）（把国外的 Spring Cloud 和国内的 Spring Cloud Alibaba 结合在一起对比着去讲，主流技术栈、知识点都讲到了，真心不错！） 文档 Apache Dubbo 官方文档 Spring Cloud Alibaba 官方文档 ⭐ Swagger 教学文档（跟着快速开始直接用就好了） ","date":"2022-08-13","objectID":"/blog/20220813_route/:5:5","tags":["java","study","Java学习路线"],"title":"Java 学习路线","uri":"/blog/20220813_route/"},{"categories":["Java"],"content":"容器（7 天） 将应用和环境进行封装，相互隔离、独立部署、便于移植，提高安全性、提高开发和维护效率。 便于实现微服务、持续集成和交付。 知识 Docker 容器概念 镜像 部署服务 Dockerfile K8S（Kubernetes） 架构 部署应用 暴露服务 动态扩缩容 学习建议 会用 Docker / K8S 部署项目和服务就行，企业一般都有现成的平台直接用，面试考察不多，不用花太多时间。 资源 视频 ⭐【狂神说】Docker 最新超详细版教程通俗易懂 K8S 视频教程 书籍 《深入浅出 Docker》 文档 Docker — 从入门到实践 菜鸟教程 Docker 国外 Docker 官方文档 网站 Docker 中文社区（强烈推荐，有很多 Docker 技术文章和学习笔记） Docker Blog（国外 Docker 技术博客） 镜像源 Docker Hub 腾讯软件源 阿里云 Docker 仓库 ","date":"2022-08-13","objectID":"/blog/20220813_route/:5:6","tags":["java","study","Java学习路线"],"title":"Java 学习路线","uri":"/blog/20220813_route/"},{"categories":["Java"],"content":"CI / CD（3 天） 持续集成 / 持续交付，贯穿整个研发到项目上线的过程，提高效率。 大公司一般都有自己的 CI / CD 平台。 知识 什么是 CI / CD CI / CD 有什么好处 使用任一 CI / CD 平台 学习建议 了解它是什么，并且实战使用任一 CI / CD 平台，感受它和传统开发运维到底有什么不同，就足够了。其实很简单，不要花太多时间。 真正要自己去搭建的时候，跟着官方文档来就行。 资源 视频 ⭐【狂神说】CI/CD到底是什么？十分钟理解企业级DevOps（讲的非常棒！带你快速理解 CI / CD 的作用和部分原理） 尚硅谷 - Jenkins 持续集成工具教程（实在要用到 Jenkins 再去学） 文档 Jenkins 官方文档（有很多案例，要用的时候查一下就行了） 实战平台 ⭐ 微信云托管 前端托管 Webify ","date":"2022-08-13","objectID":"/blog/20220813_route/:5:7","tags":["java","study","Java学习路线"],"title":"Java 学习路线","uri":"/blog/20220813_route/"},{"categories":["Java"],"content":"阶段 5：项目实战 ","date":"2022-08-13","objectID":"/blog/20220813_route/:6:0","tags":["java","study","Java学习路线"],"title":"Java 学习路线","uri":"/blog/20220813_route/"},{"categories":["Java"],"content":"目标 综合所学技术从 0 到 1 开发和上线一个全面、有特色的、可以写进简历的个人项目。 ","date":"2022-08-13","objectID":"/blog/20220813_route/:6:1","tags":["java","study","Java学习路线"],"title":"Java 学习路线","uri":"/blog/20220813_route/"},{"categories":["Java"],"content":"学习建议 其实在之前的框架学习视频中应该就做过几个项目了，但相对不够完整和体系化。 有想法的同学可以做任何自己想做的项目，推荐参加一些作品类竞赛，练手、拿奖、收获项目经历一举三得。 暂时没想法的朋友，建议先跟着专门带做项目的视频教程做 1 - 2 套 Java 完整项目，一定要从 0 到 1 自己手写！ 有能力的朋友也可以试着用 GitHub 上的源码来学习啦~ 做一个完整的项目的确很不容易，建议大家根据自己的 时间、兴趣 选择 较新的、有配套源码的 教程，保持耐心。 下面推荐一些优质的、较新的项目实战视频教程 + 50 套项目源码。 ","date":"2022-08-13","objectID":"/blog/20220813_route/:6:2","tags":["java","study","Java学习路线"],"title":"Java 学习路线","uri":"/blog/20220813_route/"},{"categories":["Java"],"content":"视频教程 尚硅谷 - 谷粒学院 - 微服务 + 全栈 - 在线教育实战项目（全栈项目，前后端讲得都很全面） 尚硅谷 - 尚筹网 - Java项目实战开发教程 - SSM 框架 + 微服务架构（500 多集，包含完整的用户权限管理，功能丰富、讲得很细致全面） 黑马 - 24 小时搞定 Java 毕设电商项目 黑马程序员 Java 项目《传智健康》，超完整的企业级医疗行业项目 黑马程序员 Java 项目《万信金融》企业级开发实战，互联网金融行业解决方案 黑马程序员 Java 项目 SaaS 移动办公完整版《iHRM 人力资源管理系统》，跨行业 SaaS 办公整合性解决方案 黑马程序员 Java 大型分布式微服务闪聚支付项目，Java 移动支付全生态系统 黑马程序员 Java 项目《好客租房》 ","date":"2022-08-13","objectID":"/blog/20220813_route/:6:3","tags":["java","study","Java学习路线"],"title":"Java 学习路线","uri":"/blog/20220813_route/"},{"categories":["Java"],"content":"项目源码（50 套） 电商秒杀 天猫整站 J2EE 天猫整站 SSM 天猫整站 Springboot mall-learning（学习教程，架构、业务、技术要点全方位解析） SpringBoot 电商商城系统 Mall4j SpringBoot 完整电商系统 Mall（包括前台商城系统及后台管理系统，基于 SpringBoot+MyBatis 实现） newbee-mall（一套电商系统，包括 newbee-mall 商城系统及 newbee-mall-admin 商城后台管理系统，基于 Spring Boot 2.X 及相关技术栈开发） paascloud-master：\u003c\u003e（基于 spring cloud + vue + oAuth2.0，前后端分离商城系统） mall-swarm（一套微服务商城系统，采用了 Spring Cloud Greenwich、Spring Boot 2、MyBatis、Docker、Elasticsearch 等核心技术，同时提供了基于 Vue 的管理后台方便快速搭建系统） onemall（mall 商城，基于微服务的思想，构建在 B2C 电商场景下的项目实战。核心技术栈，是 Spring Boot + Dubbo 。未来，会重构成 Spring Cloud Alibaba） litemall（又一个小商城，litemall = Spring Boot 后端 + Vue 管理员前端 + 微信小程序用户前端 + Vue 用户移动端） xmall （基于SOA架构的分布式电商购物商城 前后端分离 前台商城:Vue全家桶 后台管理系统） miaosha（秒杀系统设计与实现） SecKill（基于 SpringBoot+Mybatis+Redis+RabbitMQ 秒杀系统） 博客论坛 Mblog：开源 Java 博客系统 halo：一个优秀的开源博客发布应用 forum-java：一款用 Java（spring boot） 实现的现代化社区（论坛/问答/BBS/社交网络/博客）系统平台 vhr：微人事是一个前后端分离的人力资源管理系统，项目采用 SpringBoot+Vue 开发。 favorites-web:云收藏 Spring Boot 2.X 开源项目。云收藏是一个使用 Spring Boot 构建的开源网站，可以让用户在线随时随地收藏的一个网站，在网站上分类整理收藏的网站或者文章。 community：码问，开源论坛、问答系统，现有功能提问、回复、通知、最新、最热、消除零回复功能。技术栈 Spring、Spring Boot、MyBatis、MySQL/H2、Bootstrap NiterForum：尼特社区-NiterForum-一个论坛/社区程序。后端Springboot/MyBatis/Maven/MySQL，前端Thymeleaf/Layui。可供初学者，学习、交流使用。 VBlog：V部落，Vue+SpringBoot实现的多用户博客管理平台! NiceFish：SpringBoot/SpringCloud 前后端分离项目 My-Blog： My Blog 是由 SpringBoot + Mybatis + Thymeleaf 等技术实现的 Java 博客系统，页面美观、功能齐全、部署简单及完善的代码，一定会给使用者无与伦比的体验。 My-Blog-layui：layui 版本的 My-Blog : A simple \u0026 beautiful blogging system implemented with spring-boot \u0026 layui \u0026 thymeleaf \u0026 mybatis My Blog 是由 SpringBoot + Layui + Mybatis + Thymeleaf 等技术实现的 Java 博客系统，页面美观、功能齐全、部署简单及完善的代码，一定会给使用者无与伦比的体验 symphony：Java 实现的现代化社区 管理系统 Spring-Cloud-Admin：Cloud-Admin 是国内首个基于 Spring Cloud 微服务化开发平台，具有统一授权、认证后台管理系统，其中包含具备用户管理、资源权限管理、网关 API 管理等多个模块，支持多业务系统并行开发，可以作为后端服务的开发脚手架。代码简洁，架构清晰，适合学习和直接项目中使用。核心技术采用 Spring Boot2 以及 Spring Cloud Gateway 相关核心组件，前端采用 vue-element-admin 组件。 bootshiro：基于 springboot+shiro+jwt 的资源无状态认证权限管理系统后端 悟空CRM：基于jfinal+vue+ElementUI的前后端分离CRM系统 EL-ADMIN：基于 SpringBoot 的后台管理系统 pig：基于 Spring Boot 2.2、 Spring Cloud Hoxton \u0026 Alibaba、 OAuth2 的 RBAC 权限管理系统。 FEBS-Shiro：Spring Boot 2.1.3，Shiro1.4.0 \u0026 Layui 2.5.4 权限管理系统。 Spring Boot-Shiro-Vue：基于Spring Boot-Shiro-Vue 的权限管理 studentmanager：基于springboot+mybatis学生管理系统 jshERP：华夏ERP基于SpringBoot框架和SaaS模式，立志为中小企业提供开源好用的ERP软件，目前专注进销存+财务功能。主要模块有零售管理、采购管理、销售管理、仓库管理、财务管理、报表查询、系统管理等。支持预付款、收入支出、仓库调拨、组装拆卸、订单等特色功能。拥有库存状况、出入库统计等报表。同时对角色和权限进行了细致全面控制，精确到每个按钮和菜单。 HotelSystem：酒店管理系统 Java,tomcat,mysql,servlet,jsp实现，没有使用任何框架 开发平台 open-capacity-platform：微服务能力开发平台 jeecg-boot：JeecgBoot是一款基于BPM的低代码平台！前后端分离架构 SpringBoot 2.x，SpringCloud，Ant Design\u0026Vue，Mybatis-plus，Shiro，JWT，支持微服务。强大的代码生成器让前后端代码一键生成，实现低代码开发！ 其他 学之思在线考试系统：一款 java + vue 的前后端分离的考试系统 PassJava-Platform：一款面试刷题的 Spring Cloud 开源系统 kkFileView：使用spring boot打造文件文档在线预览项目 dynamic-datasource：一个基于springboot的快速集成多数据源的启动器 moti-cloud：莫提网盘，基于 SpringBoot+MyBatis+ThymeLeaf+BootStrap，适合初学者 threadandjuc：three-high-import 高可用\\高可靠\\高性能，三高多线程导入系统（该项目意义为理论贯通) proxyee-down：http下载工具，基于http代理，支持多连接分块下载 hosp_order：医院预约挂号系统，基于 SSM 框架 趋势投资 SpringCloud DiyTomcat ","date":"2022-08-13","objectID":"/blog/20220813_route/:6:4","tags":["java","study","Java学习路线"],"title":"Java 学习路线","uri":"/blog/20220813_route/"},{"categories":["Java"],"content":"阶段 6：Java 高级 ","date":"2022-08-13","objectID":"/blog/20220813_route/:7:0","tags":["java","study","Java学习路线"],"title":"Java 学习路线","uri":"/blog/20220813_route/"},{"categories":["Java"],"content":"目标 不满足于能做，而是通过更 深入 和 广泛 的学习，实现高质量的代码和更优秀的架构，培养解决问题的能力。 ","date":"2022-08-13","objectID":"/blog/20220813_route/:7:1","tags":["java","study","Java学习路线"],"title":"Java 学习路线","uri":"/blog/20220813_route/"},{"categories":["Java"],"content":"并发编程（21 天） 对 Java 后端开发程序员来说，懂得如何利用有限的系统资源来提高系统的性能是很重要的，也是大厂面试考察的重点，因此并发编程（尤其是 Java 并发包的使用）这块的知识很重要。 把它放到高级，是因为在学并发编程前，需要有一定的编程经验、了解一定的操作系统知识。 知识 线程和进程 线程状态 并行和并发 同步和异步 Synchronized Volatile 关键字 Lock 锁 死锁 可重入锁 线程安全 线程池 JUC 的使用 AQS Fork Join CAS 学习建议 并发编程入门不难，依然是 先学会使用 基础的 Java 并发包， 再通过大量地实践和测试，了解一些原理，才能真正掌握何时使用、如何更合理地使用并发编程。 资源 视频 ⭐【尚硅谷】大厂必备技术之JUC并发编程2021最新版（特点是短、精、新） 黑马程序员全面深入学习Java并发编程（讲的很细、全面深入） 书籍 ⭐《Java并发编程实战》（国外的经典） ⭐《Java 并发编程艺术》（国人写的，理论思想内容较多，有时间建议反复看） 项目 ⭐ Java 并发知识点总结 ","date":"2022-08-13","objectID":"/blog/20220813_route/:7:2","tags":["java","study","Java学习路线"],"title":"Java 学习路线","uri":"/blog/20220813_route/"},{"categories":["Java"],"content":"JVM（30 天） 想要深入理解 Java，探秘 Java 跨平台的奥秘，一定要了解 Java 底层的虚拟机技术。 了解虚拟机、掌握虚拟机性能调优方法，有助于你写出更高性能、资源占用更小的优质程序。 在学习 JVM 的过程中，也能学到很多精妙的设计，开拓思路。 知识 JVM 内存结构 JVM 生命周期 主流虚拟机 Java 代码执行流程 类加载 类加载器 类加载过程 双亲委派机制 垃圾回收 垃圾回收器 垃圾回收策略 垃圾回收算法 StopTheWorld 字节码 内存分配和回收 JVM 性能调优 性能分析方法 常用工具 参数设置 学习建议 JVM 的知识略显枯燥，建议先看视频，有实操的地方一定要实操！自己多去分析。 第一遍不理解没有关系，可以再看书来巩固，想要真正学好，《深入理解 Java 虚拟机（第三版）》一定要读。 如果只是为了通过面试可以直接看更精简的视频，比如狂神的。 资源 视频 ⭐ 尚硅谷宋红康 - JVM 全套教程详解（讲得相当全面！附有实操） 【狂神说Java】JVM快速入门篇（讲得有点浅，但都是面试重点，时间紧的小伙伴可以直接看这个） 书籍 ⭐《深入理解 Java 虚拟机（第三版）》（有理论有实践，内容丰富，不可多得的 JVM 学习神书，就是有点废头发） 项目 ⭐ Java 虚拟机底层原理知识总结 实战 阿里云 JVM 实战 ","date":"2022-08-13","objectID":"/blog/20220813_route/:7:3","tags":["java","study","Java学习路线"],"title":"Java 学习路线","uri":"/blog/20220813_route/"},{"categories":["Java"],"content":"架构设计 分布式 分布式理论 CAP BASE 分布式缓存 Redis Memcached Etcd 一致性算法 Raft 一致性哈希 分布式事务 分布式 id 生成 分布式服务调用 分布式存储 分布式数据库 分布式文件系统 分布式协调 Zookeeper 分布式监控 Prometheus 分布式消息队列 RabbitMQ Kafka Apache Pulsar 分布式日志收集 Elastic Stack Loki 分布式搜索引擎 Elasticsearch 分布式链路追踪 Apache SkyWalking 分布式配置中心 Apollo Nacos 高可用 主从 异地多活 容灾备份 高并发 数据库 分库分表 读写分离 缓存 缓存雪崩 缓存击穿 缓存穿透 负载均衡 负载均衡算法 软硬件负载均衡（2、3、4、7 层） 其他 监控告警 领域驱动设计 应用安全 线上故障分析 服务网格 Serverless 云原生 学习建议 多看文章多思考 ","date":"2022-08-13","objectID":"/blog/20220813_route/:7:4","tags":["java","study","Java学习路线"],"title":"Java 学习路线","uri":"/blog/20220813_route/"},{"categories":["Java"],"content":"阶段 7：Java 求职 ","date":"2022-08-13","objectID":"/blog/20220813_route/:8:0","tags":["java","study","Java学习路线"],"title":"Java 学习路线","uri":"/blog/20220813_route/"},{"categories":["Java"],"content":"目标 找到好工作 ","date":"2022-08-13","objectID":"/blog/20220813_route/:8:1","tags":["java","study","Java学习路线"],"title":"Java 学习路线","uri":"/blog/20220813_route/"},{"categories":["Java"],"content":"建议 尽早做规划，可以通过大厂招聘官网的岗位描述来了解岗位的要求 雕琢一份优秀的简历，推荐阅读 多读面经，坚持刷算法 多参与面试，持续复盘总结 ","date":"2022-08-13","objectID":"/blog/20220813_route/:8:2","tags":["java","study","Java学习路线"],"title":"Java 学习路线","uri":"/blog/20220813_route/"},{"categories":["Java"],"content":"资源 岗位要求 阿里 Java 开发 腾讯后台开发 腾讯全栈开发 腾讯运营开发 美团后端开发 华为软件开发 知识总结 ⭐ 牛客 Java 面试宝典 ⭐ JavaGuide ⭐ CS-Notes 阿里 Java 技术图谱 面经 ⭐ 2021 最新 Java 笔试、面试题合集（密码：lkw1） ⭐ 牛客面经 视频 ⭐ 尚硅谷 2021 逆袭版 Java 面试题第三季 ⭐ 阿里大佬透彻讲解 Java 面试 500 道必考题 ","date":"2022-08-13","objectID":"/blog/20220813_route/:8:3","tags":["java","study","Java学习路线"],"title":"Java 学习路线","uri":"/blog/20220813_route/"},{"categories":["Java"],"content":"阶段 8：持续学习 ","date":"2022-08-13","objectID":"/blog/20220813_route/:9:0","tags":["java","study","Java学习路线"],"title":"Java 学习路线","uri":"/blog/20220813_route/"},{"categories":["Java"],"content":"目标 持续追求技术的深度和广度，培养自己的 核心竞争力 和 不可替代性 ，学无止境！ ","date":"2022-08-13","objectID":"/blog/20220813_route/:9:1","tags":["java","study","Java学习路线"],"title":"Java 学习路线","uri":"/blog/20220813_route/"},{"categories":["Java"],"content":"学习建议 自主学习，自主搜索教程，多看书，多阅读技术博客，多实践。 ","date":"2022-08-13","objectID":"/blog/20220813_route/:9:2","tags":["java","study","Java学习路线"],"title":"Java 学习路线","uri":"/blog/20220813_route/"},{"categories":["Java"],"content":"学习方向 框架源码 Spring SpringBoot SpringMVC MyBatis Netty Dubbo SpringCloud 计算机原理 《算法导论》 《现代操作系统》 《深入理解计算机系统》 《编译原理》 《计算机网络：自顶向下方法》 《计算机程序的构造和解释》 《数据库系统概念》 数据库 / 中间件 / 分布式 数据库 MySQL PostgreSQL 缓存 Redis 队列 Apache Kafka Apache Pulsar 搜索引擎 Elastic Stack 容器 Docker K8S 解决方案 广告 电商 搜索 游戏 即时通讯 社交 CMS ERP OA 架构 亿级流量架构 秒杀系统 架构选型能力 大数据 5V 特点 Hadoop HDFS MapReduce Spark Flink Storm Hive HBase Druid Kylin Pig Mahout 前沿技术 云原生 Quasar Framework ","date":"2022-08-13","objectID":"/blog/20220813_route/:9:3","tags":["java","study","Java学习路线"],"title":"Java 学习路线","uri":"/blog/20220813_route/"},{"categories":["Java"],"content":"自学 Java 专题资源 GitHub Java 专区 GitHub Java 合集 StackOverflow（解决问题必备） 掘金 Java 专区 美团技术团队 阿里技术团队 有赞技术团队 ","date":"2022-08-13","objectID":"/blog/20220813_route/:9:4","tags":["java","study","Java学习路线"],"title":"Java 学习路线","uri":"/blog/20220813_route/"},{"categories":["Java"],"content":"尾声 ","date":"2022-08-13","objectID":"/blog/20220813_route/:10:0","tags":["java","study","Java学习路线"],"title":"Java 学习路线","uri":"/blog/20220813_route/"},{"categories":["Java"],"content":"编程误区 我不适合学编程？❌（兴趣比天赋更重要，不要怀疑自己） 忽视基础，急于求成 ❌（勿以浮沙筑高台） 数学、英语差，就学不好编程 ❌（开发工作基本不用高等数学，英语可以使用翻译软件、工作中提升） 编程时，刻意记忆代码 ❌（知道每行代码的意义，能看文档写出来就行） 每行代码都要追求完美 ❌（何为完美？每个人的定义不同） 用百度搜索、复制粘贴的都是菜鸡程序员 ❌（艹） 我做的项目太小了，就不整理了 ❌（自己的每个项目都要整理，可以记录自己的成长） 跟别人交流很麻烦，我更愿意自己写代码 ❌（1 + 1 \u003e 2，切勿闭门造车，不过也要找到合适的同学去交流） 做别人做过的项目没有意义 ❌（连别人做过的项目都做不出，还想造新轮子？） 遇到 Bug，想办法绕过而不是寻找解决方案 ❌（Bug 最能使人成长） 遇到问题，第一时间去问别人而非自己解决 ❌（建议阅读《提问的智慧》） 花了很多时间、看了很多书，就能学好编程 ❌（编程最忌讳纸上谈兵） 只向前学习，不整理学过的知识 ❌（建议每学完一个知识，都去回想、总结、写心得，这个时间的花费是值得的） 单元测试不重要 ❌（一棍打死） 写文档不重要 ❌（一棍打死） 和我无关的工作，就不需要了解 ❌（了解团队、同行是很重要的，全局视野） 收藏的资源从来不看，就不收藏了 ❌（万一以后用到了呢？） 不去考虑需求的价值，而是一味寻求解决方案 ❌（不要成为需求机器，要有自己的独立思考） 资料参照：程序员鱼皮 （创作不易，转载下载请注明创者，谢谢） ","date":"2022-08-13","objectID":"/blog/20220813_route/:10:1","tags":["java","study","Java学习路线"],"title":"Java 学习路线","uri":"/blog/20220813_route/"},{"categories":["Daily"],"content":"消去浮躁，沉淀精华.","date":"2022-08-07","objectID":"/blog/20220807/","tags":["daily","study"],"title":"决定重新回归","uri":"/blog/20220807/"},{"categories":["Daily"],"content":"去浮去燥，砥砺前行 ","date":"2022-08-07","objectID":"/blog/20220807/:0:0","tags":["daily","study"],"title":"决定重新回归","uri":"/blog/20220807/"},{"categories":["Daily"],"content":"起因 回想起自己因为备考以及种种原因，已经将近一年没有真正自己独立开发代码了，会想之前手撕代码的日子还是很怀念的，虽让当时很累，天天能在电脑面前坐上个十几个小时（非卷王），但那时真的收获满满，心满意足😀，现在虽然已经成功上岸，但新的目标也随之而来，进入大厂，我深知进入大厂的难度，毕竟谁不想年入百万呢😁，今天我再次登陆我的GitHub时，看着当年满腔热血搭建的Blog，至今还没有发布任何像样文章，真是感慨万千，于是我今天又重新部署完成了我的Blog，以便记录自己的成长，完善自我，早日成为别人眼中的大牛🐮。 ","date":"2022-08-07","objectID":"/blog/20220807/:0:1","tags":["daily","study"],"title":"决定重新回归","uri":"/blog/20220807/"},{"categories":["Daily"],"content":"计划 从现在开始，我要给自己制定相应日程目标，不能再每天只是娱乐至上了🙈 根据学习路线图查漏补缺（学习路线图后面会制作） 每天刷题，保持头脑（选择+编程） 遇到经常犯的错误或难题解决后，通过Blog记录下来，以便自己温习 每天空闲时间看看大牛技术分享以及分享的面经 ","date":"2022-08-07","objectID":"/blog/20220807/:0:2","tags":["daily","study"],"title":"决定重新回归","uri":"/blog/20220807/"},{"categories":["Daily"],"content":"总结 虽然不知道后面会继续到哪里，但总算迈出了今天的第一步，后面我也会继续努力，朝着自己预期的目标拼劲全力，加油阿豪，未来可期！ ","date":"2022-08-07","objectID":"/blog/20220807/:0:3","tags":["daily","study"],"title":"决定重新回归","uri":"/blog/20220807/"},{"categories":["Hugo"],"content":"Hugo 中的 Emoji 的用法指南.","date":"2021-07-01","objectID":"/blog/emoji/","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"Emoji 可以通过多种方式在 Hugo 项目中启用. emojify 方法可以直接在模板中调用, 或者使用行内 Shortcodes. 要全局使用 emoji, 需要在你的网站配置中设置 enableEmoji 为 true, 然后你就可以直接在文章中输入 emoji 的代码. 它们以冒号开头和结尾，并且包含 emoji 的 代码: 去露营啦! :tent: 很快就回来. 真开心! :joy: 呈现的输出效果如下: 去露营啦! ⛺ 很快就回来. 真开心! 😂 以下符号清单是 emoji 代码的非常有用的参考. ","date":"2021-07-01","objectID":"/blog/emoji/:0:0","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"表情与情感 ","date":"2021-07-01","objectID":"/blog/emoji/:1:0","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"笑脸表情 图标 代码 图标 代码 😀 grinning 😃 smiley 😄 smile 😁 grin 😆 laughing satisfied 😅 sweat_smile 🤣 rofl 😂 joy 🙂 slightly_smiling_face 🙃 upside_down_face 😉 wink 😊 blush 😇 innocent ","date":"2021-07-01","objectID":"/blog/emoji/:1:1","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"爱意表情 图标 代码 图标 代码 😍 heart_eyes 😘 kissing_heart 😗 kissing ☺️ relaxed 😚 kissing_closed_eyes 😙 kissing_smiling_eyes ","date":"2021-07-01","objectID":"/blog/emoji/:1:2","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"吐舌头表情 图标 代码 图标 代码 😋 yum 😛 stuck_out_tongue 😜 stuck_out_tongue_winking_eye 😝 stuck_out_tongue_closed_eyes 🤑 money_mouth_face ","date":"2021-07-01","objectID":"/blog/emoji/:1:3","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"带手的表情 图标 代码 图标 代码 🤗 hugs 🤔 thinking ","date":"2021-07-01","objectID":"/blog/emoji/:1:4","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"中性表情 图标 代码 图标 代码 🤐 zipper_mouth_face 😐 neutral_face 😑 expressionless 😶 no_mouth 😏 smirk 😒 unamused 🙄 roll_eyes 😬 grimacing 🤥 lying_face ","date":"2021-07-01","objectID":"/blog/emoji/:1:5","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"困倦的表情 图标 代码 图标 代码 😌 relieved 😔 pensive 😪 sleepy 🤤 drooling_face 😴 sleeping ","date":"2021-07-01","objectID":"/blog/emoji/:1:6","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"不适的表情 图标 代码 图标 代码 😷 mask 🤒 face_with_thermometer 🤕 face_with_head_bandage 🤢 nauseated_face 🤧 sneezing_face 😵 dizzy_face ","date":"2021-07-01","objectID":"/blog/emoji/:1:7","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"戴帽子的表情 图标 代码 图标 代码 🤠 cowboy_hat_face ","date":"2021-07-01","objectID":"/blog/emoji/:1:8","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"戴眼镜的表情 图标 代码 图标 代码 😎 sunglasses 🤓 nerd_face ","date":"2021-07-01","objectID":"/blog/emoji/:1:9","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"担心的表情 图标 代码 图标 代码 😕 confused 😟 worried 🙁 slightly_frowning_face ☹ frowning_face 😮 open_mouth 😯 hushed 😲 astonished 😳 flushed 😦 frowning 😧 anguished 😨 fearful 😰 cold_sweat 😥 disappointed_relieved 😢 cry 😭 sob 😱 scream 😖 confounded 😣 persevere 😞 disappointed 😓 sweat 😩 weary 😫 tired_face ","date":"2021-07-01","objectID":"/blog/emoji/:1:10","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"否定的表情 图标 代码 图标 代码 😤 triumph 😡 pout rage 😠 angry 😈 smiling_imp 👿 imp 💀 skull ☠️ skull_and_crossbones ","date":"2021-07-01","objectID":"/blog/emoji/:1:11","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"特殊打扮的表情 图标 代码 图标 代码 💩 hankey poop shit 🤡 clown_face 👹 japanese_ogre 👺 japanese_goblin 👻 ghost 👽 alien 👾 space_invader 🤖 robot ","date":"2021-07-01","objectID":"/blog/emoji/:1:12","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"猫脸表情 图标 代码 图标 代码 😺 smiley_cat 😸 smile_cat 😹 joy_cat 😻 heart_eyes_cat 😼 smirk_cat 😽 kissing_cat 🙀 scream_cat 😿 crying_cat_face 😾 pouting_cat ","date":"2021-07-01","objectID":"/blog/emoji/:1:13","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"猴脸表情 图标 代码 图标 代码 🙈 see_no_evil 🙉 hear_no_evil 🙊 speak_no_evil ","date":"2021-07-01","objectID":"/blog/emoji/:1:14","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"情感 图标 代码 图标 代码 💋 kiss 💌 love_letter 💘 cupid 💝 gift_heart 💖 sparkling_heart 💗 heartpulse 💓 heartbeat 💞 revolving_hearts 💕 two_hearts 💟 heart_decoration ❣️ heavy_heart_exclamation 💔 broken_heart ❤️ heart 💛 yellow_heart 💚 green_heart 💙 blue_heart 💜 purple_heart 🖤 black_heart 💯 100 💢 anger 💥 boom collision 💫 dizzy 💦 sweat_drops 💨 dash 🕳️ hole 💣 bomb 💬 speech_balloon 👁️‍🗨️ eye_speech_bubble 🗯️ right_anger_bubble 💭 thought_balloon 💤 zzz ","date":"2021-07-01","objectID":"/blog/emoji/:1:15","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"人与身体 ","date":"2021-07-01","objectID":"/blog/emoji/:2:0","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"张开手掌的手势 图标 代码 图标 代码 👋 wave 🤚 raised_back_of_hand 🖐️ raised_hand_with_fingers_splayed ✋ hand raised_hand 🖖 vulcan_salute ","date":"2021-07-01","objectID":"/blog/emoji/:2:1","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"部分手指的手势 图标 代码 图标 代码 👌 ok_hand ✌️ v 🤞 crossed_fingers 🤘 metal 🤙 call_me_hand ","date":"2021-07-01","objectID":"/blog/emoji/:2:2","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"一根手指的手势 图标 代码 图标 代码 👈 point_left 👉 point_right 👆 point_up_2 🖕 fu middle_finger 👇 point_down ☝️ point_up ","date":"2021-07-01","objectID":"/blog/emoji/:2:3","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"握紧的手势 图标 代码 图标 代码 👍 +1 thumbsup 👎 -1 thumbsdown ✊ fist fist_raised 👊 facepunch fist_oncoming punch 🤛 fist_left 🤜 fist_right ","date":"2021-07-01","objectID":"/blog/emoji/:2:4","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"两只手 图标 代码 图标 代码 👏 clap 🙌 raised_hands 👐 open_hands 🤝 handshake 🙏 pray ","date":"2021-07-01","objectID":"/blog/emoji/:2:5","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"握住东西的手势 图标 代码 图标 代码 ✍️ writing_hand 💅 nail_care 🤳 selfie ","date":"2021-07-01","objectID":"/blog/emoji/:2:6","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"身体部位 图标 代码 图标 代码 💪 muscle 👂 ear 👃 nose 👀 eyes 👁️ eye 👅 tongue 👄 lips ","date":"2021-07-01","objectID":"/blog/emoji/:2:7","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"人 图标 代码 图标 代码 👶 baby 👦 boy 👧 girl :blonde_man: blonde_man person_with_blond_hair 👨 man 👩 woman 👱‍♀️ blonde_woman 👴 older_man 👵 older_woman ","date":"2021-07-01","objectID":"/blog/emoji/:2:8","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"身体动作 图标 代码 图标 代码 🙍‍♀️ frowning_woman person_frowning 🙍‍♂️ frowning_man 🙎‍♀️ person_with_pouting_face pouting_woman 🙎‍♂️ pouting_man 🙅‍♀️ ng_woman no_good no_good_woman 🙅‍♂️ ng_man no_good_man 🙆‍♀️ ok_woman 🙆‍♂️ ok_man 💁‍♀️ information_desk_person sassy_woman tipping_hand_woman 💁‍♂️ sassy_man tipping_hand_man 🙋‍♀️ raising_hand raising_hand_woman 🙋‍♂️ raising_hand_man 🙇 bow bowing_man 🙇‍♀️ bowing_woman 🤦‍♂️ man_facepalming 🤦‍♀️ woman_facepalming 🤷‍♂️ man_shrugging 🤷‍♀️ woman_shrugging ","date":"2021-07-01","objectID":"/blog/emoji/:2:9","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"人物角色 图标 代码 图标 代码 👨‍⚕️ man_health_worker 👩‍⚕️ woman_health_worker 👨‍🎓 man_student 👩‍🎓 woman_student 👨‍🏫 man_teacher 👩‍🏫 woman_teacher 👨‍⚖️ man_judge 👩‍⚖️ woman_judge 👨‍🌾 man_farmer 👩‍🌾 woman_farmer 👨‍🍳 man_cook 👩‍🍳 woman_cook 👨‍🔧 man_mechanic 👩‍🔧 woman_mechanic 👨‍🏭 man_factory_worker 👩‍🏭 woman_factory_worker 👨‍💼 man_office_worker 👩‍💼 woman_office_worker 👨‍🔬 man_scientist 👩‍🔬 woman_scientist 👨‍💻 man_technologist 👩‍💻 woman_technologist 👨‍🎤 man_singer 👩‍🎤 woman_singer 👨‍🎨 man_artist 👩‍🎨 woman_artist 👨‍✈️ man_pilot 👩‍✈️ woman_pilot 👨‍🚀 man_astronaut 👩‍🚀 woman_astronaut 👨‍🚒 man_firefighter 👩‍🚒 woman_firefighter 👮‍♂️ cop policeman 👮‍♀️ policewoman 🕵 detective male_detective 🕵️‍♀️ female_detective 💂‍♂️ guardsman 💂‍♀️ guardswoman 👷‍♂️ construction_worker construction_worker_man 👷‍♀️ construction_worker_woman 🤴 prince 👸 princess 👳‍♂️ man_with_turban 👳‍♀️ woman_with_turban 👲 man_with_gua_pi_mao 🤵‍♂️ man_in_tuxedo 👰 bride_with_veil 🤰 pregnant_woman ","date":"2021-07-01","objectID":"/blog/emoji/:2:10","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"幻想的人物 图标 代码 图标 代码 👼 angel 🎅 santa 🤶 mrs_claus ","date":"2021-07-01","objectID":"/blog/emoji/:2:11","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"人物活动 图标 代码 图标 代码 💆‍♀️ massage massage_woman 💆‍♂️ massage_man 💇‍♀️ haircut haircut_woman 💇‍♂️ haircut_man 🚶‍♂️ walking walking_man 🚶‍♀️ walking_woman 🏃‍♂️ runner running running_man 🏃‍♀️ running_woman 💃 dancer 🕺 man_dancing 🕴️ business_suit_levitating 👯‍♀️ dancers dancing_women 👯‍♂️ dancing_men ","date":"2021-07-01","objectID":"/blog/emoji/:2:12","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"体育 图标 代码 图标 代码 🤺 person_fencing 🏇 horse_racing ⛷️ skier 🏂 snowboarder 🏌️‍♂️ golfing_man 🏌️‍♀️ golfing_woman 🏄‍♂️ surfer surfing_man 🏄‍♀️ surfing_woman 🚣‍♂️ rowboat rowing_man 🚣‍♀️ rowing_woman 🏊‍♂️ swimmer swimming_man 🏊‍♀️ swimming_woman ⛹️‍♂️ basketball_man ⛹️‍♀️ basketball_woman 🏋️‍♂️ weight_lifting_man 🏋️‍♀️ weight_lifting_woman 🚴‍♂️ bicyclist biking_man 🚴‍♀️ biking_woman 🚵‍♂️ mountain_bicyclist mountain_biking_man 🚵‍♀️ mountain_biking_woman 🤸‍♂️ man_cartwheeling 🤸‍♀️ woman_cartwheeling 🤼‍♂️ men_wrestling 🤼‍♀️ women_wrestling 🤽‍♂️ man_playing_water_polo 🤽‍♀️ woman_playing_water_polo 🤾‍♂️ man_playing_handball 🤾‍♀️ woman_playing_handball 🤹‍♂️ man_juggling 🤹‍♀️ woman_juggling ","date":"2021-07-01","objectID":"/blog/emoji/:2:13","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"休息 图标 代码 图标 代码 🛀 bath 🛌 sleeping_bed ","date":"2021-07-01","objectID":"/blog/emoji/:2:14","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"家庭 图标 代码 图标 代码 👭 two_women_holding_hands 👫 couple 👬 two_men_holding_hands 👩‍❤️‍💋‍👨 couplekiss_man_woman 👨‍❤️‍💋‍👨 couplekiss_man_man 👩‍❤️‍💋‍👩 couplekiss_woman_woman 💑 couple_with_heart couple_with_heart_woman_man 👨‍❤️‍👨 couple_with_heart_man_man 👩‍❤️‍👩 couple_with_heart_woman_woman 👨‍👩‍👦 family family_man_woman_boy 👨‍👩‍👧 family_man_woman_girl 👨‍👩‍👧‍👦 family_man_woman_girl_boy 👨‍👩‍👦‍👦 family_man_woman_boy_boy 👨‍👩‍👧‍👧 family_man_woman_girl_girl 👨‍👨‍👦 family_man_man_boy 👨‍👨‍👧 family_man_man_girl 👨‍👨‍👧‍👦 family_man_man_girl_boy 👨‍👨‍👦‍👦 family_man_man_boy_boy 👨‍👨‍👧‍👧 family_man_man_girl_girl 👩‍👩‍👦 family_woman_woman_boy 👩‍👩‍👧 family_woman_woman_girl 👩‍👩‍👧‍👦 family_woman_woman_girl_boy 👩‍👩‍👦‍👦 family_woman_woman_boy_boy 👩‍👩‍👧‍👧 family_woman_woman_girl_girl 👨‍👦 family_man_boy 👨‍👦‍👦 family_man_boy_boy 👨‍👧 family_man_girl 👨‍👧‍👦 family_man_girl_boy 👨‍👧‍👧 family_man_girl_girl 👩‍👦 family_woman_boy 👩‍👦‍👦 family_woman_boy_boy 👩‍👧 family_woman_girl 👩‍👧‍👦 family_woman_girl_boy 👩‍👧‍👧 family_woman_girl_girl ","date":"2021-07-01","objectID":"/blog/emoji/:2:15","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"人物符号 图标 代码 图标 代码 🗣 speaking_head 👤 bust_in_silhouette 👥 busts_in_silhouette 👣 footprints ","date":"2021-07-01","objectID":"/blog/emoji/:2:16","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"动物与自然 ","date":"2021-07-01","objectID":"/blog/emoji/:3:0","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"哺乳动物 图标 代码 图标 代码 🐵 monkey_face 🐒 monkey 🦍 gorilla 🐶 dog 🐕 dog2 🐩 poodle 🐺 wolf 🦊 fox_face 🐱 cat 🐈 cat2 🦁 lion 🐯 tiger 🐅 tiger2 🐆 leopard 🐴 horse 🐎 racehorse 🦄 unicorn 🦌 deer 🐮 cow 🐂 ox 🐃 water_buffalo 🐄 cow2 🐷 pig 🐖 pig2 🐗 boar 🐽 pig_nose 🐏 ram 🐑 sheep 🐐 goat 🐪 dromedary_camel 🐫 camel 🐘 elephant 🦏 rhinoceros 🐭 mouse 🐁 mouse2 🐀 rat 🐹 hamster 🐰 rabbit 🐇 rabbit2 🐿️ chipmunk 🦇 bat 🐻 bear 🐨 koala 🐼 panda_face 🐾 feet paw_prints ","date":"2021-07-01","objectID":"/blog/emoji/:3:1","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"鸟类 图标 代码 图标 代码 🦃 turkey 🐔 chicken 🐓 rooster 🐣 hatching_chick 🐤 baby_chick 🐥 hatched_chick 🐦 bird 🐧 penguin 🕊 dove 🦅 eagle 🦆 duck 🦉 owl ","date":"2021-07-01","objectID":"/blog/emoji/:3:2","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"两栖动物 icon code icon code 🐸 frog ","date":"2021-07-01","objectID":"/blog/emoji/:3:3","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"爬虫类 图标 代码 图标 代码 🐊 crocodile 🐢 turtle 🦎 lizard 🐍 snake 🐲 dragon_face 🐉 dragon ","date":"2021-07-01","objectID":"/blog/emoji/:3:4","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"海洋动物 图标 代码 图标 代码 🐳 whale 🐋 whale2 🐬 dolphin flipper 🐟 fish 🐠 tropical_fish 🐡 blowfish 🦈 shark 🐙 octopus 🐚 shell ","date":"2021-07-01","objectID":"/blog/emoji/:3:5","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"虫类 图标 代码 图标 代码 🐌 snail 🦋 butterfly 🐛 bug 🐜 ant 🐝 bee honeybee 🪲 beetle 🕷️ spider 🕸️ spider_web 🦂 scorpion ","date":"2021-07-01","objectID":"/blog/emoji/:3:6","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"花类植物 图标 代码 图标 代码 💐 bouquet 🌸 cherry_blossom 💮 white_flower 🏵️ rosette 🌹 rose 🥀 wilted_flower 🌺 hibiscus 🌻 sunflower 🌼 blossom 🌷 tulip ","date":"2021-07-01","objectID":"/blog/emoji/:3:7","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"其它植物 图标 代码 图标 代码 🌱 seedling 🌲 evergreen_tree 🌳 deciduous_tree 🌴 palm_tree 🌵 cactus 🌾 ear_of_rice 🌿 herb ☘️ shamrock 🍀 four_leaf_clover 🍁 maple_leaf 🍂 fallen_leaf 🍃 leaves ","date":"2021-07-01","objectID":"/blog/emoji/:3:8","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"食物与饮料 ","date":"2021-07-01","objectID":"/blog/emoji/:4:0","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"水果 图标 代码 图标 代码 🍇 grapes 🍈 melon 🍉 watermelon 🍊 mandarin orange tangerine 🍋 lemon 🍌 banana 🍍 pineapple 🍎 apple 🍏 green_apple 🍐 pear 🍑 peach 🍒 cherries 🍓 strawberry 🥝 kiwi_fruit 🍅 tomato ","date":"2021-07-01","objectID":"/blog/emoji/:4:1","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"蔬菜 图标 代码 图标 代码 🥑 avocado 🍆 eggplant 🥔 potato 🥕 carrot 🌽 corn 🌶️ hot_pepper 🥒 cucumber 🍄 mushroom 🥜 peanuts 🌰 chestnut ","date":"2021-07-01","objectID":"/blog/emoji/:4:2","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"快餐 图标 代码 图标 代码 🍞 bread 🥐 croissant 🥖 baguette_bread 🥞 pancakes 🧀 cheese 🍖 meat_on_bone 🍗 poultry_leg 🥓 bacon 🍔 hamburger 🍟 fries 🍕 pizza 🌭 hotdog 🌮 taco 🌯 burrito 🥙 stuffed_flatbread 🥚 egg 🍳 fried_egg 🥘 shallow_pan_of_food 🍲 stew 🥗 green_salad 🍿 popcorn ","date":"2021-07-01","objectID":"/blog/emoji/:4:3","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"亚洲食物 图标 代码 图标 代码 🍱 bento 🍘 rice_cracker 🍙 rice_ball 🍚 rice 🍛 curry 🍜 ramen 🍝 spaghetti 🍠 sweet_potato 🍢 oden 🍣 sushi 🍤 fried_shrimp 🍥 fish_cake 🍡 dango ","date":"2021-07-01","objectID":"/blog/emoji/:4:4","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"海鲜 图标 代码 图标 代码 🦀 crab 🦐 shrimp 🦑 squid ","date":"2021-07-01","objectID":"/blog/emoji/:4:5","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"甜点 图标 代码 图标 代码 🍦 icecream 🍧 shaved_ice 🍨 ice_cream 🍩 doughnut 🍪 cookie 🎂 birthday 🍰 cake 🍫 chocolate_bar 🍬 candy 🍭 lollipop 🍮 custard 🍯 honey_pot ","date":"2021-07-01","objectID":"/blog/emoji/:4:6","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"饮料 图标 代码 图标 代码 🍼 baby_bottle 🥛 milk_glass ☕ coffee 🍵 tea 🍶 sake 🍾 champagne 🍷 wine_glass 🍸 cocktail 🍹 tropical_drink 🍺 beer 🍻 beers 🥂 clinking_glasses 🥃 tumbler_glass ","date":"2021-07-01","objectID":"/blog/emoji/:4:7","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"餐具 图标 代码 图标 代码 🍽️ plate_with_cutlery 🍴 fork_and_knife 🥄 spoon 🔪 hocho knife 🏺 amphora ","date":"2021-07-01","objectID":"/blog/emoji/:4:8","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"旅游与地理 ","date":"2021-07-01","objectID":"/blog/emoji/:5:0","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"地图 图标 代码 图标 代码 🌍 earth_africa 🌎 earth_americas 🌏 earth_asia 🌐 globe_with_meridians 🗺️ world_map 🗾 japan ","date":"2021-07-01","objectID":"/blog/emoji/:5:1","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"地理现象 图标 代码 图标 代码 🏔 mountain_snow ⛰️ mountain 🌋 volcano 🗻 mount_fuji 🏕️ camping ⛱ beach_umbrella 🏜️ desert 🏝️ desert_island 🏞️ national_park ","date":"2021-07-01","objectID":"/blog/emoji/:5:2","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"建筑物 图标 代码 图标 代码 🏟️ stadium 🏛️ classical_building 🏗️ building_construction 🏘 houses 🏚 derelict_house 🏠 house 🏡 house_with_garden 🏢 office 🏣 post_office 🏤 european_post_office 🏥 hospital 🏦 bank 🏨 hotel 🏩 love_hotel 🏪 convenience_store 🏫 school 🏬 department_store 🏭 factory 🏯 japanese_castle 🏰 european_castle 💒 wedding 🗼 tokyo_tower 🗽 statue_of_liberty ","date":"2021-07-01","objectID":"/blog/emoji/:5:3","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"宗教建筑 图标 代码 图标 代码 ⛪ church 🕌 mosque 🕍 synagogue ⛩️ shinto_shrine 🕋 kaaba ","date":"2021-07-01","objectID":"/blog/emoji/:5:4","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"其它地点 图标 代码 图标 代码 ⛲ fountain ⛺ tent 🌁 foggy 🌃 night_with_stars 🏙️ cityscape 🌄 sunrise_over_mountains 🌅 sunrise 🌆 city_sunset 🌇 city_sunrise 🌉 bridge_at_night ♨️ hotsprings 🎠 carousel_horse 🎡 ferris_wheel 🎢 roller_coaster 💈 barber 🎪 circus_tent ","date":"2021-07-01","objectID":"/blog/emoji/:5:5","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"陆路运输 图标 代码 图标 代码 🚂 steam_locomotive 🚃 railway_car 🚄 bullettrain_side 🚅 bullettrain_front 🚆 train2 🚇 metro 🚈 light_rail 🚉 station 🚊 tram 🚝 monorail 🚞 mountain_railway 🚋 train 🚌 bus 🚍 oncoming_bus 🚎 trolleybus 🚐 minibus 🚑 ambulance 🚒 fire_engine 🚓 police_car 🚔 oncoming_police_car 🚕 taxi 🚖 oncoming_taxi 🚗 car red_car 🚘 oncoming_automobile 🚙 blue_car 🚚 truck 🚛 articulated_lorry 🚜 tractor 🏎️ racing_car 🏍 motorcycle 🛵 motor_scooter 🚲 bike 🛴 kick_scooter 🚏 busstop 🛣️ motorway 🛤️ railway_track 🛢️ oil_drum ⛽ fuelpump 🚨 rotating_light 🚥 traffic_light 🚦 vertical_traffic_light 🛑 stop_sign 🚧 construction ","date":"2021-07-01","objectID":"/blog/emoji/:5:6","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"水路运输 图标 代码 图标 代码 ⚓ anchor ⛵ boat sailboat 🛶 canoe 🚤 speedboat 🛳️ passenger_ship ⛴️ ferry 🛥️ motor_boat 🚢 ship ","date":"2021-07-01","objectID":"/blog/emoji/:5:7","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"空中运输 图标 代码 图标 代码 ✈️ airplane 🛩️ small_airplane 🛫 flight_departure 🛬 flight_arrival 💺 seat 🚁 helicopter 🚟 suspension_railway 🚠 mountain_cableway 🚡 aerial_tramway 🛰️ artificial_satellite 🚀 rocket ","date":"2021-07-01","objectID":"/blog/emoji/:5:8","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"旅馆 icon code icon code 🛎️ bellhop_bell ","date":"2021-07-01","objectID":"/blog/emoji/:5:9","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"时间 图标 代码 图标 代码 ⌛ hourglass ⏳ hourglass_flowing_sand ⌚ watch ⏰ alarm_clock ⏱️ stopwatch ⏲️ timer_clock 🕰️ mantelpiece_clock 🕛 clock12 🕧 clock1230 🕐 clock1 🕜 clock130 🕑 clock2 🕝 clock230 🕒 clock3 🕞 clock330 🕓 clock4 🕟 clock430 🕔 clock5 🕠 clock530 🕕 clock6 🕡 clock630 🕖 clock7 🕢 clock730 🕗 clock8 🕣 clock830 🕘 clock9 🕤 clock930 🕙 clock10 🕥 clock1030 🕚 clock11 🕦 clock1130 ","date":"2021-07-01","objectID":"/blog/emoji/:5:10","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"天空与天气 图标 代码 图标 代码 🌑 new_moon 🌒 waxing_crescent_moon 🌓 first_quarter_moon 🌔 moon waxing_gibbous_moon 🌕 full_moon 🌖 waning_gibbous_moon 🌗 last_quarter_moon 🌘 waning_crescent_moon 🌙 crescent_moon 🌚 new_moon_with_face 🌛 first_quarter_moon_with_face 🌜 last_quarter_moon_with_face 🌡️ thermometer ☀️ sunny 🌝 full_moon_with_face 🌞 sun_with_face ⭐ star 🌟 star2 🌠 stars 🌌 milky_way ☁️ cloud ⛅ partly_sunny ⛈ cloud_with_lightning_and_rain 🌤 sun_behind_small_cloud 🌥 sun_behind_large_cloud 🌦 sun_behind_rain_cloud 🌧 cloud_with_rain 🌨 cloud_with_snow 🌩 cloud_with_lightning 🌪️ tornado 🌫️ fog 🌬 wind_face 🌀 cyclone 🌈 rainbow 🌂 closed_umbrella ☂️ open_umbrella ☂️ umbrella ⛱️ parasol_on_ground ⚡ zap ❄️ snowflake ☃️ snowman_with_snow ☃️ snowman ☄️ comet 🔥 fire 💧 droplet 🌊 ocean ","date":"2021-07-01","objectID":"/blog/emoji/:5:11","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"活动 ","date":"2021-07-01","objectID":"/blog/emoji/:6:0","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"事件 图标 代码 图标 代码 🎃 jack_o_lantern 🎄 christmas_tree 🎆 fireworks 🎇 sparkler ✨ sparkles 🎈 balloon 🎉 tada 🎊 confetti_ball 🎋 tanabata_tree 🎍 bamboo 🎎 dolls 🎏 flags 🎐 wind_chime 🎑 rice_scene 🎀 ribbon 🎁 gift 🎗️ reminder_ribbon 🎟 tickets 🎫 ticket ","date":"2021-07-01","objectID":"/blog/emoji/:6:1","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"奖杯与奖牌 图标 代码 图标 代码 🎖️ medal_military 🏆 trophy 🏅 medal_sports 🥇 1st_place_medal 🥈 2nd_place_medal 🥉 3rd_place_medal ","date":"2021-07-01","objectID":"/blog/emoji/:6:2","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"体育运动 图标 代码 图标 代码 ⚽ soccer ⚾ baseball 🏀 basketball 🏐 volleyball 🏈 football 🏉 rugby_football 🎾 tennis 🎳 bowling 🦗 cricket 🏑 field_hockey 🏒 ice_hockey 🏓 ping_pong 🏸 badminton 🥊 boxing_glove 🥋 martial_arts_uniform 🥅 goal_net ⛳ golf ⛸️ ice_skate 🎣 fishing_pole_and_fish 🎽 running_shirt_with_sash 🎿 ski ","date":"2021-07-01","objectID":"/blog/emoji/:6:3","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"游戏 图标 代码 图标 代码 🎯 dart 🎱 8ball 🔮 crystal_ball 🎮 video_game 🕹️ joystick 🎰 slot_machine 🎲 game_die ♠️ spades ♥️ hearts ♦️ diamonds ♣️ clubs 🃏 black_joker 🀄 mahjong 🎴 flower_playing_cards ","date":"2021-07-01","objectID":"/blog/emoji/:6:4","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"艺术与工艺 图标 代码 图标 代码 🎭 performing_arts 🖼 framed_picture 🎨 art ","date":"2021-07-01","objectID":"/blog/emoji/:6:5","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"物品 ","date":"2021-07-01","objectID":"/blog/emoji/:7:0","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"服装 图标 代码 图标 代码 👓 eyeglasses 🕶️ dark_sunglasses 👔 necktie 👕 shirt tshirt 👖 jeans 👗 dress 👘 kimono 👙 bikini 👚 womans_clothes 👛 purse 👜 handbag 👝 pouch 🛍️ shopping 🎒 school_satchel 👞 mans_shoe shoe 👟 athletic_shoe 👠 high_heel 👡 sandal 👢 boot 👑 crown 👒 womans_hat 🎩 tophat 🎓 mortar_board ⛑️ rescue_worker_helmet 📿 prayer_beads 💄 lipstick 💍 ring 💎 gem ","date":"2021-07-01","objectID":"/blog/emoji/:7:1","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"声音 图标 代码 图标 代码 🔇 mute 🔈 speaker 🔉 sound 🔊 loud_sound 📢 loudspeaker 📣 mega 📯 postal_horn 🔔 bell 🔕 no_bell ","date":"2021-07-01","objectID":"/blog/emoji/:7:2","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"音乐 图标 代码 图标 代码 🎼 musical_score 🎵 musical_note 🎶 notes 🎙️ studio_microphone 🎚️ level_slider 🎛️ control_knobs 🎤 microphone 🎧 headphones 📻 radio ","date":"2021-07-01","objectID":"/blog/emoji/:7:3","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"乐器 图标 代码 图标 代码 🎷 saxophone 🎸 guitar 🎹 musical_keyboard 🎺 trumpet 🎻 violin 🥁 drum ","date":"2021-07-01","objectID":"/blog/emoji/:7:4","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"电话 图标 代码 图标 代码 📱 iphone 📲 calling ☎️ phone telephone 📞 telephone_receiver 📟 pager 📠 fax ","date":"2021-07-01","objectID":"/blog/emoji/:7:5","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"电脑 图标 代码 图标 代码 🔋 battery 🔌 electric_plug 💻 computer 🖥️ desktop_computer 🖨️ printer ⌨️ keyboard 🖱 computer_mouse 🖲️ trackball 💽 minidisc 💾 floppy_disk 💿 cd 📀 dvd ","date":"2021-07-01","objectID":"/blog/emoji/:7:6","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"灯光与影像 图标 代码 图标 代码 🎥 movie_camera 🎞️ film_strip 📽️ film_projector 🎬 clapper 📺 tv 📷 camera 📸 camera_flash 📹 video_camera 📼 vhs 🔍 mag 🔎 mag_right 🕯️ candle 💡 bulb 🔦 flashlight 🏮 izakaya_lantern lantern ","date":"2021-07-01","objectID":"/blog/emoji/:7:7","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"书与纸张 图标 代码 图标 代码 📔 notebook_with_decorative_cover 📕 closed_book 📖 book open_book 📗 green_book 📘 blue_book 📙 orange_book 📚 books 📓 notebook 📒 ledger 📃 page_with_curl 📜 scroll 📄 page_facing_up 📰 newspaper 🗞️ newspaper_roll 📑 bookmark_tabs 🔖 bookmark 🏷️ label ","date":"2021-07-01","objectID":"/blog/emoji/:7:8","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"钱 图标 代码 图标 代码 💰 moneybag 💴 yen 💵 dollar 💶 euro 💷 pound 💸 money_with_wings 💳 credit_card 💹 chart ","date":"2021-07-01","objectID":"/blog/emoji/:7:9","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"邮件 图标 代码 图标 代码 ✉️ email envelope 📧 📧 📨 incoming_envelope 📩 envelope_with_arrow 📤 outbox_tray 📥 inbox_tray 📦 package 📫 mailbox 📪 mailbox_closed 📬 mailbox_with_mail 📭 mailbox_with_no_mail 📮 postbox 🗳 ballot_box ","date":"2021-07-01","objectID":"/blog/emoji/:7:10","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"书写 图标 代码 图标 代码 ✏️ pencil2 ✒️ black_nib 🖋 fountain_pen 🖊 pen 🖌 paintbrush 🖍 crayon 📝 memo pencil ","date":"2021-07-01","objectID":"/blog/emoji/:7:11","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"办公 图标 代码 图标 代码 💼 briefcase 📁 file_folder 📂 open_file_folder 🗂️ card_index_dividers 📅 date 📆 calendar 🗒 spiral_notepad 🗓 spiral_calendar 📇 card_index 📈 chart_with_upwards_trend 📉 chart_with_downwards_trend 📊 bar_chart 📋 clipboard 📌 pushpin 📍 round_pushpin 📎 paperclip 🖇 paperclips 📏 straight_ruler 📐 triangular_ruler ✂️ scissors 🗃️ card_file_box 🗄️ file_cabinet 🗑️ wastebasket ","date":"2021-07-01","objectID":"/blog/emoji/:7:12","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"锁 图标 代码 图标 代码 🔒 lock 🔓 unlock 🔏 lock_with_ink_pen 🔐 closed_lock_with_key 🔑 key 🗝️ old_key ","date":"2021-07-01","objectID":"/blog/emoji/:7:13","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"工具 图标 代码 图标 代码 🔨 hammer ⛏️ pick ⚒️ hammer_and_pick 🛠️ hammer_and_wrench 🗡 dagger ⚔️ crossed_swords 🔫 gun 🏹 bow_and_arrow 🛡️ shield 🔧 wrench 🔩 nut_and_bolt ⚙️ gear 🗜 clamp ⚖ balance_scale 🔗 link ⛓️ chains ","date":"2021-07-01","objectID":"/blog/emoji/:7:14","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"科学 图标 代码 图标 代码 ⚗️ alembic 🔬 microscope 🔭 telescope 🛰️ satellite ","date":"2021-07-01","objectID":"/blog/emoji/:7:15","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"医疗 图标 代码 图标 代码 💉 syringe 💊 pill ","date":"2021-07-01","objectID":"/blog/emoji/:7:16","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"生活用品 图标 代码 图标 代码 🚪 door 🛏️ bed 🛋️ couch_and_lamp 🚽 toilet 🚿 shower 🛁 bathtub 🛒 shopping_cart ","date":"2021-07-01","objectID":"/blog/emoji/:7:17","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"其它物品 图标 代码 图标 代码 🚬 smoking ⚰️ coffin ⚱️ funeral_urn 🗿 moyai ","date":"2021-07-01","objectID":"/blog/emoji/:7:18","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"符号 ","date":"2021-07-01","objectID":"/blog/emoji/:8:0","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"交通标识 图标 代码 图标 代码 🏧 atm 🚮 put_litter_in_its_place 🚰 potable_water ♿ wheelchair 🚹 mens 🚺 womens 🚻 restroom 🚼 baby_symbol 🚾 wc 🛂 passport_control 🛃 customs 🛄 baggage_claim 🛅 left_luggage ","date":"2021-07-01","objectID":"/blog/emoji/:8:1","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"警告 图标 代码 图标 代码 ⚠️ warning 🚸 children_crossing ⛔ no_entry 🚫 no_entry_sign 🚳 no_bicycles 🚭 no_smoking 🚯 do_not_litter 🚱 🚱 🚷 no_pedestrians 📵 no_mobile_phones 🔞 underage ☢ radioactive ☣ biohazard ","date":"2021-07-01","objectID":"/blog/emoji/:8:2","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"箭头 图标 代码 图标 代码 ⬆️ arrow_up ↗️ arrow_upper_right ➡️ arrow_right ↘️ arrow_lower_right ⬇️ arrow_down ↙️ arrow_lower_left ⬅️ arrow_left ↖️ arrow_upper_left ↕️ arrow_up_down ↔️ left_right_arrow ↩️ leftwards_arrow_with_hook ↪️ arrow_right_hook ⤴️ arrow_heading_up ⤵️ arrow_heading_down 🔃 arrows_clockwise 🔄 arrows_counterclockwise 🔙 back 🔚 end 🔛 on 🔜 soon 🔝 top ","date":"2021-07-01","objectID":"/blog/emoji/:8:3","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"宗教 图标 代码 图标 代码 🛐 place_of_worship ⚛️ atom_symbol 🕉 om ✡️ star_of_david ☸️ wheel_of_dharma ☯️ yin_yang ✝️ latin_cross ☦️ orthodox_cross ☪️ star_and_crescent ☮️ peace_symbol 🕎 menorah 🔯 six_pointed_star ","date":"2021-07-01","objectID":"/blog/emoji/:8:4","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"生肖 图标 代码 图标 代码 ♈ aries ♉ taurus ♊ gemini ♋ cancer ♌ leo ♍ virgo ♎ libra ♏ scorpius ♐ sagittarius ♑ capricorn ♒ aquarius ♓ pisces ⛎ ophiuchus ","date":"2021-07-01","objectID":"/blog/emoji/:8:5","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"影像符号 图标 代码 图标 代码 🔀 twisted_rightwards_arrows 🔁 repeat 🔂 repeat_one ▶️ arrow_forward ⏩ fast_forward ⏭ next_track_button ⏯ play_or_pause_button ◀️ arrow_backward ⏪ rewind ⏮️ previous_track_button 🔼 arrow_up_small ⏫ arrow_double_up 🔽 arrow_down_small ⏬ arrow_double_down ⏸ pause_button ⏹ stop_button ⏺ record_button 🎦 cinema 🔅 low_brightness 🔆 high_brightness 📶 signal_strength 📳 vibration_mode 📴 mobile_phone_off ","date":"2021-07-01","objectID":"/blog/emoji/:8:6","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"数学 图标 代码 图标 代码 ✖️ heavy_multiplication_x ➕ heavy_plus_sign ➖ heavy_minus_sign ➗ heavy_division_sign ","date":"2021-07-01","objectID":"/blog/emoji/:8:7","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"标点符号 图标 代码 图标 代码 ‼️ bangbang ⁉️ interrobang ❓ question ❔ grey_question ❕ grey_exclamation ❗ exclamation heavy_exclamation_mark 〰️ wavy_dash ","date":"2021-07-01","objectID":"/blog/emoji/:8:8","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"货币 图标 代码 图标 代码 💱 currency_exchange 💲 heavy_dollar_sign ","date":"2021-07-01","objectID":"/blog/emoji/:8:9","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"按键符号 图标 代码 图标 代码 #️⃣ hash *️⃣ asterisk 0️⃣ zero 1️⃣ one 2️⃣ two 3️⃣ three 4️⃣ four 5️⃣ five 6️⃣ six 7️⃣ seven 8️⃣ eight 9️⃣ nine 🔟 keycap_ten ","date":"2021-07-01","objectID":"/blog/emoji/:8:10","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"字母符号 图标 代码 图标 代码 🔠 capital_abcd 🔡 abcd 🔢 1234 🔣 symbols 🔤 abc 🅰️ a 🆎 ab 🅱️ b 🆑 cl 🆒 cool 🆓 free ℹ️ information_source 🆔 id ⓜ️ m 🆕 new 🆖 ng 🅾️ o2 🆗 ok 🅿️ parking 🆘 sos 🆙 up 🆚 vs 🈁 koko 🈂️ sa 🈷️ u6708 🈶 u6709 🈯 u6307 🉐 ideograph_advantage 🈹 u5272 🈚 u7121 🈲 u7981 🉑 accept 🈸 u7533 🈴 u5408 🈳 u7a7a ㊗️ congratulations ㊙️ secret 🈺 u55b6 🈵 u6e80 ","date":"2021-07-01","objectID":"/blog/emoji/:8:11","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"几何符号 图标 代码 图标 代码 🔴 red_circle 🔵 large_blue_circle ⚫ black_circle ⚪ white_circle ⬛ black_large_square ⬜ white_large_square ◼️ black_medium_square ◻️ white_medium_square ◾ black_medium_small_square ◽ white_medium_small_square ▪️ black_small_square ▫️ white_small_square 🔶 large_orange_diamond 🔷 large_blue_diamond 🔸 small_orange_diamond 🔹 small_blue_diamond 🔺 small_red_triangle 🔻 small_red_triangle_down 💠 diamond_shape_with_a_dot_inside 🔘 radio_button 🔳 white_square_button 🔲 black_square_button ","date":"2021-07-01","objectID":"/blog/emoji/:8:12","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"其它符合 图标 代码 图标 代码 ♻️ recycle ⚜️ fleur_de_lis 🔱 trident 📛 name_badge 🔰 beginner ⭕ o ✅ white_check_mark ☑️ ballot_box_with_check ✔️ heavy_check_mark ❌ x ❎ negative_squared_cross_mark ➰ curly_loop ➿ loop 〽️ part_alternation_mark ✳️ eight_spoked_asterisk ✴️ eight_pointed_black_star ❇️ sparkle ©️ copyright ®️ registered ™️ tm ","date":"2021-07-01","objectID":"/blog/emoji/:8:13","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"旗帜 ","date":"2021-07-01","objectID":"/blog/emoji/:9:0","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"常用旗帜 图标 代码 图标 代码 🏁 checkered_flag 🚩 triangular_flag_on_post 🎌 crossed_flags 🏴 black_flag 🏳 white_flag 🏳️‍🌈 rainbow_flag ","date":"2021-07-01","objectID":"/blog/emoji/:9:1","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"},{"categories":["Hugo"],"content":"国家和地区旗帜 图标 代码 图标 代码 🇦🇩 andorra 🇦🇪 united_arab_emirates 🇦🇫 afghanistan 🇦🇬 antigua_barbuda 🇦🇮 anguilla 🇦🇱 albania 🇦🇲 armenia 🇦🇴 angola 🇦🇶 antarctica 🇦🇷 argentina 🇦🇸 american_samoa 🇦🇹 austria 🇦🇺 australia 🇦🇼 aruba 🇦🇽 aland_islands 🇦🇿 azerbaijan 🇧🇦 bosnia_herzegovina 🇧🇧 barbados 🇧🇩 bangladesh 🇧🇪 belgium 🇧🇫 burkina_faso 🇧🇬 bulgaria 🇧🇭 bahrain 🇧🇮 burundi 🇧🇯 benin 🇧🇱 st_barthelemy 🇧🇲 bermuda 🇧🇳 brunei 🇧🇴 bolivia 🇧🇶 caribbean_netherlands 🇧🇷 brazil 🇧🇸 bahamas 🇧🇹 bhutan 🇧🇼 botswana 🇧🇾 belarus 🇧🇿 belize 🇨🇦 canada 🇨🇨 cocos_islands 🇨🇩 congo_kinshasa 🇨🇫 central_african_republic 🇨🇬 congo_brazzaville 🇨🇭 switzerland 🇨🇮 cote_divoire 🇨🇰 cook_islands 🇨🇱 chile 🇨🇲 cameroon 🇨🇳 cn 🇨🇴 colombia 🇨🇷 costa_rica 🇨🇺 cuba 🇨🇻 cape_verde 🇨🇼 curacao 🇨🇽 christmas_island 🇨🇾 cyprus 🇨🇿 czech_republic 🇩🇪 de 🇩🇯 djibouti 🇩🇰 denmark 🇩🇲 dominica 🇩🇴 dominican_republic 🇩🇿 algeria 🇪🇨 ecuador 🇪🇪 estonia 🇪🇬 egypt 🇪🇭 western_sahara 🇪🇷 eritrea 🇪🇸 es 🇪🇹 ethiopia 🇪🇺 eu european_union 🇫🇮 finland 🇫🇯 fiji 🇫🇰 falkland_islands 🇫🇲 micronesia 🇫🇴 faroe_islands 🇫🇷 fr 🇬🇦 gabon 🇬🇧 gb uk 🇬🇩 grenada 🇬🇪 georgia 🇬🇫 french_guiana 🇬🇬 guernsey 🇬🇭 ghana 🇬🇮 gibraltar 🇬🇱 greenland 🇬🇲 gambia 🇬🇳 guinea 🇬🇵 guadeloupe 🇬🇶 equatorial_guinea 🇬🇷 greece 🇬🇸 south_georgia_south_sandwich_islands 🇬🇹 guatemala 🇬🇺 guam 🇬🇼 guinea_bissau 🇬🇾 guyana 🇭🇰 hong_kong 🇭🇳 honduras 🇭🇷 croatia 🇭🇹 haiti 🇭🇺 hungary 🇮🇨 canary_islands 🇮🇩 indonesia 🇮🇪 ireland 🇮🇱 israel 🇮🇲 isle_of_man 🇮🇳 india 🇮🇴 british_indian_ocean_territory 🇮🇶 iraq 🇮🇷 iran 🇮🇸 iceland 🇮🇹 it 🇯🇪 jersey 🇯🇲 jamaica 🇯🇴 jordan 🇯🇵 jp 🇰🇪 kenya 🇰🇬 kyrgyzstan 🇰🇭 cambodia 🇰🇮 kiribati 🇰🇲 comoros 🇰🇳 st_kitts_nevis 🇰🇵 north_korea 🇰🇷 kr 🇰🇼 kuwait 🇰🇾 cayman_islands 🇰🇿 kazakhstan 🇱🇦 laos 🇱🇧 lebanon 🇱🇨 st_lucia 🇱🇮 liechtenstein 🇱🇰 sri_lanka 🇱🇷 liberia 🇱🇸 lesotho 🇱🇹 lithuania 🇱🇺 luxembourg 🇱🇻 latvia 🇱🇾 libya 🇲🇦 morocco 🇲🇨 monaco 🇲🇩 moldova 🇲🇪 montenegro 🇲🇬 madagascar 🇲🇭 marshall_islands 🇲🇰 macedonia 🇲🇱 mali 🇲🇲 myanmar 🇲🇳 mongolia 🇲🇴 macau 🇲🇵 northern_mariana_islands 🇲🇶 martinique 🇲🇷 mauritania 🇲🇸 montserrat 🇲🇹 malta 🇲🇺 mauritius 🇲🇻 maldives 🇲🇼 malawi 🇲🇽 mexico 🇲🇾 malaysia 🇲🇿 mozambique 🇳🇦 namibia 🇳🇨 new_caledonia 🇳🇪 niger 🇳🇫 norfolk_island 🇳🇬 nigeria 🇳🇮 nicaragua 🇳🇱 netherlands 🇳🇴 norway 🇳🇵 nepal 🇳🇷 nauru 🇳🇺 niue 🇳🇿 new_zealand 🇴🇲 oman 🇵🇦 panama 🇵🇪 peru 🇵🇫 french_polynesia 🇵🇬 papua_new_guinea 🇵🇭 philippines 🇵🇰 pakistan 🇵🇱 poland 🇵🇲 st_pierre_miquelon 🇵🇳 pitcairn_islands 🇵🇷 puerto_rico 🇵🇸 palestinian_territories 🇵🇹 portugal 🇵🇼 palau 🇵🇾 paraguay 🇶🇦 qatar 🇷🇪 reunion 🇷🇴 romania 🇷🇸 serbia 🇷🇺 ru 🇷🇼 rwanda 🇸🇦 saudi_arabia 🇸🇧 solomon_islands 🇸🇨 seychelles 🇸🇩 sudan 🇸🇪 sweden 🇸🇬 singapore 🇸🇭 st_helena 🇸🇮 slovenia 🇸🇰 slovakia 🇸🇱 sierra_leone 🇸🇲 san_marino 🇸🇳 senegal 🇸🇴 somalia 🇸🇷 suriname 🇸🇸 south_sudan 🇸🇹 sao_tome_principe 🇸🇻 el_salvador 🇸🇽 sint_maarten 🇸🇾 syria 🇸🇿 swaziland 🇹🇨 turks_caicos_islands 🇹🇩 chad 🇹🇫 french_southern_territories 🇹🇬 togo 🇹🇭 thailand 🇹🇯 tajikistan 🇹🇰 tokelau 🇹🇱 timor_leste 🇹🇲 turkmenistan 🇹🇳 tunisia 🇹🇴 tonga 🇹🇷 tr 🇹🇹 trinidad_tobago 🇹🇻 tuvalu 🇹🇼 taiwan 🇹🇿 tanzania 🇺🇦 ukraine 🇺🇬 uganda 🇺🇸 us 🇺🇾 uruguay 🇺🇿 uzbekistan 🇻🇦 vatican_city 🇻🇨 st_vincent_grenadines 🇻🇪 venezuela 🇻🇬 british_virgin_islands 🇻🇮 us_virgin_islands 🇻🇳 vietnam 🇻🇺 vanuatu 🇼🇫 wallis_futuna 🇼🇸 samoa 🇽🇰 kosovo 🇾🇪 yemen 🇾🇹 mayotte 🇿🇦 south_africa 🇿🇲 zambia 🇿🇼 zimbabwe ","date":"2021-07-01","objectID":"/blog/emoji/:9:2","tags":["emoji"],"title":"Emoji 支持","uri":"/blog/emoji/"}]